{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC20Snapshot.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ArraysUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\n * total supply at the time are recorded for later access.\n *\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\n * used to create an efficient ERC20 forking mechanism.\n *\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\n * and the account address.\n *\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\n *\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\n * alternative consider {ERC20Votes}.\n *\n * ==== Gas Costs\n *\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\n *\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\n * transfers will have normal cost until the next snapshot, and so on.\n */\n\nabstract contract ERC20SnapshotUpgradeable is Initializable, ERC20Upgradeable {\n    function __ERC20Snapshot_init() internal onlyInitializing {\n    }\n\n    function __ERC20Snapshot_init_unchained() internal onlyInitializing {\n    }\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\n    // https://github.com/Giveth/minime/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\n\n    using ArraysUpgradeable for uint256[];\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n    // Snapshot struct, but that would impede usage of functions that work on an array.\n    struct Snapshots {\n        uint256[] ids;\n        uint256[] values;\n    }\n\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\n    Snapshots private _totalSupplySnapshots;\n\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n    CountersUpgradeable.Counter private _currentSnapshotId;\n\n    /**\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\n     */\n    event Snapshot(uint256 id);\n\n    /**\n     * @dev Creates a new snapshot and returns its snapshot id.\n     *\n     * Emits a {Snapshot} event that contains the same id.\n     *\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\n     *\n     * [WARNING]\n     * ====\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n     * you must consider that it can potentially be used by attackers in two ways.\n     *\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n     * section above.\n     *\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n     * ====\n     */\n    function _snapshot() internal virtual returns (uint256) {\n        _currentSnapshotId.increment();\n\n        uint256 currentId = _getCurrentSnapshotId();\n        emit Snapshot(currentId);\n        return currentId;\n    }\n\n    /**\n     * @dev Get the current snapshotId\n     */\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\n        return _currentSnapshotId.current();\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return snapshotted ? value : balanceOf(account);\n    }\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n\n        return snapshotted ? value : totalSupply();\n    }\n\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\n        require(snapshotId <= _getCurrentSnapshotId(), \"ERC20Snapshot: nonexistent id\");\n\n        // When a valid snapshot is queried, there are three possibilities:\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n        //  to this id is the current one.\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n        //  requested id, and its value is the one to return.\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n        //  larger than the requested one.\n        //\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n        // exactly this.\n\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\n\n        if (index == snapshots.ids.length) {\n            return (false, 0);\n        } else {\n            return (true, snapshots.values[index]);\n        }\n    }\n\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\n    }\n\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\n        uint256 currentId = _getCurrentSnapshotId();\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\n            snapshots.ids.push(currentId);\n            snapshots.values.push(currentValue);\n        }\n    }\n\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\n        if (ids.length == 0) {\n            return 0;\n        } else {\n            return ids[ids.length - 1];\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ArraysUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary ArraysUpgradeable {\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)`  `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/array/LibUint256Array.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\n/// @title Uint256Array\n/// @notice Things we want to do carefully and efficiently with uint256 arrays\n/// that Solidity doesn't give us native tools for.\nlibrary LibUint256Array {\n    using LibUint256Array for uint256[];\n\n    /// Building arrays from literal components is a common task that introduces\n    /// boilerplate that is either inefficient or error prone.\n    /// @param a_ a single integer to build an array around.\n    /// @return the newly allocated array including a_ as a single item.\n    function arrayFrom(uint256 a_) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](1);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n        }\n        return array_;\n    }\n\n    /// Building arrays from literal components is a common task that introduces\n    /// boilerplate that is either inefficient or error prone.\n    /// @param a_ the first integer to build an array around.\n    /// @param b_ the second integer to build an array around.\n    /// @return the newly allocated array including a_ and b_ as the only items.\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](2);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n            mstore(add(array_, 0x40), b_)\n        }\n        return array_;\n    }\n\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](3);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n            mstore(add(array_, 0x40), b_)\n            mstore(add(array_, 0x60), c_)\n        }\n        return array_;\n    }\n\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256 d_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](4);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n            mstore(add(array_, 0x40), b_)\n            mstore(add(array_, 0x60), c_)\n            mstore(add(array_, 0x80), d_)\n        }\n        return array_;\n    }\n\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256 d_,\n        uint256 e_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](5);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n            mstore(add(array_, 0x40), b_)\n            mstore(add(array_, 0x60), c_)\n            mstore(add(array_, 0x80), d_)\n            mstore(add(array_, 0xA0), e_)\n        }\n        return array_;\n    }\n\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256 d_,\n        uint256 e_,\n        uint f_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](6);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n            mstore(add(array_, 0x40), b_)\n            mstore(add(array_, 0x60), c_)\n            mstore(add(array_, 0x80), d_)\n            mstore(add(array_, 0xA0), e_)\n            mstore(add(array_, 0xC0), f_)\n        }\n        return array_;\n    }\n\n    /// Building arrays from literal components is a common task that introduces\n    /// boilerplate that is either inefficient or error prone.\n    /// @param a_ The head of the new array.\n    /// @param tail_ The tail of the new array.\n    /// @return The new array.\n    function arrayFrom(\n        uint256 a_,\n        uint256[] memory tail_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](1);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n        }\n        array_.extend(tail_);\n        return array_;\n    }\n\n    /// Building arrays from literal components is a common task that introduces\n    /// boilerplate that is either inefficient or error prone.\n    /// @param a_ The first item of the new array.\n    /// @param b_ The second item of the new array.\n    /// @param tail_ The tail of the new array.\n    /// @return The new array.\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256[] memory tail_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](2);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n            mstore(add(array_, 0x40), b_)\n        }\n        array_.extend(tail_);\n        return array_;\n    }\n\n    function matrixFrom(\n        uint256[] memory a_\n    ) internal pure returns (uint256[][] memory) {\n        uint256[][] memory matrix_ = new uint256[][](1);\n        assembly (\"memory-safe\") {\n            mstore(add(matrix_, 0x20), a_)\n        }\n        return matrix_;\n    }\n\n    /// Solidity provides no way to change the length of in-memory arrays but\n    /// it also does not deallocate memory ever. It is always safe to shrink an\n    /// array that has already been allocated, with the caveat that the\n    /// truncated items will effectively become inaccessible regions of memory.\n    /// That is to say, we deliberately \"leak\" the truncated items, but that is\n    /// no worse than Solidity's native behaviour of leaking everything always.\n    /// The array is MUTATED in place so there is no return value and there is\n    /// no new allocation or copying of data either.\n    /// @param array_ The array to truncate.\n    /// @param newLength_ The new length of the array after truncation.\n    function truncate(\n        uint256[] memory array_,\n        uint256 newLength_\n    ) internal pure {\n        require(newLength_ <= array_.length, \"OOB_TRUNCATE\");\n        assembly (\"memory-safe\") {\n            mstore(array_, newLength_)\n        }\n    }\n\n    /// Extends `base_` with `extend_` by allocating additional `extend_.length`\n    /// uints onto `base_`. Reverts if some other memory has been allocated\n    /// after `base_` already, in which case it is NOT safe to copy inline.\n    /// If `base_` is large this MAY be significantly more efficient than\n    /// allocating `base_.length + extend_.length` for an entirely new array and\n    /// copying both `base_` and `extend_` into the new array one item at a\n    /// time in Solidity.\n    /// The Solidity compiler MAY rearrange sibling statements in a code block\n    /// EVEN IF THE OPTIMIZER IS DISABLED such that it becomes unsafe to use\n    /// `extend` for memory allocated in different code blocks. It is ONLY safe\n    /// to `extend` arrays that were allocated in the same lexical scope and you\n    /// WILL see subtle errors that revert transactions otherwise.\n    /// i.e. the `new` keyword MUST appear in the same code block as `extend`.\n    /// @param base_ The base integer array that will be extended by `extend_`.\n    /// @param extend_ The integer array that extends `base_`.\n    function extend(\n        uint256[] memory base_,\n        uint256[] memory extend_\n    ) internal pure {\n        uint256 freeMemoryPointer_;\n        assembly (\"memory-safe\") {\n            // Solidity stores free memory pointer at 0x40\n            freeMemoryPointer_ := mload(0x40)\n            let baseLength_ := mload(base_)\n            let extendLength_ := mload(extend_)\n\n            // The freeMemoryPointer_ does NOT point to the end of `base_` so\n            // it is NOT safe to copy `extend_` over the top of already\n            // allocated memory. This happens whenever some memory is allocated\n            // after `base_` is allocated but before `extend` is called.\n            if gt(\n                freeMemoryPointer_,\n                add(base_, add(0x20, mul(0x20, baseLength_)))\n            ) {\n                revert(0, 0)\n            }\n\n            // Move the free memory pointer by the length of extend_, excluding\n            // the length slot of extend as that will NOT be copied to `base_`.\n            mstore(0x40, add(freeMemoryPointer_, mul(0x20, extendLength_)))\n\n            // Update the length of base to be the length of base+extend.\n            mstore(base_, add(baseLength_, extendLength_))\n        }\n\n        unsafeCopyValuesTo(extend_, freeMemoryPointer_);\n    }\n\n    /// Copies `inputs_` to `outputCursor_` with NO attempt to check that this\n    /// is safe to do so. The caller MUST ensure that there exists allocated\n    /// memory at `outputCursor_` in which it is safe and appropriate to copy\n    /// ALL `inputs_` to. Anything that was already written to memory at\n    /// `[outputCursor_:outputCursor_+(inputs_.length * 32 bytes)]` will be\n    /// overwritten. The length of `inputs_` is NOT copied to the output\n    /// location, ONLY the `uint256` values of the `inputs_` array are copied.\n    /// There is no return value as memory is modified directly.\n    /// @param inputs_ The input array that will be copied from EXCLUDING the\n    /// length at the start of the array in memory.\n    /// @param outputCursor_ Location in memory that the values will be copied\n    /// to linearly.\n    function unsafeCopyValuesTo(\n        uint256[] memory inputs_,\n        uint256 outputCursor_\n    ) internal pure {\n        uint256 inputCursor_;\n        assembly (\"memory-safe\") {\n            inputCursor_ := add(inputs_, 0x20)\n        }\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, inputs_.length);\n    }\n\n    /// Copies `length_` 32 byte words from `inputCursor_` to a newly allocated\n    /// uint256[] array with NO attempt to check that the inputs are sane.\n    /// This function is safe in that the outputs are guaranteed to be copied\n    /// to newly allocated memory so no existing data will be overwritten.\n    /// This function is subtle in that the `inputCursor_` is NOT validated in\n    /// any way so the caller MUST ensure it points to a sensible memory\n    /// location to read (e.g. to exclude the length from input arrays etc.).\n    /// @param inputCursor_ The start of the memory that will be copied to the\n    /// newly allocated array.\n    /// @param length_ Number of 32 byte words to copy starting at\n    /// `inputCursor_` to the items of the newly allocated array.\n    /// @return The newly allocated `uint256[]` array.\n    function copyToNewUint256Array(\n        uint256 inputCursor_,\n        uint256 length_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory outputs_ = new uint256[](length_);\n        uint256 outputCursor_;\n        assembly (\"memory-safe\") {\n            outputCursor_ := add(outputs_, 0x20)\n        }\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, length_);\n        return outputs_;\n    }\n\n    /// Copies `length_` uint256 values starting from `inputsCursor_` to\n    /// `outputCursor_` with NO attempt to check that this is safe to do so.\n    /// The caller MUST ensure that there exists allocated memory at\n    /// `outputCursor_` in which it is safe and appropriate to copy\n    /// `length_ * 32` bytes to. Anything that was already written to memory at\n    /// `[outputCursor_:outputCursor_+(length_ * 32 bytes)]` will be\n    /// overwritten.\n    /// There is no return value as memory is modified directly.\n    /// @param inputCursor_ The starting position in memory that data will be\n    /// copied from.\n    /// @param outputCursor_ The starting position in memory that data will be\n    /// copied to.\n    /// @param length_ The number of 32 byte (i.e. `uint256`) values that will\n    /// be copied.\n    function unsafeCopyValuesTo(\n        uint256 inputCursor_,\n        uint256 outputCursor_,\n        uint256 length_\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            for {\n                let end_ := add(inputCursor_, mul(0x20, length_))\n            } lt(inputCursor_, end_) {\n                inputCursor_ := add(inputCursor_, 0x20)\n                outputCursor_ := add(outputCursor_, 0x20)\n            } {\n                mstore(outputCursor_, mload(inputCursor_))\n            }\n        }\n    }\n}\n"
    },
    "contracts/bytes/LibBytes.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\n/// @title LibBytes\n/// @notice Things we want to do carefully and efficiently with `bytes` in memory\n/// that Solidity doesn't give us native tools for.\nlibrary LibBytes {\n    /// Copy an arbitrary number of bytes from one location in memory to another.\n    /// As we can only read/write bytes in 32 byte chunks we first have to loop\n    /// over 32 byte values to copy then handle any unaligned remaining data. The\n    /// remaining data will be appropriately masked with the existing data in the\n    /// final chunk so as to not write past the desired length. Note that the\n    /// final unaligned write will be more gas intensive than the prior aligned\n    /// writes. The writes are completely unsafe, the caller MUST ensure that\n    /// sufficient memory is allocated and reading/writing the requested number\n    /// of bytes from/to the requested locations WILL NOT corrupt memory in the\n    /// opinion of solidity or other subsequent read/write operations.\n    /// @param inputCursor_ The starting location in memory to read from.\n    /// @param outputCursor_ The starting location in memory to write to.\n    /// @param remaining_ The number of bytes to read/write.\n    function unsafeCopyBytesTo(\n        uint256 inputCursor_,\n        uint256 outputCursor_,\n        uint256 remaining_\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            for {\n\n            } iszero(lt(remaining_, 0x20)) {\n                remaining_ := sub(remaining_, 0x20)\n                inputCursor_ := add(inputCursor_, 0x20)\n                outputCursor_ := add(outputCursor_, 0x20)\n            } {\n                mstore(outputCursor_, mload(inputCursor_))\n            }\n\n            if gt(remaining_, 0) {\n                let mask_ := shr(\n                    mul(remaining_, 8),\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n                // preserve existing bytes\n                mstore(\n                    outputCursor_,\n                    or(\n                        // input\n                        and(mload(inputCursor_), not(mask_)),\n                        and(mload(outputCursor_), mask_)\n                    )\n                )\n            }\n        }\n    }\n}\n"
    },
    "contracts/chainlink/LibChainlink.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../math/FixedPointMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nlibrary LibChainlink {\n    using SafeCast for int256;\n    using FixedPointMath for uint256;\n\n    function price(\n        address feed_,\n        uint256 staleAfter_\n    ) internal view returns (uint256) {\n        (, int256 answer_, , uint256 updatedAt_, ) = AggregatorV3Interface(\n            feed_\n        ).latestRoundData();\n        require(answer_ > 0, \"MIN_BASE_PRICE\");\n        // Checked time comparison ensures no updates from the future as that\n        // would overflow, and no stale prices.\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp - updatedAt_ < staleAfter_, \"STALE_PRICE\");\n\n        // Safely cast the answer to uint and scale it to 18 decimal FP.\n        return\n            answer_.toUint256().scale18(\n                AggregatorV3Interface(feed_).decimals()\n            );\n    }\n}\n"
    },
    "contracts/idempotent/LibIdempotentFlag.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../math/Binary.sol\";\n\ntype IdempotentFlag is uint256;\n\nlibrary LibIdempotentFlag {\n    using LibIdempotentFlag for IdempotentFlag;\n\n    function get(\n        IdempotentFlag flag_,\n        uint256 index_\n    ) internal pure returns (bool) {\n        return (IdempotentFlag.unwrap(flag_) >> index_) & 0x01 > 0;\n    }\n\n    function set(\n        IdempotentFlag flag_,\n        uint256 index_\n    ) internal pure returns (IdempotentFlag) {\n        return\n            IdempotentFlag.wrap(\n                IdempotentFlag.unwrap(flag_) | (0x01 << index_)\n            );\n    }\n\n    modifier only16x16(uint256 column_, uint256 row_) {\n        require(column_ < 16, \"OOB_COLUMN\");\n        require(row_ < 16, \"OOB_ROW\");\n        _;\n    }\n\n    function get16x16(\n        IdempotentFlag flag_,\n        uint256 column_,\n        uint256 row_\n    ) internal pure only16x16(column_, row_) returns (bool) {\n        unchecked {\n            return flag_.get(column_ * 16 + row_);\n        }\n    }\n\n    function set16x16(\n        IdempotentFlag flag_,\n        uint256 column_,\n        uint256 row_\n    ) internal pure only16x16(column_, row_) returns (IdempotentFlag) {\n        unchecked {\n            return flag_.set(column_ * 16 + row_);\n        }\n    }\n\n    function set16x16Column(\n        IdempotentFlag flag_,\n        uint column_\n    ) internal pure only16x16(column_, 0) returns (IdempotentFlag) {\n        unchecked {\n            return\n                IdempotentFlag.wrap(\n                    IdempotentFlag.unwrap(flag_) |\n                        (MASK_16BIT << (column_ * 16))\n                );\n        }\n    }\n}\n"
    },
    "contracts/interpreter/deploy/IExpressionDeployerV1.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\n/// Config required to build a new `State`.\n/// @param sources Sources verbatim.\n/// @param constants Constants verbatim.\nstruct StateConfig {\n    bytes[] sources;\n    uint256[] constants;\n}\n\ninterface IExpressionDeployerV1 {\n    function deployExpression(\n        StateConfig memory config,\n        uint[] memory minOutputs\n    ) external returns (address expressionAddress, uint256 contextReads);\n}\n"
    },
    "contracts/interpreter/deploy/IRainInterpreterIntegrity.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"./IExpressionDeployerV1.sol\";\nimport \"./LibIntegrityState.sol\";\n\ninterface IRainInterpreterIntegrity {\n    function ensureIntegrity(\n        bytes[] memory sources,\n        uint256 constantsLength,\n        uint[] memory minStackOutputs\n    ) external view returns (uint256 contextReads, uint256 stackLength);\n}\n"
    },
    "contracts/interpreter/deploy/LibIntegrityState.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../run/RainInterpreter.sol\";\nimport \"../run/LibStackTop.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\nimport \"../run/IInterpreterV1.sol\";\n\nstruct IntegrityState {\n    // Sources first as we read it in assembly.\n    bytes[] sources;\n    uint256 constantsLength;\n    StackTop stackBottom;\n    StackTop stackMaxTop;\n    uint256 contextReads;\n    function(IntegrityState memory, Operand, StackTop)\n        view\n        returns (StackTop)[] integrityFunctionPointers;\n}\n\nlibrary LibIntegrityState {\n    using LibIntegrityState for IntegrityState;\n    using LibStackTop for StackTop;\n    using Math for uint256;\n\n    function syncStackMaxTop(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_\n    ) internal pure {\n        if (\n            StackTop.unwrap(stackTop_) >\n            StackTop.unwrap(integrityState_.stackMaxTop)\n        ) {\n            integrityState_.stackMaxTop = stackTop_;\n        }\n    }\n\n    function ensureIntegrity(\n        IntegrityState memory integrityState_,\n        SourceIndex sourceIndex_,\n        StackTop stackTop_,\n        uint minStackOutputs_\n    ) internal view returns (StackTop) {\n        unchecked {\n            uint256 cursor_;\n            uint256 end_;\n            assembly (\"memory-safe\") {\n                cursor_ := mload(\n                    add(\n                        mload(integrityState_),\n                        add(0x20, mul(0x20, sourceIndex_))\n                    )\n                )\n                end_ := add(cursor_, mload(cursor_))\n            }\n\n            // Loop until complete.\n            while (cursor_ < end_) {\n                uint256 opcode_;\n                Operand operand_;\n                cursor_ += 4;\n                assembly (\"memory-safe\") {\n                    let op_ := mload(cursor_)\n                    operand_ := and(op_, 0xFFFF)\n                    opcode_ := and(shr(16, op_), 0xFFFF)\n                }\n                // We index into the function pointers here to ensure that any\n                // opcodes that we don't have a pointer for will error.\n                stackTop_ = integrityState_.integrityFunctionPointers[opcode_](\n                    integrityState_,\n                    operand_,\n                    stackTop_\n                );\n            }\n            require(\n                minStackOutputs_ <=\n                    integrityState_.stackBottom.toIndex(stackTop_),\n                \"MIN_FINAL_STACK\"\n            );\n            return stackTop_;\n        }\n    }\n\n    function push(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop stackTopAfter_) {\n        stackTopAfter_ = stackTop_.up();\n        integrityState_.syncStackMaxTop(stackTopAfter_);\n    }\n\n    function push(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        uint256 n_\n    ) internal pure returns (StackTop stackTopAfter_) {\n        stackTopAfter_ = stackTop_.up(n_);\n        integrityState_.syncStackMaxTop(stackTopAfter_);\n    }\n\n    function popUnderflowCheck(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_\n    ) internal pure {\n        require(\n            // Stack bottom may be non-zero so check we are above it.\n            (StackTop.unwrap(stackTop_) >=\n                StackTop.unwrap(integrityState_.stackBottom)) &&\n                // If we underflowed zero then we will be above the stack max\n                // top. Assumes that at least 1 item was popped so we can do a\n                // strict inequality check here.\n                (StackTop.unwrap(stackTop_) <\n                    StackTop.unwrap(integrityState_.stackMaxTop)),\n            \"STACK_UNDERFLOW\"\n        );\n    }\n\n    function pop(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop stackTopAfter_) {\n        stackTopAfter_ = stackTop_.down();\n        integrityState_.popUnderflowCheck(stackTopAfter_);\n    }\n\n    function pop(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        uint256 n_\n    ) internal pure returns (StackTop) {\n        if (n_ > 0) {\n            stackTop_ = stackTop_.down(n_);\n            integrityState_.popUnderflowCheck(stackTop_);\n        }\n        return stackTop_;\n    }\n\n    function applyFnN(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256) internal view returns (uint256),\n        uint256 n_\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_, n_));\n    }\n\n    function applyFnN(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256) internal view,\n        uint256 n_\n    ) internal pure returns (StackTop) {\n        return integrityState_.pop(stackTop_, n_);\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256) internal view returns (uint256)\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(Operand, uint256) internal view returns (uint256)\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256) internal view\n    ) internal pure returns (StackTop) {\n        return integrityState_.pop(stackTop_, 2);\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256) internal view returns (uint256)\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_, 2));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(Operand, uint256, uint256) internal view returns (uint256)\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_, 2));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256, uint256) internal view returns (uint256)\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_, 3));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256, uint256, uint)\n            internal\n            view\n            returns (uint256)\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_, 4));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256[] memory) internal view returns (uint256),\n        uint256 length_\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_, length_));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256, uint256[] memory)\n            internal\n            view\n            returns (uint256),\n        uint256 length_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            return\n                integrityState_.push(\n                    integrityState_.pop(stackTop_, length_ + 2)\n                );\n        }\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256, uint256, uint256[] memory)\n            internal\n            view\n            returns (uint256),\n        uint256 length_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            return\n                integrityState_.push(\n                    integrityState_.pop(stackTop_, length_ + 3)\n                );\n        }\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256[] memory, uint256[] memory)\n            internal\n            view\n            returns (uint256[] memory),\n        uint256 length_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            return\n                integrityState_.push(\n                    integrityState_.pop(stackTop_, length_ * 2 + 1),\n                    length_\n                );\n        }\n    }\n}\n"
    },
    "contracts/interpreter/deploy/RainInterpreterIntegrity.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\nimport \"../run/RainInterpreter.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"../../sstore2/SSTORE2.sol\";\nimport \"../run/LibStackTop.sol\";\nimport \"./LibIntegrityState.sol\";\nimport \"./IRainInterpreterIntegrity.sol\";\nimport {SafeCastUpgradeable as SafeCast} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nabstract contract RainInterpreterIntegrity is IRainInterpreterIntegrity {\n    using SafeCast for uint256;\n    using Math for uint256;\n    using LibInterpreterState for InterpreterState;\n    using LibCast for uint256;\n    using LibStackTop for bytes;\n    using LibStackTop for StackTop;\n    using LibStackTop for uint256[];\n    using LibIntegrityState for IntegrityState;\n\n    function integrityFunctionPointers()\n        internal\n        view\n        virtual\n        returns (\n            function(IntegrityState memory, Operand, StackTop)\n                view\n                returns (StackTop)[]\n                memory\n        );\n\n    function ensureIntegrity(\n        bytes[] memory sources_,\n        uint256 constantsLength_,\n        uint[] memory minStackOutputs_\n    ) public view returns (uint256 contextReads_, uint256 stackLength_) {\n        require(sources_.length >= minStackOutputs_.length, \"BAD_MSO_LENGTH\");\n        IntegrityState memory integrityState_ = IntegrityState(\n            sources_,\n            constantsLength_,\n            StackTop.wrap(0),\n            StackTop.wrap(0),\n            0,\n            integrityFunctionPointers()\n        );\n        for (uint256 i_ = 0; i_ < minStackOutputs_.length; i_++) {\n            integrityState_.ensureIntegrity(\n                SourceIndex.wrap(i_),\n                StackTop.wrap(0),\n                minStackOutputs_[i_]\n            );\n        }\n        return (\n            integrityState_.contextReads,\n            integrityState_.stackBottom.toIndex(integrityState_.stackMaxTop)\n        );\n    }\n}\n"
    },
    "contracts/interpreter/deploy/StandardIntegrity.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"../run/RainInterpreter.sol\";\nimport \"./RainInterpreterIntegrity.sol\";\nimport \"../ops/AllStandardOps.sol\";\n\ncontract StandardIntegrity is RainInterpreterIntegrity {\n    function localIntegrityFunctionPointers()\n        internal\n        pure\n        virtual\n        returns (\n            function(IntegrityState memory, Operand, StackTop)\n                view\n                returns (StackTop)[]\n                memory localFnPtrs_\n        )\n    {}\n\n    /// @inheritdoc RainInterpreterIntegrity\n    function integrityFunctionPointers()\n        internal\n        view\n        virtual\n        override\n        returns (\n            function(IntegrityState memory, Operand, StackTop)\n                view\n                returns (StackTop)[]\n                memory\n        )\n    {\n        return\n            AllStandardOps.integrityFunctionPointers(\n                localIntegrityFunctionPointers()\n            );\n    }\n}\n"
    },
    "contracts/interpreter/ops/AllStandardOps.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"../../type/LibCast.sol\";\nimport \"../../type/LibConvert.sol\";\nimport \"../../array/LibUint256Array.sol\";\nimport \"../run/RainInterpreter.sol\";\nimport \"./chainlink/OpChainlinkOraclePrice.sol\";\nimport \"./core/OpCall.sol\";\nimport \"./core/OpSet.sol\";\nimport \"./core/OpContext.sol\";\nimport \"./core/OpContextRow.sol\";\nimport \"./core/OpDebug.sol\";\nimport \"./core/OpDoWhile.sol\";\nimport \"./core/OpFoldContext.sol\";\nimport \"./core/OpLoopN.sol\";\nimport \"./core/OpReadMemory.sol\";\nimport \"./crypto/OpHash.sol\";\nimport \"./erc20/OpERC20BalanceOf.sol\";\nimport \"./erc20/OpERC20TotalSupply.sol\";\nimport \"./erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol\";\nimport \"./erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol\";\nimport \"./erc721/OpERC721BalanceOf.sol\";\nimport \"./erc721/OpERC721OwnerOf.sol\";\nimport \"./erc1155/OpERC1155BalanceOf.sol\";\nimport \"./erc1155/OpERC1155BalanceOfBatch.sol\";\nimport \"./error/OpEnsure.sol\";\nimport \"./evm/OpBlockNumber.sol\";\nimport \"./evm/OpCaller.sol\";\nimport \"./evm/OpThisAddress.sol\";\nimport \"./evm/OpTimestamp.sol\";\nimport \"./list/OpExplode32.sol\";\nimport \"./math/fixedPoint/OpFixedPointScale18.sol\";\nimport \"./math/fixedPoint/OpFixedPointScale18Div.sol\";\nimport \"./math/fixedPoint/OpFixedPointScale18Mul.sol\";\nimport \"./math/fixedPoint/OpFixedPointScaleBy.sol\";\nimport \"./math/fixedPoint/OpFixedPointScaleN.sol\";\nimport \"./math/logic/OpAny.sol\";\nimport \"./math/logic/OpEagerIf.sol\";\nimport \"./math/logic/OpEqualTo.sol\";\nimport \"./math/logic/OpEvery.sol\";\nimport \"./math/logic/OpGreaterThan.sol\";\nimport \"./math/logic/OpIsZero.sol\";\nimport \"./math/logic/OpLessThan.sol\";\nimport \"./math/saturating/OpSaturatingAdd.sol\";\nimport \"./math/saturating/OpSaturatingMul.sol\";\nimport \"./math/saturating/OpSaturatingSub.sol\";\nimport \"./math/OpAdd.sol\";\nimport \"./math/OpDiv.sol\";\nimport \"./math/OpExp.sol\";\nimport \"./math/OpMax.sol\";\nimport \"./math/OpMin.sol\";\nimport \"./math/OpMod.sol\";\nimport \"./math/OpMul.sol\";\nimport \"./math/OpSub.sol\";\nimport \"./rain/IOrderBookV1/OpIOrderBookV1VaultBalance.sol\";\nimport \"./rain/ISaleV2/OpISaleV2RemainingTokenInventory.sol\";\nimport \"./rain/ISaleV2/OpISaleV2Reserve.sol\";\nimport \"./rain/ISaleV2/OpISaleV2SaleStatus.sol\";\nimport \"./rain/ISaleV2/OpISaleV2Token.sol\";\nimport \"./rain/ISaleV2/OpISaleV2TotalReserveReceived.sol\";\nimport \"./tier/OpITierV2Report.sol\";\nimport \"./tier/OpITierV2ReportTimeForTier.sol\";\nimport \"./tier/OpSaturatingDiff.sol\";\nimport \"./tier/OpSelectLte.sol\";\nimport \"./tier/OpUpdateTimesForTierRange.sol\";\n\nuint256 constant ALL_STANDARD_OPS_LENGTH = 59;\n\n/// @title AllStandardOps\n/// @notice RainInterpreter opcode pack to expose all other packs.\nlibrary AllStandardOps {\n    using LibCast for uint256;\n    using LibCast for function(uint256) pure returns (uint256);\n    using LibCast for function(InterpreterState memory, uint256, StackTop)\n        view\n        returns (StackTop);\n    using LibCast for function(InterpreterState memory, uint256, StackTop)\n        pure\n        returns (StackTop);\n    using LibCast for function(InterpreterState memory, uint256, StackTop)\n        view\n        returns (StackTop)[];\n\n    using AllStandardOps for function(IntegrityState memory, Operand, StackTop)\n        view\n        returns (StackTop)[ALL_STANDARD_OPS_LENGTH + 1];\n    using AllStandardOps for function(\n        InterpreterState memory,\n        Operand,\n        StackTop\n    ) view returns (StackTop)[ALL_STANDARD_OPS_LENGTH + 1];\n\n    using AllStandardOps for uint256[ALL_STANDARD_OPS_LENGTH + 1];\n\n    using LibUint256Array for uint256[];\n    using LibConvert for uint256[];\n    using LibCast for uint256[];\n    using LibCast for function(IntegrityState memory, Operand, StackTop)\n        view\n        returns (StackTop);\n    using LibCast for function(IntegrityState memory, Operand, StackTop)\n        pure\n        returns (StackTop);\n    using LibCast for function(IntegrityState memory, Operand, StackTop)\n        view\n        returns (StackTop)[];\n    using LibCast for function(InterpreterState memory, Operand, StackTop)\n        view\n        returns (StackTop)[];\n\n    /// An oddly specific conversion between a fixed and dynamic uint256 array.\n    /// This is useful for the purpose of building metadata for bounds checks\n    /// and dispatch of all the standard ops provided by RainInterpreter.\n    /// The cast will fail if the length of the dynamic array doesn't match the\n    /// first item of the fixed array; it relies on differences in memory\n    /// layout in Solidity that MAY change in the future. The rollback guards\n    /// against changes in Solidity memory layout silently breaking this cast.\n    /// @param fixed_ The fixed size uint array to cast to a dynamic uint array.\n    /// Specifically the size is fixed to match the number of standard ops.\n    /// @param dynamic_ The dynamic uint array with length of the standard ops.\n    function asUint256Array(\n        function(IntegrityState memory, Operand, StackTop)\n            view\n            returns (StackTop)[ALL_STANDARD_OPS_LENGTH + 1]\n            memory fixed_\n    ) internal pure returns (uint256[] memory dynamic_) {\n        assembly (\"memory-safe\") {\n            dynamic_ := fixed_\n        }\n        require(\n            dynamic_.length == ALL_STANDARD_OPS_LENGTH,\n            \"BAD_DYNAMIC_LENGTH\"\n        );\n    }\n\n    function asUint256Array(\n        function(InterpreterState memory, Operand, StackTop)\n            view\n            returns (StackTop)[ALL_STANDARD_OPS_LENGTH + 1]\n            memory fixed_\n    ) internal pure returns (uint256[] memory dynamic_) {\n        assembly (\"memory-safe\") {\n            dynamic_ := fixed_\n        }\n        require(\n            dynamic_.length == ALL_STANDARD_OPS_LENGTH,\n            \"BAD_DYNAMIC_LENGTH\"\n        );\n    }\n\n    function integrityFunctionPointers(\n        function(IntegrityState memory, Operand, StackTop)\n            view\n            returns (StackTop)[]\n            memory locals_\n    )\n        internal\n        pure\n        returns (\n            function(IntegrityState memory, Operand, StackTop)\n                view\n                returns (StackTop)[]\n                memory\n        )\n    {\n        unchecked {\n            function(IntegrityState memory, Operand, StackTop)\n                view\n                returns (StackTop)[ALL_STANDARD_OPS_LENGTH + 1]\n                memory pointersFixed_ = [\n                    ALL_STANDARD_OPS_LENGTH.asIntegrityFunctionPointer(),\n                    OpChainlinkOraclePrice.integrity,\n                    OpCall.integrity,\n                    OpContext.integrity,\n                    OpContextRow.integrity,\n                    OpDebug.integrity,\n                    OpDoWhile.integrity,\n                    OpFoldContext.integrity,\n                    OpLoopN.integrity,\n                    OpReadMemory.integrity,\n                    OpSet.integrity,\n                    OpHash.integrity,\n                    OpERC20BalanceOf.integrity,\n                    OpERC20TotalSupply.integrity,\n                    OpERC20SnapshotBalanceOfAt.integrity,\n                    OpERC20SnapshotTotalSupplyAt.integrity,\n                    OpERC721BalanceOf.integrity,\n                    OpERC721OwnerOf.integrity,\n                    OpERC1155BalanceOf.integrity,\n                    OpERC1155BalanceOfBatch.integrity,\n                    OpEnsure.integrity,\n                    OpBlockNumber.integrity,\n                    OpCaller.integrity,\n                    OpThisAddress.integrity,\n                    OpTimestamp.integrity,\n                    OpExplode32.integrity,\n                    OpFixedPointScale18.integrity,\n                    OpFixedPointScale18Div.integrity,\n                    OpFixedPointScale18Mul.integrity,\n                    OpFixedPointScaleBy.integrity,\n                    OpFixedPointScaleN.integrity,\n                    OpAny.integrity,\n                    OpEagerIf.integrity,\n                    OpEqualTo.integrity,\n                    OpEvery.integrity,\n                    OpGreaterThan.integrity,\n                    OpIsZero.integrity,\n                    OpLessThan.integrity,\n                    OpSaturatingAdd.integrity,\n                    OpSaturatingMul.integrity,\n                    OpSaturatingSub.integrity,\n                    OpAdd.integrity,\n                    OpDiv.integrity,\n                    OpExp.integrity,\n                    OpMax.integrity,\n                    OpMin.integrity,\n                    OpMod.integrity,\n                    OpMul.integrity,\n                    OpSub.integrity,\n                    OpIOrderBookV1VaultBalance.integrity,\n                    OpISaleV2RemainingTokenInventory.integrity,\n                    OpISaleV2Reserve.integrity,\n                    OpISaleV2SaleStatus.integrity,\n                    OpISaleV2Token.integrity,\n                    OpISaleV2TotalReserveReceived.integrity,\n                    OpITierV2Report.integrity,\n                    OpITierV2ReportTimeForTier.integrity,\n                    OpSaturatingDiff.integrity,\n                    OpSelectLte.integrity,\n                    OpUpdateTimesForTierRange.integrity\n                ];\n            uint256[] memory pointers_ = pointersFixed_.asUint256Array();\n            pointers_.extend(locals_.asUint256Array());\n            return pointers_.asIntegrityPointers();\n        }\n    }\n\n    function opcodeFunctionPointers(\n        function(InterpreterState memory, Operand, StackTop)\n            view\n            returns (StackTop)[]\n            memory locals_\n    )\n        internal\n        pure\n        returns (\n            function(InterpreterState memory, Operand, StackTop)\n                view\n                returns (StackTop)[]\n                memory opcodeFunctionPointers_\n        )\n    {\n        unchecked {\n            function(InterpreterState memory, Operand, StackTop)\n                view\n                returns (StackTop)[ALL_STANDARD_OPS_LENGTH + 1]\n                memory pointersFixed_ = [\n                    ALL_STANDARD_OPS_LENGTH.asOpFunctionPointer(),\n                    OpChainlinkOraclePrice.price,\n                    OpCall.run,\n                    OpContext.run,\n                    OpContextRow.run,\n                    OpDebug.debug,\n                    OpDoWhile.run,\n                    OpFoldContext.run,\n                    OpLoopN.run,\n                    OpReadMemory.run,\n                    OpSet.run,\n                    OpHash.hash,\n                    OpERC20BalanceOf.balanceOf,\n                    OpERC20TotalSupply.totalSupply,\n                    OpERC20SnapshotBalanceOfAt.balanceOfAt,\n                    OpERC20SnapshotTotalSupplyAt.totalSupplyAt,\n                    OpERC721BalanceOf.balanceOf,\n                    OpERC721OwnerOf.ownerOf,\n                    OpERC1155BalanceOf.balanceOf,\n                    OpERC1155BalanceOfBatch.balanceOfBatch,\n                    OpEnsure.ensure,\n                    OpBlockNumber.blockNumber,\n                    OpCaller.caller,\n                    OpThisAddress.thisAddress,\n                    OpTimestamp.timestamp,\n                    OpExplode32.explode32,\n                    OpFixedPointScale18.scale18,\n                    OpFixedPointScale18Div.scale18Div,\n                    OpFixedPointScale18Mul.scale18Mul,\n                    OpFixedPointScaleBy.scaleBy,\n                    OpFixedPointScaleN.scaleN,\n                    OpAny.any,\n                    OpEagerIf.eagerIf,\n                    OpEqualTo.equalTo,\n                    OpEvery.every,\n                    OpGreaterThan.greaterThan,\n                    OpIsZero.isZero,\n                    OpLessThan.lessThan,\n                    OpSaturatingAdd.saturatingAdd,\n                    OpSaturatingMul.saturatingMul,\n                    OpSaturatingSub.saturatingSub,\n                    OpAdd.add,\n                    OpDiv.div,\n                    OpExp.exp,\n                    OpMax.max,\n                    OpMin.min,\n                    OpMod.mod,\n                    OpMul.mul,\n                    OpSub.sub,\n                    OpIOrderBookV1VaultBalance.run,\n                    OpISaleV2RemainingTokenInventory.run,\n                    OpISaleV2Reserve.run,\n                    OpISaleV2SaleStatus.run,\n                    OpISaleV2Token.run,\n                    OpISaleV2TotalReserveReceived.run,\n                    OpITierV2Report.report,\n                    OpITierV2ReportTimeForTier.reportTimeForTier,\n                    OpSaturatingDiff.saturatingDiff,\n                    OpSelectLte.selectLte,\n                    OpUpdateTimesForTierRange.updateTimesForTierRange\n                ];\n            uint256[] memory pointers_ = pointersFixed_.asUint256Array();\n            pointers_.extend(locals_.asUint256Array());\n            opcodeFunctionPointers_ = pointers_.asOpcodeFunctionPointers();\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/chainlink/OpChainlinkOraclePrice.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {LibChainlink} from \"../../../chainlink/LibChainlink.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpChainlinkOraclePrice\n/// @notice Opcode for chainlink oracle prices.\nlibrary OpChainlinkOraclePrice {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _price(\n        uint256 feed_,\n        uint256 staleAfter_\n    ) internal view returns (uint256) {\n        return LibChainlink.price(address(uint160(feed_)), staleAfter_);\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _price);\n    }\n\n    function price(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_price);\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpCall.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../../array/LibUint256Array.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\nimport \"../../../math/Binary.sol\";\n\n/// @title OpCall\n/// @notice Opcode for calling eval with a new scope. The construction of this\n/// scope is split across integrity and runtime responsibilities. When the\n/// integrity checks are done the expression being called has all its integrity\n/// logic run, recursively if needed. The integrity checks are run against the\n/// integrity state as it is but with the stack bottom set below the inputs to\n/// the called source. This ensures that the sub-integrity checks do not\n/// underflow what they perceive as a fresh stack, and it ensures that we set the\n/// stack length long enough to cover all sub-executions as a single array in\n/// memory. At runtime we trust the integrity checks have allocated enough runway\n/// in the stack for all our recursive sub-calls so we simply move the stack\n/// bottom in the state below the inputs during the call and move it back to\n/// where it was after the call. Notably this means that reading from the stack\n/// in the called source will 0 index from the first input, NOT the bottom of\n/// the calling stack.\nlibrary OpCall {\n    using LibIntegrityState for IntegrityState;\n    using LibStackTop for StackTop;\n    using LibInterpreterState for InterpreterState;\n    using LibUint256Array for uint;\n\n    /// Interpreter integrity logic.\n    /// The basic movements on the outer stack are to pop the inputs and push the\n    /// outputs, but the called source doesn't have access to a separately\n    /// allocated region of memory. There's only a single shared memory\n    /// allocation for all executions and sub-executions, so we recursively run\n    /// integrity checks on the called source relative to the current stack\n    /// position.\n    /// @param integrityState_ The state of the current integrity check.\n    /// @param operand_ The operand associated with this call.\n    /// @param stackTop_ The current stack top within the integrity check.\n    /// @return stackTopAfter_ The stack top after the call movements are applied.\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop stackTopAfter_) {\n        // Unpack the operand to get IO and the source to be called.\n        uint256 inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\n        uint256 outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\n        SourceIndex callSourceIndex_ = SourceIndex.wrap(\n            Operand.unwrap(operand_) >> 8\n        );\n\n        // Remember the outer stack bottom.\n        StackTop stackBottom_ = integrityState_.stackBottom;\n\n        // Set the inner stack bottom to below the inputs.\n        integrityState_.stackBottom = integrityState_.pop(stackTop_, inputs_);\n\n        // Ensure the integrity of the inner source on the current state using\n        // the stack top above the inputs as the starting stack top.\n        // Contraints namespace is irrelevant here.\n        integrityState_.ensureIntegrity(callSourceIndex_, stackTop_, outputs_);\n\n        // The outer stack top will move above the outputs relative to the inner\n        // stack bottom. At runtime any values that are not outputs will be\n        // removed so they do not need to be accounted for here.\n        stackTopAfter_ = integrityState_.push(\n            integrityState_.stackBottom,\n            outputs_\n        );\n\n        // Reinstate the outer stack bottom.\n        integrityState_.stackBottom = stackBottom_;\n    }\n\n    /// Call eval with a new scope.\n    /// @param state_ The state of the current evaluation.\n    /// @param operand_ The operand associated with this call.\n    /// @param stackTop_ The current stack top within the evaluation.\n    /// @return stackTopAfter_ The stack top after the call is evaluated.\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop stackTopAfter_) {\n        // Unpack the operand to get IO and the source to be called.\n        uint256 inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\n        uint256 outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\n        SourceIndex callSourceIndex_ = SourceIndex.wrap(\n            Operand.unwrap(operand_) >> 8\n        );\n\n        // Remember the outer stack bottom.\n        StackTop stackBottom_ = state_.stackBottom;\n\n        // Set the inner stack bottom to below the inputs.\n        state_.stackBottom = stackTop_.down(inputs_);\n\n        // Eval the source from the operand on the current state using the stack\n        // top above the inputs as the starting stack top. The final stack top\n        // is where we will read outputs from below.\n        StackTop stackTopEval_ = state_.eval(callSourceIndex_, stackTop_);\n        // Normalize the inner final stack so that it contains only the outputs\n        // starting from the inner stack bottom.\n        LibUint256Array.unsafeCopyValuesTo(\n            StackTop.unwrap(stackTopEval_.down(outputs_)),\n            StackTop.unwrap(state_.stackBottom),\n            outputs_\n        );\n\n        // The outer stack top should now point above the outputs.\n        stackTopAfter_ = state_.stackBottom.up(outputs_);\n\n        // The outer stack bottom needs to be reinstated as it was before eval.\n        state_.stackBottom = stackBottom_;\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpContext.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\nimport \"../../../idempotent/LibIdempotentFlag.sol\";\nimport \"../../../math/Binary.sol\";\n\n/// @title OpContext\n/// @notice Opcode for stacking from the context. Context requires slightly\n/// different handling to other memory reads as it is working with data that\n/// is provided at runtime.\nlibrary OpContext {\n    using LibStackTop for StackTop;\n    using LibInterpreterState for InterpreterState;\n    using LibIntegrityState for IntegrityState;\n\n    /// Interpreter integrity logic.\n    /// Context pushes a single value to the stack from memory.\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        uint256 row_ = Operand.unwrap(operand_) & MASK_8BIT;\n        uint256 column_ = Operand.unwrap(operand_) >> 8;\n        integrityState_.contextReads = IdempotentFlag.unwrap(\n            LibIdempotentFlag.set16x16(\n                IdempotentFlag.wrap(integrityState_.contextReads),\n                column_,\n                row_\n            )\n        );\n        // Note that a expression with context can error at runtime due to OOB\n        // reads that we don't know about here.\n        return integrityState_.push(stackTop_);\n    }\n\n    /// Stack a value from the context WITH OOB checks from solidity.\n    /// The bounds checks are done at runtime because context MAY be provided\n    /// by the end user with arbitrary length.\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        // The indexing syntax here enforces OOB checks at runtime.\n        return\n            stackTop_.push(\n                state_.context[Operand.unwrap(operand_) >> 8][\n                    Operand.unwrap(operand_) & MASK_8BIT\n                ]\n            );\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpContextRow.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\nimport \"../../../idempotent/LibIdempotentFlag.sol\";\nimport \"../../../math/Binary.sol\";\n\n/// @title OpContextRow\n/// @notice Opcode for stacking a dynamic row from the context. Context requires\n/// slightly different handling to other memory reads as it is working with data\n/// that is provided at runtime. `OpContextRow` works exactly like `OpContext`\n/// but the row is provided from the stack instead of the operand. We rely on\n/// Solidity OOB checks at runtime to enforce that the index from the stack is\n/// within bounds at runtime. As we do NOT know statically which row will be read\n/// the context reads is set to the entire column.\nlibrary OpContextRow {\n    using LibStackTop for StackTop;\n    using LibInterpreterState for InterpreterState;\n    using LibIntegrityState for IntegrityState;\n\n    /// Interpreter integrity logic.\n    /// Context pushes a single value to the stack from memory.\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        uint256 column_ = Operand.unwrap(operand_);\n        integrityState_.contextReads = IdempotentFlag.unwrap(\n            LibIdempotentFlag.set16x16Column(\n                IdempotentFlag.wrap(integrityState_.contextReads),\n                column_\n            )\n        );\n        // Note that a expression with context can error at runtime due to OOB\n        // reads that we don't know about here.\n        function(uint) internal pure returns (uint) fn_;\n        return integrityState_.applyFn(stackTop_, fn_);\n    }\n\n    /// Stack a value from the context WITH OOB checks from solidity.\n    /// The bounds checks are done at runtime because context MAY be provided\n    /// by the end user with arbitrary length.\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        // The indexing syntax here enforces OOB checks at runtime.\n        (StackTop location_, uint row_) = stackTop_.pop();\n        location_.set(state_.context[Operand.unwrap(operand_)][row_]);\n        return stackTop_;\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpDebug.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpDebug\n/// @notice Opcode for debugging state. Uses the standard debugging logic from\n/// InterpreterState.debug.\nlibrary OpDebug {\n    using LibStackTop for StackTop;\n    using LibInterpreterState for InterpreterState;\n\n    /// Interpreter integrity for debug.\n    /// Debug doesn't modify the stack.\n    function integrity(\n        IntegrityState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        // Try to build a debug style from the operand to ensure we can enumerate\n        // it.\n        DebugStyle(Operand.unwrap(operand_));\n        return stackTop_;\n    }\n\n    /// Debug the current state.\n    function debug(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        DebugStyle debugStyle_ = DebugStyle(Operand.unwrap(operand_));\n\n        state_.debug(stackTop_, debugStyle_);\n\n        return stackTop_;\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpDoWhile.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\nimport \"./OpCall.sol\";\n\n/// @title OpWhile\n/// @notice Opcode for looping while the stack top is nonzero. As we pre-allocate\n/// all the memory for execution during integrity checks we have an apparent\n/// contradiction here. If we do not know how many times the loop will run then\n/// we cannot calculate the final stack height or intermediate pops and pushes.\n/// To solve this we simply wrap `OpCall` which already has fixed inputs and\n/// outputs and enforce that the outputs of each iteration is 1 more than the\n/// inputs. We then consume the extra output as the condition for the decision\n/// to loop again, thus the outputs = inputs for every iteration. If the stack\n/// height does not change between iterations we do not care how many times we\n/// loop (although the user paying gas might).\nlibrary OpDoWhile {\n    using LibIntegrityState for IntegrityState;\n    using LibStackTop for StackTop;\n    using LibInterpreterState for InterpreterState;\n\n    /// Interpreter integrity for do while.\n    /// The loop itself pops a single value from the stack to determine whether\n    /// it should run another iteration of the loop. The source called by the\n    /// loop must then put a value back on the stack in the same position to\n    /// either continue or break the loop.\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        unchecked {\n            uint inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\n            /// We need outputs to be larger than inputs so inputs can't be the\n            /// max value possible in 4 bits or outputs will overflow.\n            require(inputs_ < MASK_4BIT, \"OP_DO_WHILE_INPUTS\");\n            uint outputs_ = inputs_ + 1;\n            Operand callOperand_ = Operand.wrap(\n                Operand.unwrap(operand_) | (outputs_ << 4)\n            );\n            // Stack height changes are deterministic so if we call once we've\n            // called a thousand times. Also we pop one output off the result of\n            // the call to check the while condition.\n            return\n                integrityState_.pop(\n                    OpCall.integrity(integrityState_, callOperand_, stackTop_)\n                );\n        }\n    }\n\n    /// Loop the stack while the stack top is true.\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        unchecked {\n            uint inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\n            uint outputs_ = inputs_ + 1;\n            Operand callOperand_ = Operand.wrap(\n                Operand.unwrap(operand_) | (outputs_ << 4)\n            );\n            uint256 do_;\n            (stackTop_, do_) = stackTop_.pop();\n            while (do_ > 0) {\n                stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\n                (stackTop_, do_) = stackTop_.pop();\n            }\n            return stackTop_;\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpFoldContext.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\nimport \"./OpCall.sol\";\nimport \"../../../idempotent/LibIdempotentFlag.sol\";\n\n/// @title OpFoldContext\n/// Folds over columns of context from their start to end. Expressions do not\n/// have a good way of handling dynamic lengths of things, and that is\n/// intentional to avoid end users having to write out looping constructs of the\n/// form `i = 0; i < length; i++` is is so tedious and error prone in software\n/// development generally. It is very easy to implement \"off by one\" errors in\n/// this form, and requires sourcing a length from somewhere. This opcode exposes\n/// a pretty typical fold as found elsewhere in functional programming. A start\n/// column and width of columns can be specified, the rows will be iterated and\n/// pushed to the stack on top of any additional inputs specified by the\n/// expression. The additional inputs are the accumulators and so the number of\n/// outputs in the called source needs to match the number of accumulator inputs.\nlibrary OpFoldContext {\n    using LibIntegrityState for IntegrityState;\n    using LibStackTop for StackTop;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        unchecked {\n            uint sourceIndex_ = Operand.unwrap(operand_) & MASK_4BIT;\n            uint column_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\n            uint width_ = (Operand.unwrap(operand_) >> 8) & MASK_4BIT;\n            uint inputs_ = Operand.unwrap(operand_) >> 12;\n            uint callInputs_ = width_ + inputs_;\n\n            for (uint i_ = 0; i_ < width_; i_++) {\n                integrityState_.contextReads = IdempotentFlag.unwrap(\n                    LibIdempotentFlag.set16x16Column(\n                        IdempotentFlag.wrap(integrityState_.contextReads),\n                        column_ + i_\n                    )\n                );\n            }\n\n            Operand callOperand_ = Operand.wrap(\n                (sourceIndex_ << 8) | (inputs_ << 4) | callInputs_\n            );\n\n            // First the width of the context columns being folded is pushed to\n            // the stack.\n            stackTop_ = integrityState_.push(\n                integrityState_.stackBottom,\n                width_\n            );\n            // Then we loop over call taking the width and extra inputs, then\n            // returning the same number of outputs as non-width inputs.\n            return OpCall.integrity(integrityState_, callOperand_, stackTop_);\n        }\n    }\n\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        unchecked {\n            uint sourceIndex_ = Operand.unwrap(operand_) & MASK_4BIT;\n            uint column_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\n            uint width_ = (Operand.unwrap(operand_) >> 8) & MASK_4BIT;\n            uint inputs_ = Operand.unwrap(operand_) >> 12;\n            // Call will take the width of the context rows being copied and the\n            // base inputs that will be the accumulators of the fold.\n            uint callInputs_ = width_ + inputs_;\n\n            // Fold over the entire context. This will error with an OOB index\n            // if the context columns are not of the same length.\n            for (uint i_ = 0; i_ < state_.context[column_].length; i_++) {\n                // Push the width of the context columns onto the stack as rows.\n                for (uint j_ = 0; j_ < width_; j_++) {\n                    stackTop_ = stackTop_.push(\n                        state_.context[column_ + j_][i_]\n                    );\n                }\n                // The outputs of call are the same as the base inputs, this is\n                // similar to `OpDoWhile` so that we don't have to care how many\n                // iterations there are in order to calculate the stack.\n                Operand callOperand_ = Operand.wrap(\n                    (sourceIndex_ << 8) | (inputs_ << 4) | callInputs_\n                );\n                stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\n            }\n\n            return stackTop_;\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpGet.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpGet\n/// @notice Opcode for reading from storage.\nlibrary OpGet {\n    using LibStackTop for StackTop;\n    using LibInterpreterState for InterpreterState;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            // Pop key\n            // Stack value\n            function(uint) internal pure returns (uint) fn_;\n            return integrityState_.applyFn(stackTop_, fn_);\n        }\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackTop\n    ) internal pure returns (StackTop) {\n        // This must be implemented on the interpreter itself so that storage\n        // reads can happen.\n        revert(\"UNIMPLEMENTED\");\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpLoopN.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\nimport \"./OpCall.sol\";\n\n/// @title OpLoopN\n/// @notice Opcode for looping a static number of times. A thin wrapper around\n/// `OpCall` with the 4 high bits as a number of times to loop. Each iteration\n/// will use the outputs of the previous iteration as its inputs so the inputs\n/// to call must be greater or equal to the outputs. If the outputs exceed the\n/// inputs then each subsequent call will take as many inputs as it needs from\n/// the top of the intermediate stack. The net outputs to the stack will include\n/// all the intermediate excess outputs as:\n/// `outputs + (inputs - outputs) * n`\nlibrary OpLoopN {\n    using LibStackTop for StackTop;\n    using LibInterpreterState for InterpreterState;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        unchecked {\n            uint n_ = Operand.unwrap(operand_) >> 12;\n            uint inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\n            uint outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\n            require(inputs_ >= outputs_, \"LOOP_N_INPUTS\");\n            Operand callOperand_ = Operand.wrap(\n                Operand.unwrap(operand_) & MASK_12BIT\n            );\n            for (uint i_ = 0; i_ < n_; i_++) {\n                stackTop_ = OpCall.integrity(\n                    integrityState_,\n                    callOperand_,\n                    stackTop_\n                );\n            }\n            return stackTop_;\n        }\n    }\n\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        uint256 n_ = Operand.unwrap(operand_) >> 12;\n        Operand callOperand_ = Operand.wrap(\n            Operand.unwrap(operand_) & MASK_12BIT\n        );\n        for (uint256 i_ = 0; i_ < n_; i_++) {\n            stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\n        }\n        return stackTop_;\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpReadMemory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\nimport \"../../../math/Binary.sol\";\n\nuint256 constant OPCODE_MEMORY_TYPE_STACK = 0;\nuint256 constant OPCODE_MEMORY_TYPE_CONSTANT = 1;\n\n/// @title OpReadMemory\n/// @notice Opcode for stacking from the state.\nlibrary OpReadMemory {\n    using LibStackTop for StackTop;\n    using LibInterpreterState for InterpreterState;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        uint256 type_ = Operand.unwrap(operand_) & MASK_1BIT;\n        uint256 offset_ = Operand.unwrap(operand_) >> 1;\n        if (type_ == OPCODE_MEMORY_TYPE_STACK) {\n            require(\n                offset_ < integrityState_.stackBottom.toIndex(stackTop_),\n                \"OOB_STACK_READ\"\n            );\n        } else {\n            require(\n                offset_ < integrityState_.constantsLength,\n                \"OOB_CONSTANT_READ\"\n            );\n        }\n        return integrityState_.push(stackTop_);\n    }\n\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            uint256 type_ = Operand.unwrap(operand_) & MASK_1BIT;\n            uint256 offset_ = Operand.unwrap(operand_) >> 1;\n            assembly (\"memory-safe\") {\n                mstore(\n                    stackTop_,\n                    mload(\n                        add(\n                            mload(add(state_, mul(0x20, type_))),\n                            mul(0x20, offset_)\n                        )\n                    )\n                )\n            }\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + 0x20);\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpSet.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\nimport \"../../../kv/LibMemoryKV.sol\";\n\n/// @title OpSet\n/// @notice Opcode for recording k/v state changes to be set in storage.\nlibrary OpSet {\n    using LibStackTop for StackTop;\n    using LibInterpreterState for InterpreterState;\n    using LibIntegrityState for IntegrityState;\n    using LibMemoryKV for MemoryKV;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            function(uint, uint) internal pure fn_;\n            return integrityState_.applyFn(stackTop_, fn_);\n        }\n    }\n\n    function run(\n        InterpreterState memory state_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            uint k_;\n            uint v_;\n            (stackTop_, v_) = stackTop_.pop();\n            (stackTop_, k_) = stackTop_.pop();\n            state_.stateKV = state_.stateKV.setVal(\n                MemoryKVKey.wrap(k_),\n                MemoryKVVal.wrap(v_)\n            );\n            return stackTop_;\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/crypto/OpHash.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../../array/LibUint256Array.sol\";\nimport \"../../../type/LibCast.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpHash\n/// @notice Opcode for hashing a list of values.\nlibrary OpHash {\n    using LibStackTop for StackTop;\n    using LibCast for uint256[];\n    using LibIntegrityState for IntegrityState;\n\n    function _hash(uint256[] memory values_) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(values_)));\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFn(stackTop_, _hash, Operand.unwrap(operand_));\n    }\n\n    // Stack the return of `balanceOfBatch`.\n    // Operand will be the length\n    function hash(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_hash, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc1155/OpERC1155BalanceOf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC1155Upgradeable as IERC1155} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpERC1155BalanceOf\n/// @notice Opcode for getting the current erc1155 balance of an account.\nlibrary OpERC1155BalanceOf {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _balanceOf(\n        uint256 token_,\n        uint256 account_,\n        uint256 id_\n    ) internal view returns (uint256) {\n        return\n            IERC1155(address(uint160(token_))).balanceOf(\n                address(uint160(account_)),\n                id_\n            );\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _balanceOf);\n    }\n\n    // Stack the return of `balanceOf`.\n    function balanceOf(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_balanceOf);\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc1155/OpERC1155BalanceOfBatch.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC1155Upgradeable as IERC1155} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../../array/LibUint256Array.sol\";\nimport \"../../../type/LibCast.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpERC1155BalanceOfBatch\n/// @notice Opcode for getting the current erc1155 balance of an accounts batch.\nlibrary OpERC1155BalanceOfBatch {\n    using LibStackTop for StackTop;\n    using LibCast for uint256[];\n    using LibIntegrityState for IntegrityState;\n\n    function _balanceOfBatch(\n        uint256 token_,\n        uint256[] memory accounts_,\n        uint256[] memory ids_\n    ) internal view returns (uint256[] memory) {\n        return\n            IERC1155(address(uint160(token_))).balanceOfBatch(\n                accounts_.asAddresses(),\n                ids_\n            );\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFn(\n                stackTop_,\n                _balanceOfBatch,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    // Stack the return of `balanceOfBatch`.\n    // Operand will be the length\n    function balanceOfBatch(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_balanceOfBatch, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc20/OpERC20BalanceOf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpERC20BalanceOf\n/// @notice Opcode for ERC20 `balanceOf`.\nlibrary OpERC20BalanceOf {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _balanceOf(\n        uint256 token_,\n        uint256 account_\n    ) internal view returns (uint256) {\n        return\n            IERC20(address(uint160(token_))).balanceOf(\n                address(uint160(account_))\n            );\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _balanceOf);\n    }\n\n    /// Stack `balanceOf`.\n    function balanceOf(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_balanceOf);\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc20/OpERC20TotalSupply.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpERC20TotalSupply\n/// @notice Opcode for ERC20 `totalSupply`.\nlibrary OpERC20TotalSupply {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _totalSupply(uint256 token_) internal view returns (uint256) {\n        return IERC20(address(uint160(token_))).totalSupply();\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _totalSupply);\n    }\n\n    // Stack the return of `totalSupply`.\n    function totalSupply(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_totalSupply);\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {ERC20SnapshotUpgradeable as ERC20Snapshot} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpERC20SnapshotBalanceOfAt\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.balanceOfAt`.\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\nlibrary OpERC20SnapshotBalanceOfAt {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _balanceOfAt(\n        uint256 token_,\n        uint256 account_,\n        uint256 snapshotId_\n    ) internal view returns (uint256) {\n        return\n            ERC20Snapshot(address(uint160(token_))).balanceOfAt(\n                address(uint160(account_)),\n                snapshotId_\n            );\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _balanceOfAt);\n    }\n\n    /// Stack `balanceOfAt`.\n    function balanceOfAt(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_balanceOfAt);\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {ERC20SnapshotUpgradeable as ERC20Snapshot} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpERC20SnapshotTotalSupplyAt\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.totalSupplyAt`.\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\nlibrary OpERC20SnapshotTotalSupplyAt {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _totalSupplyAt(\n        uint256 token_,\n        uint256 snapshotId_\n    ) internal view returns (uint256) {\n        return\n            ERC20Snapshot(address(uint160(token_))).totalSupplyAt(snapshotId_);\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _totalSupplyAt);\n    }\n\n    /// Stack `totalSupplyAt`.\n    function totalSupplyAt(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_totalSupplyAt);\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc721/OpERC721BalanceOf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC721Upgradeable as IERC721} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpERC721BalanceOf\n/// @notice Opcode for getting the current erc721 balance of an account.\nlibrary OpERC721BalanceOf {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _balanceOf(\n        uint256 token_,\n        uint256 account_\n    ) internal view returns (uint256) {\n        return\n            IERC721(address(uint160(token_))).balanceOf(\n                address(uint160(account_))\n            );\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _balanceOf);\n    }\n\n    // Stack the return of `balanceOf`.\n    function balanceOf(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_balanceOf);\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc721/OpERC721OwnerOf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC721Upgradeable as IERC721} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpERC721OwnerOf\n/// @notice Opcode for getting the current erc721 owner of an account.\nlibrary OpERC721OwnerOf {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _ownerOf(\n        uint256 token_,\n        uint256 id_\n    ) internal view returns (uint256) {\n        return uint256(uint160(IERC721(address(uint160(token_))).ownerOf(id_)));\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _ownerOf);\n    }\n\n    // Stack the return of `ownerOf`.\n    function ownerOf(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_ownerOf);\n    }\n}\n"
    },
    "contracts/interpreter/ops/error/OpEnsure.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../../array/LibUint256Array.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpEnsure\n/// @notice Opcode for requiring some truthy values.\nlibrary OpEnsure {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _ensure(uint256 a_) internal pure {\n        assembly (\"memory-safe\") {\n            if iszero(a_) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFnN(\n                stackTop_,\n                _ensure,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function ensure(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFnN(_ensure, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/evm/OpBlockNumber.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpBlockNumber\n/// @notice Opcode for getting the current block number.\nlibrary OpBlockNumber {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(stackTop_);\n    }\n\n    function blockNumber(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.push(block.number);\n    }\n}\n"
    },
    "contracts/interpreter/ops/evm/OpCaller.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpCaller\n/// @notice Opcode for getting the current caller.\nlibrary OpCaller {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(stackTop_);\n    }\n\n    function caller(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.push(uint256(uint160(msg.sender)));\n    }\n}\n"
    },
    "contracts/interpreter/ops/evm/OpThisAddress.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpThisAddress\n/// @notice Opcode for getting the address of the current contract.\nlibrary OpThisAddress {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(stackTop_);\n    }\n\n    function thisAddress(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.push(uint256(uint160(address(this))));\n    }\n}\n"
    },
    "contracts/interpreter/ops/evm/OpTimestamp.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpTimestamp\n/// @notice Opcode for getting the current timestamp.\nlibrary OpTimestamp {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(stackTop_);\n    }\n\n    function timestamp(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.push(block.timestamp);\n    }\n}\n"
    },
    "contracts/interpreter/ops/list/OpExplode32.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../../array/LibUint256Array.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpExplode\n/// @notice Opcode for exploding a single value into 8x 32 bit integers.\nlibrary OpExplode32 {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_), 8);\n    }\n\n    function explode32(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        (StackTop location_, uint256 i_) = stackTop_.pop();\n        uint256 mask_ = uint256(type(uint32).max);\n        return\n            location_.push(\n                i_ & mask_,\n                (i_ >> 0x20) & mask_,\n                (i_ >> 0x40) & mask_,\n                (i_ >> 0x60) & mask_,\n                (i_ >> 0x80) & mask_,\n                (i_ >> 0xA0) & mask_,\n                (i_ >> 0xC0) & mask_,\n                (i_ >> 0xE0) & mask_\n            );\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/FixedPointMath.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpFixedPointScale18\n/// @notice Opcode for scaling a number to 18 fixed point.\nlibrary OpFixedPointScale18 {\n    using FixedPointMath for uint256;\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _scale18(\n        Operand operand_,\n        uint256 a_\n    ) internal pure returns (uint256) {\n        return a_.scale18(Operand.unwrap(operand_));\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _scale18);\n    }\n\n    function scale18(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_scale18, operand_);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18Div.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/FixedPointMath.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpFixedPointScale18Div\n/// @notice Opcode for performing scale 18 fixed point division.\nlibrary OpFixedPointScale18Div {\n    using FixedPointMath for uint256;\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _scale18Div(\n        Operand operand_,\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        return a_.scale18(Operand.unwrap(operand_)).fixedPointDiv(b_);\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _scale18Div);\n    }\n\n    function scale18Div(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_scale18Div, operand_);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18Mul.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/FixedPointMath.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpFixedPointScale18Mul\n/// @notice Opcode for performing scale 18 fixed point multiplication.\nlibrary OpFixedPointScale18Mul {\n    using FixedPointMath for uint256;\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _scale18Mul(\n        Operand operand_,\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        return a_.scale18(Operand.unwrap(operand_)).fixedPointMul(b_);\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _scale18Mul);\n    }\n\n    function scale18Mul(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_scale18Mul, operand_);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/fixedPoint/OpFixedPointScaleBy.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/FixedPointMath.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpFixedPointScaleBy\n/// @notice Opcode for scaling a number by some OOMs.\nlibrary OpFixedPointScaleBy {\n    using FixedPointMath for uint256;\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _scaleBy(\n        Operand operand_,\n        uint256 a_\n    ) internal pure returns (uint256) {\n        return a_.scaleBy(int8(uint8(Operand.unwrap(operand_))));\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _scaleBy);\n    }\n\n    function scaleBy(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_scaleBy, operand_);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/fixedPoint/OpFixedPointScaleN.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/FixedPointMath.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpFixedPointScaleN\n/// @notice Opcode for scaling a number to N fixed point.\nlibrary OpFixedPointScaleN {\n    using FixedPointMath for uint256;\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _scaleN(\n        Operand operand_,\n        uint256 a_\n    ) internal pure returns (uint256) {\n        return a_.scaleN(Operand.unwrap(operand_));\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _scaleN);\n    }\n\n    function scaleN(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_scaleN, operand_);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpAny.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpAny\n/// @notice Opcode to compare the top N stack values.\nlibrary OpAny {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        function(uint256[] memory) internal view returns (uint256) fn_;\n        return\n            integrityState_.applyFn(stackTop_, fn_, Operand.unwrap(operand_));\n    }\n\n    // ANY\n    // ANY is the first nonzero item, else 0.\n    // operand_ id the length of items to check.\n    function any(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        StackTop bottom_ = stackTop_.down(Operand.unwrap(operand_));\n        for (\n            StackTop i_ = bottom_;\n            StackTop.unwrap(i_) < StackTop.unwrap(stackTop_);\n            i_ = i_.up()\n        ) {\n            uint256 item_ = i_.peekUp();\n            if (item_ > 0) {\n                return bottom_.push(item_);\n            }\n        }\n        return bottom_.up();\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpEagerIf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpEagerIf\n/// @notice Opcode for selecting a value based on a condition.\nlibrary OpEagerIf {\n    using LibIntegrityState for IntegrityState;\n    using LibStackTop for StackTop;\n\n    function _eagerIf(\n        uint256 a_,\n        uint256[] memory bs_,\n        uint256[] memory cs_\n    ) internal pure returns (uint256[] memory) {\n        return a_ > 0 ? bs_ : cs_;\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFn(\n                stackTop_,\n                _eagerIf,\n                Operand.unwrap(operand_) + 1\n            );\n    }\n\n    /// Eager because BOTH x_ and y_ must be eagerly evaluated\n    /// before EAGER_IF will select one of them. If both x_ and y_\n    /// are cheap (e.g. constant values) then this may also be the\n    /// simplest and cheapest way to select one of them.\n    function eagerIf(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        unchecked {\n            return stackTop_.applyFn(_eagerIf, Operand.unwrap(operand_) + 1);\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpEqualTo.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../../type/LibCast.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpEqualTo\n/// @notice Opcode to compare the top two stack values.\nlibrary OpEqualTo {\n    using LibCast for bool;\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _equalTo(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return (a_ == b_).asUint256();\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _equalTo);\n    }\n\n    function equalTo(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_equalTo);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpEvery.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpEvery\n/// @notice Opcode to compare the top N stack values.\nlibrary OpEvery {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        function(uint256[] memory) internal view returns (uint256) fn_;\n        return\n            integrityState_.applyFn(stackTop_, fn_, Operand.unwrap(operand_));\n    }\n\n    // EVERY\n    // EVERY is either the first item if every item is nonzero, else 0.\n    // operand_ is the length of items to check.\n    function every(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        StackTop bottom_ = stackTop_.down(Operand.unwrap(operand_));\n        for (\n            StackTop i_ = bottom_;\n            StackTop.unwrap(i_) < StackTop.unwrap(stackTop_);\n            i_ = i_.up()\n        ) {\n            if (i_.peekUp() == 0) {\n                return bottom_.push(0);\n            }\n        }\n        return bottom_.up();\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpGreaterThan.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../../type/LibCast.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpGreaterThan\n/// @notice Opcode to compare the top two stack values.\nlibrary OpGreaterThan {\n    using LibCast for bool;\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _greaterThan(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        return (a_ > b_).asUint256();\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _greaterThan);\n    }\n\n    function greaterThan(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_greaterThan);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpIsZero.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../../type/LibCast.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpIsZero\n/// @notice Opcode for checking if the stack top is zero.\nlibrary OpIsZero {\n    using LibCast for bool;\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _isZero(uint256 a_) internal pure returns (uint256) {\n        return (a_ == 0).asUint256();\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _isZero);\n    }\n\n    function isZero(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_isZero);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpLessThan.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../../type/LibCast.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpLessThan\n/// @notice Opcode to compare the top two stack values.\nlibrary OpLessThan {\n    using LibStackTop for StackTop;\n    using LibCast for bool;\n    using LibIntegrityState for IntegrityState;\n\n    function _lessThan(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return (a_ < b_).asUint256();\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _lessThan);\n    }\n\n    function lessThan(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_lessThan);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpAdd.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../../array/LibUint256Array.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpAdd\n/// @notice Opcode for adding N numbers.\nlibrary OpAdd {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _add(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ + b_;\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFnN(stackTop_, _add, Operand.unwrap(operand_));\n    }\n\n    function add(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFnN(_add, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpDiv.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpDiv\n/// @notice Opcode for dividing N numbers.\nlibrary OpDiv {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _div(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ / b_;\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFnN(stackTop_, _div, Operand.unwrap(operand_));\n    }\n\n    function div(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop stackTopAfter_) {\n        return stackTop_.applyFnN(_div, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpExp.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpExp\n/// @notice Opcode to exponentiate N numbers.\nlibrary OpExp {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _exp(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ ** b_;\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFnN(stackTop_, _exp, Operand.unwrap(operand_));\n    }\n\n    function exp(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop stackTopAfter_) {\n        return stackTop_.applyFnN(_exp, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpMax.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpMax\n/// @notice Opcode to stack the maximum of N numbers.\nlibrary OpMax {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _max(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ > b_ ? a_ : b_;\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFnN(stackTop_, _max, Operand.unwrap(operand_));\n    }\n\n    function max(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop stackTopAfter_) {\n        return stackTop_.applyFnN(_max, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpMin.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpMin\n/// @notice Opcode to stack the minimum of N numbers.\nlibrary OpMin {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _min(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ < b_ ? a_ : b_;\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFnN(stackTop_, _min, Operand.unwrap(operand_));\n    }\n\n    function min(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop stackTopAfter_) {\n        return stackTop_.applyFnN(_min, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpMod.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpMod\n/// @notice Opcode to mod N numbers.\nlibrary OpMod {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _mod(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ % b_;\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFnN(stackTop_, _mod, Operand.unwrap(operand_));\n    }\n\n    function mod(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop stackTopAfter_) {\n        return stackTop_.applyFnN(_mod, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpMul.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpMul\n/// @notice Opcode for multiplying N numbers.\nlibrary OpMul {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _mul(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ * b_;\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFnN(stackTop_, _mul, Operand.unwrap(operand_));\n    }\n\n    function mul(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop stackTopAfter_) {\n        return stackTop_.applyFnN(_mul, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpSub.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpSub\n/// @notice Opcode for subtracting N numbers.\nlibrary OpSub {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _sub(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ - b_;\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFnN(stackTop_, _sub, Operand.unwrap(operand_));\n    }\n\n    function sub(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop stackTopAfter_) {\n        return stackTop_.applyFnN(_sub, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/saturating/OpSaturatingAdd.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/SaturatingMath.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpSaturatingAdd\n/// @notice Opcode for adding N numbers with saturating addition.\nlibrary OpSaturatingAdd {\n    using SaturatingMath for uint256;\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFnN(\n                stackTop_,\n                SaturatingMath.saturatingAdd,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function saturatingAdd(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop stackTopAfter_) {\n        return\n            stackTop_.applyFnN(\n                SaturatingMath.saturatingAdd,\n                Operand.unwrap(operand_)\n            );\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/saturating/OpSaturatingMul.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/SaturatingMath.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpSaturatingMul\n/// @notice Opcode for multiplying N numbers with saturating multiplication.\nlibrary OpSaturatingMul {\n    using SaturatingMath for uint256;\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFnN(\n                stackTop_,\n                SaturatingMath.saturatingMul,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function saturatingMul(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop stackTopAfter_) {\n        return\n            stackTop_.applyFnN(\n                SaturatingMath.saturatingMul,\n                Operand.unwrap(operand_)\n            );\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/saturating/OpSaturatingSub.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/SaturatingMath.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpSaturatingSub\n/// @notice Opcode for subtracting N numbers with saturating subtraction.\nlibrary OpSaturatingSub {\n    using SaturatingMath for uint256;\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFnN(\n                stackTop_,\n                SaturatingMath.saturatingSub,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function saturatingSub(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop stackTopAfter_) {\n        return\n            stackTop_.applyFnN(\n                SaturatingMath.saturatingSub,\n                Operand.unwrap(operand_)\n            );\n    }\n}\n"
    },
    "contracts/interpreter/ops/rain/IOrderBookV1/OpIOrderBookV1VaultBalance.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../orderbook/IOrderBookV1.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpIOrderBookV1VaultBalance\n/// @notice Opcode for IOrderBookV1 `vaultBalance`.\nlibrary OpIOrderBookV1VaultBalance {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function f(\n        uint256 orderbook_,\n        uint owner_,\n        uint token_,\n        uint id_\n    ) internal view returns (uint256) {\n        return\n            uint256(\n                uint160(\n                    IOrderBookV1(address(uint160(orderbook_))).vaultBalance(\n                        address(uint160(owner_)),\n                        address(uint160(token_)),\n                        id_\n                    )\n                )\n            );\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/rain/ISaleV2/OpISaleV2RemainingTokenInventory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../sale/ISaleV2.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpISaleV2RemainingTokenInventory\n/// @notice Opcode for ISaleV2 `remainingTokenInventory`.\nlibrary OpISaleV2RemainingTokenInventory {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function f(uint256 sale_) internal view returns (uint256) {\n        return ISaleV2(address(uint160(sale_))).remainingTokenInventory();\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, f);\n    }\n\n    /// Stack `remainingTokenInventory`.\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/rain/ISaleV2/OpISaleV2Reserve.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../sale/ISaleV2.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpISaleV2Reserve\n/// @notice Opcode for ISaleV2 `reserve`.\nlibrary OpISaleV2Reserve {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function f(uint256 sale_) internal view returns (uint256) {\n        return uint256(uint160(ISaleV2(address(uint160(sale_))).reserve()));\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, f);\n    }\n\n    /// Stack `reserve`.\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/rain/ISaleV2/OpISaleV2SaleStatus.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../sale/ISaleV2.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpISaleV2SaleStatus\n/// @notice Opcode for ISaleV2 `saleStatus`.\nlibrary OpISaleV2SaleStatus {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function f(uint256 sale_) internal view returns (uint256) {\n        return uint(ISaleV2(address(uint160(sale_))).saleStatus());\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, f);\n    }\n\n    /// Stack `saleStatus`.\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/rain/ISaleV2/OpISaleV2Token.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../sale/ISaleV2.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpISaleV2Token\n/// @notice Opcode for ISaleV2 `token`.\nlibrary OpISaleV2Token {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function f(uint256 sale_) internal view returns (uint256) {\n        return uint256(uint160(ISaleV2(address(uint160(sale_))).token()));\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, f);\n    }\n\n    /// Stack `token`.\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/rain/ISaleV2/OpISaleV2TotalReserveReceived.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../sale/ISaleV2.sol\";\nimport \"../../../run/LibStackTop.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityState.sol\";\n\n/// @title OpISaleV2TotalReserveReceived\n/// @notice Opcode for ISaleV2 `totalReserveReceived`.\nlibrary OpISaleV2TotalReserveReceived {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function f(uint256 sale_) internal view returns (uint256) {\n        return ISaleV2(address(uint160(sale_))).totalReserveReceived();\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, f);\n    }\n\n    /// Stack `totalReserveReceived`.\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/tier/OpITierV2Report.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../tier/ITierV2.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpITierV2Report\n/// @notice Exposes `ITierV2.report` as an opcode.\nlibrary OpITierV2Report {\n    using LibStackTop for StackTop;\n    using LibStackTop for uint256[];\n    using LibIntegrityState for IntegrityState;\n\n    function _report(\n        uint256 tierContract_,\n        uint256 account_,\n        uint256[] memory context_\n    ) internal view returns (uint256) {\n        return\n            ITierV2(address(uint160(tierContract_))).report(\n                address(uint160(account_)),\n                context_\n            );\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFn(\n                stackTop_,\n                _report,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    // Stack the `report` returned by an `ITierV2` contract.\n    function report(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop stackTopAfter_) {\n        return stackTop_.applyFn(_report, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/tier/OpITierV2ReportTimeForTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../tier/ITierV2.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\n/// @title OpITierV2Report\n/// @notice Exposes `ITierV2.reportTimeForTier` as an opcode.\nlibrary OpITierV2ReportTimeForTier {\n    using LibStackTop for StackTop;\n    using LibStackTop for uint256[];\n    using LibIntegrityState for IntegrityState;\n\n    function _reportTimeForTier(\n        uint256 tierContract_,\n        uint256 account_,\n        uint256 tier_,\n        uint256[] memory context_\n    ) internal view returns (uint256) {\n        return\n            ITierV2(address(uint160(tierContract_))).reportTimeForTier(\n                address(uint160(account_)),\n                tier_,\n                context_\n            );\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFn(\n                stackTop_,\n                _reportTimeForTier,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    // Stack the `reportTimeForTier` returned by an `ITierV2` contract.\n    function reportTimeForTier(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_reportTimeForTier, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/tier/OpSaturatingDiff.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../tier/libraries/TierwiseCombine.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\nlibrary OpSaturatingDiff {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return\n            integrityState_.applyFn(stackTop_, TierwiseCombine.saturatingSub);\n    }\n\n    // Stack the tierwise saturating subtraction of two reports.\n    // If the older report is newer than newer report the result will\n    // be `0`, else a tierwise diff in blocks will be obtained.\n    // The older and newer report are taken from the stack.\n    function saturatingDiff(\n        InterpreterState memory,\n        Operand,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(TierwiseCombine.saturatingSub);\n    }\n}\n"
    },
    "contracts/interpreter/ops/tier/OpSelectLte.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../tier/libraries/TierwiseCombine.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\nimport \"../../../math/Binary.sol\";\n\n/// @title OpSelectLte\n/// @notice Exposes `TierwiseCombine.selectLte` as an opcode.\nlibrary OpSelectLte {\n    using LibStackTop for StackTop;\n    using LibStackTop for uint256[];\n    using LibIntegrityState for IntegrityState;\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\n            require(inputs_ > 0, \"SELECT_LTE_ZERO_INPUTS\");\n            return\n                integrityState_.push(integrityState_.pop(stackTop_, inputs_));\n        }\n    }\n\n    // Stacks the result of a `selectLte` combinator.\n    // All `selectLte` share the same stack and argument handling.\n    // Takes the `logic_` and `mode_` from the `operand_` high bits.\n    // `logic_` is the highest bit.\n    // `mode_` is the 2 highest bits after `logic_`.\n    // The other bits specify how many values to take from the stack\n    // as reports to compare against each other and the block number.\n    function selectLte(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            uint inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\n            uint mode_ = (Operand.unwrap(operand_) >> 8) & MASK_2BIT;\n            uint logic_ = Operand.unwrap(operand_) >> 10;\n            (uint256 time_, uint256[] memory reports_) = stackTop_.list(\n                inputs_\n            );\n            return\n                reports_.asStackTop().push(\n                    TierwiseCombine.selectLte(logic_, mode_, time_, reports_)\n                );\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/tier/OpUpdateTimesForTierRange.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../tier/libraries/TierReport.sol\";\nimport \"../../run/LibStackTop.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityState.sol\";\n\nlibrary OpUpdateTimesForTierRange {\n    using LibStackTop for StackTop;\n    using LibIntegrityState for IntegrityState;\n\n    function _updateTimesForTierRange(\n        Operand operand_,\n        uint256 report_,\n        uint256 timestamp_\n    ) internal pure returns (uint256) {\n        return\n            TierReport.updateTimesForTierRange(\n                report_,\n                // start tier.\n                // 4 low bits.\n                Operand.unwrap(operand_) & 0x0f,\n                // end tier.\n                // 4 high bits.\n                (Operand.unwrap(operand_) >> 4) & 0x0f,\n                timestamp_\n            );\n    }\n\n    function integrity(\n        IntegrityState memory integrityState_,\n        Operand,\n        StackTop stackTop_\n    ) internal pure returns (StackTop) {\n        return integrityState_.applyFn(stackTop_, _updateTimesForTierRange);\n    }\n\n    // Stacks a report with updated times over tier range.\n    // The start and end tier are taken from the low and high bits of\n    // the `operand_` respectively.\n    // The report to update and timestamp to update to are both\n    // taken from the stack.\n    function updateTimesForTierRange(\n        InterpreterState memory,\n        Operand operand_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return stackTop_.applyFn(_updateTimesForTierRange, operand_);\n    }\n}\n"
    },
    "contracts/interpreter/run/IInterpreterV1.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\ntype SourceIndex is uint;\ntype EncodedDispatch is uint256;\ntype StateNamespace is uint;\n\ninterface IInterpreterV1 {\n    function functionPointers() external view returns (bytes memory);\n\n    function eval(\n        EncodedDispatch dispatch,\n        uint256[][] memory context\n    )\n        external\n        view\n        returns (uint256[] memory stack, uint[] memory stateChanges);\n\n    function stateChanges(uint[] memory stateChanges) external;\n\n    function evalWithNamespace(\n        StateNamespace namespace,\n        EncodedDispatch dispatch,\n        uint[][] memory context\n    ) external view returns (uint[] memory stack, uint[] memory stateChanges);\n\n    function stateChangesWithNamespace(\n        StateNamespace namespace,\n        uint[] memory stateChanges\n    ) external;\n}\n"
    },
    "contracts/interpreter/run/LibInterpreterState.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../run/IInterpreterV1.sol\";\nimport \"../deploy/IExpressionDeployerV1.sol\";\nimport \"./LibStackTop.sol\";\nimport \"../../type/LibCast.sol\";\nimport \"../../type/LibConvert.sol\";\nimport \"../../array/LibUint256Array.sol\";\nimport \"../../memory/LibMemorySize.sol\";\nimport \"hardhat/console.sol\";\nimport {SafeCastUpgradeable as SafeCast} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {Operand} from \"./RainInterpreter.sol\";\nimport \"../../kv/LibMemoryKV.sol\";\n\nenum DebugStyle {\n    Stack,\n    Constant,\n    Context,\n    Source\n}\n\n/// Everything required to evaluate and track the state of a Rain expression.\n/// As this is a struct it will be in memory when passed to `RainInterpreter` and so\n/// will be modified by reference internally. This is important for gas\n/// efficiency; the stack, arguments and stackIndex will likely be mutated by\n/// the running expression.\n/// @param stackIndex Opcodes write to the stack at the stack index and can\n/// consume from the stack by decrementing the index and reading between the\n/// old and new stack index.\n/// IMPORANT: The stack is never zeroed out so the index must be used to\n/// find the \"top\" of the stack as the result of an `eval`.\n/// @param stack Stack is the general purpose runtime state that opcodes can\n/// read from and write to according to their functionality.\n/// @param sources Sources available to be executed by `eval`.\n/// Notably `ZIPMAP` can also select a source to execute by index.\n/// @param constants Constants that can be copied to the stack by index by\n/// `VAL`.\n/// @param arguments `ZIPMAP` populates arguments which can be copied to the\n/// stack by `VAL`.\nstruct InterpreterState {\n    StackTop stackBottom;\n    StackTop constantsBottom;\n    MemoryKV stateKV;\n    StateNamespace stateNamespace;\n    uint256[][] context;\n    bytes[] compiledSources;\n}\n\nstring constant DEBUG_DELIMETER = \"~~~\";\n\nlibrary LibInterpreterState {\n    using SafeCast for uint256;\n    using LibMemorySize for uint256;\n    using LibMemorySize for uint256[];\n    using LibMemorySize for bytes;\n    using LibUint256Array for uint256[];\n    using LibUint256Array for uint256;\n    using LibInterpreterState for InterpreterState;\n    using LibStackTop for uint256[];\n    using LibStackTop for StackTop;\n    using LibStackTop for bytes;\n    using LibCast for uint256;\n    using LibCast for function(InterpreterState memory, SourceIndex, StackTop)\n        view\n        returns (StackTop);\n    using LibCast for function(InterpreterState memory, Operand, StackTop)\n        view\n        returns (StackTop)[];\n    using LibConvert for uint256[];\n\n    function debugArray(uint256[] memory array_) internal view {\n        console.log(DEBUG_DELIMETER);\n        for (uint256 i_ = 0; i_ < array_.length; i_++) {\n            console.log(i_, array_[i_]);\n        }\n        console.log(DEBUG_DELIMETER);\n    }\n\n    function debugStack(\n        StackTop stackBottom_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        uint256 length_ = stackBottom_.toIndex(stackTop_);\n        debugArray(\n            StackTop.unwrap(stackTop_.down(length_)).copyToNewUint256Array(\n                length_\n            )\n        );\n        return stackTop_;\n    }\n\n    function debugStack(\n        InterpreterState memory state_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        return debugStack(state_.stackBottom, stackTop_);\n    }\n\n    /// Console log various aspects of the Interpreter state.\n    /// Gas intensive and relies on hardhat console so not intended for\n    /// production but great for debugging Rain expressions.\n    function debug(\n        InterpreterState memory state_,\n        StackTop stackTop_,\n        DebugStyle debugStyle_\n    ) internal view returns (StackTop) {\n        if (debugStyle_ == DebugStyle.Source) {\n            for (uint256 i_ = 0; i_ < state_.compiledSources.length; i_++) {\n                console.logBytes(state_.compiledSources[i_]);\n            }\n        } else {\n            if (debugStyle_ == DebugStyle.Stack) {\n                state_.debugStack(stackTop_);\n            } else if (debugStyle_ == DebugStyle.Constant) {\n                debugArray(state_.constantsBottom.down().asUint256Array());\n            } else {\n                for (uint256 i_ = 0; i_ < state_.context.length; i_++) {\n                    debugArray(state_.context[i_]);\n                }\n            }\n        }\n        return stackTop_;\n    }\n\n    function serialize(\n        StateConfig memory config_,\n        uint256 stackLength_,\n        bytes memory opcodeFunctionPointers_\n    ) internal pure returns (bytes memory) {\n        unchecked {\n            uint256 size_ = 0;\n            size_ += stackLength_.size();\n            size_ += config_.constants.size();\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\n                size_ += config_.sources[i_].size();\n            }\n            bytes memory serialized_ = new bytes(size_);\n            StackTop cursor_ = serialized_.asStackTop().up();\n\n            // Copy stack length.\n            cursor_ = cursor_.push(stackLength_);\n\n            // Then the constants.\n            cursor_ = cursor_.pushWithLength(config_.constants);\n\n            // Last the sources.\n            bytes memory source_;\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\n                source_ = config_.sources[i_];\n                compile(source_, opcodeFunctionPointers_);\n                cursor_ = cursor_.unalignedPushWithLength(source_);\n            }\n            return serialized_;\n        }\n    }\n\n    function deserialize(\n        bytes memory serialized_\n    ) internal pure returns (InterpreterState memory) {\n        unchecked {\n            InterpreterState memory state_;\n\n            // Context will probably be overridden by the caller according to the\n            // context scratch that we deserialize so best to just set it empty\n            // here.\n            state_.context = new uint256[][](0);\n\n            StackTop cursor_ = serialized_.asStackTop().up();\n            // The end of processing is the end of the state bytes.\n            StackTop end_ = cursor_.upBytes(cursor_.peek());\n\n            // Read the stack length and build a stack.\n            cursor_ = cursor_.up();\n            uint256 stackLength_ = cursor_.peek();\n\n            // The stack is never stored in stack bytes so we allocate a new\n            // array for it with length as per the indexes and point the state\n            // at it.\n            uint256[] memory stack_ = new uint256[](stackLength_);\n            state_.stackBottom = stack_.asStackTopUp();\n\n            // Reference the constants array and move cursor past it.\n            cursor_ = cursor_.up();\n            state_.constantsBottom = cursor_;\n            cursor_ = cursor_.up(cursor_.peek());\n\n            // Rebuild the sources array.\n            uint256 i_ = 0;\n            StackTop lengthCursor_ = cursor_;\n            uint256 sourcesLength_ = 0;\n            while (StackTop.unwrap(lengthCursor_) < StackTop.unwrap(end_)) {\n                lengthCursor_ = lengthCursor_\n                    .upBytes(lengthCursor_.peekUp())\n                    .up();\n                sourcesLength_++;\n            }\n            state_.compiledSources = new bytes[](sourcesLength_);\n            while (StackTop.unwrap(cursor_) < StackTop.unwrap(end_)) {\n                state_.compiledSources[i_] = cursor_.asBytes();\n                cursor_ = cursor_.upBytes(cursor_.peekUp()).up();\n                i_++;\n            }\n            return state_;\n        }\n    }\n\n    /// Given a source in opcodes compile to an equivalent source with real\n    /// function pointers for a given Interpreter contract. The \"compilation\"\n    /// involves simply replacing the opcode with the pointer at the index of\n    /// the opcode. i.e. opcode 4 will be replaced with `pointers_[4]`.\n    /// Relies heavily on the integrity checks ensuring opcodes used are not OOB\n    /// and that the pointers provided are valid and in the correct order.\n    /// Hopefully it goes without saying that the list of pointers MUST NOT be\n    /// user defined, otherwise any source can be compiled with a completely\n    /// different mapping between opcodes and dispatched functions.\n    function compile(\n        bytes memory source_,\n        bytes memory pointers_\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            for {\n                let replaceMask_ := 0xFFFF\n                let preserveMask_ := not(replaceMask_)\n                let sourceLength_ := mload(source_)\n                let pointersBottom_ := add(pointers_, 2)\n                let cursor_ := add(source_, 2)\n                let end_ := add(source_, sourceLength_)\n            } lt(cursor_, end_) {\n                cursor_ := add(cursor_, 4)\n            } {\n                let data_ := mload(cursor_)\n                let pointer_ := and(\n                    replaceMask_,\n                    mload(\n                        add(pointersBottom_, mul(2, and(data_, replaceMask_)))\n                    )\n                )\n                mstore(cursor_, or(and(data_, preserveMask_), pointer_))\n            }\n        }\n    }\n\n    /// Evaluates a Rain expression.\n    /// The main workhorse of the rain Interpreter, `eval` runs any core opcodes\n    /// and dispatches anything it is unaware of to the implementing contract.\n    /// For an expression to be useful the implementing contract must override\n    /// `applyOp` and dispatch non-core opcodes to domain specific logic. This\n    /// could be mathematical operations for a calculator, tier reports for\n    /// a membership combinator, entitlements for a minting curve, etc.\n    ///\n    /// Everything required to coordinate the execution of a Rain expression to\n    /// completion is contained in the `State`. The context and source index\n    /// are provided so the caller can provide additional data and kickoff the\n    /// opcode dispatch from the correct source in `sources`.\n    function eval(\n        InterpreterState memory state_,\n        SourceIndex sourceIndex_,\n        StackTop stackTop_\n    ) internal view returns (StackTop) {\n        unchecked {\n            uint256 cursor_;\n            uint256 end_;\n            assembly (\"memory-safe\") {\n                cursor_ := mload(\n                    add(\n                        mload(add(state_, 0xA0)),\n                        add(0x20, mul(0x20, sourceIndex_))\n                    )\n                )\n                end_ := add(cursor_, mload(cursor_))\n            }\n\n            // Loop until complete.\n            while (cursor_ < end_) {\n                function(InterpreterState memory, Operand, StackTop)\n                    internal\n                    view\n                    returns (StackTop) fn_;\n                Operand operand_;\n                cursor_ += 4;\n                {\n                    uint256 op_;\n                    assembly (\"memory-safe\") {\n                        op_ := mload(cursor_)\n                        operand_ := and(op_, 0xFFFF)\n                        fn_ := and(shr(16, op_), 0xFFFF)\n                    }\n                }\n                stackTop_ = fn_(state_, operand_, stackTop_);\n            }\n            return stackTop_;\n        }\n    }\n}\n"
    },
    "contracts/interpreter/run/LibStackTop.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"./RainInterpreter.sol\";\nimport \"../../array/LibUint256Array.sol\";\nimport \"../../bytes/LibBytes.sol\";\n\n/// Custom type to point to memory ostensibly in a stack.\ntype StackTop is uint256;\n\n/// @title LibStackTop\n/// @notice A `StackTop` is just a pointer to some memory. Ostensibly it is the\n/// top of some stack used by the `RainInterpreter` so that means it can move \"up\" and\n/// \"down\" (increment and decrement) by `uint256` (32 bytes) increments. In\n/// general we're abusing that concept a bit to extend to things like the bottom\n/// of a stack or a hypothetical maximum stack or even treating an arbitrary\n/// `uint256[]` array as \"a stack\". In the future it's likely this lib and\n/// concept will be renamed to reflect that it is used much more generally than\n/// simply the top of some stack.\n/// All the functions in `LibStackTop` operate on memory to read/write what is\n/// referenced but the pointers and values themselves are typically input/output\n/// of the functions. I.e. the stack top itself is not being mutated in-place,\n/// typically the caller would have both the input stack top and the output\n/// stack top in scope after calling library functions.\n/// Most of the functions in this library are equivalent to each other via\n/// composition, i.e. everything could be achieved with just `up`, `down`,\n/// `pop`, `push`, `peek`. The reason there is so much duplication of logic is\n/// that the Solidity compiler seems to fail at inlining equivalent logic quite\n/// a lot sadly. There appears to be effort upstream towards improving the\n/// function inlining by the optimizer so we should expect a lot of this library\n/// to become redundant or even counterproductive in the future.\nlibrary LibStackTop {\n    using LibStackTop for StackTop;\n    using LibStackTop for uint256[];\n    using LibStackTop for bytes;\n    using LibUint256Array for uint256[];\n    using LibBytes for uint256;\n\n    /// Reads the value above the stack top. If the stack top is the current\n    /// true stack top this is an out of bounds read. This is only useful if\n    /// the stack was first moved down and the value it moved past needs to be\n    /// read as part of the current operation.\n    /// @param stackTop_ Position to read past/above.\n    function peekUp(StackTop stackTop_) internal pure returns (uint256 a_) {\n        assembly (\"memory-safe\") {\n            a_ := mload(stackTop_)\n        }\n    }\n\n    /// Read the value immediately below the given stack top. Equivalent to\n    /// calling `pop` and discarding the `stackTopAfter_` value, so may be\n    /// less gas than setting and discarding a value.\n    /// @param stackTop_ The stack top to read below.\n    /// @return a_ The value that was read.\n    function peek(StackTop stackTop_) internal pure returns (uint256 a_) {\n        assembly (\"memory-safe\") {\n            a_ := mload(sub(stackTop_, 0x20))\n        }\n    }\n\n    /// Reads 2 values below the given stack top.\n    /// The following statements are equivalent but A may use gas if the\n    /// compiler fails to inline some function calls.\n    /// A:\n    /// ```\n    /// (uint a_, uint b_) = stackTop_.peek2();\n    /// ```\n    /// B:\n    /// ```\n    /// uint b_;\n    /// (stackTop_, b_) = stackTop_.pop();\n    /// uint a_ = stackTop_.peek();\n    /// ```\n    /// @param stackTop_ The stack top to peek below.\n    function peek2(\n        StackTop stackTop_\n    ) internal pure returns (uint256 a_, uint256 b_) {\n        assembly (\"memory-safe\") {\n            a_ := mload(sub(stackTop_, 0x40))\n            b_ := mload(sub(stackTop_, 0x20))\n        }\n    }\n\n    /// Read the value immediately below the given stack top and return the\n    /// stack top that points to the value that was read alongside the value.\n    /// The following are equivalent but A may be cheaper if the compiler\n    /// fails to inline some function calls:\n    /// A:\n    /// ```\n    /// uint a_;\n    /// (stackTop_, a_) = stackTop_.pop();\n    /// ```\n    /// B:\n    /// ```\n    /// stackTop_ = stackTop_.down();\n    /// uint a_ = stackTop_.peekUp();\n    /// ```\n    /// @param stackTop_ The stack top to read below.\n    /// @return stackTopAfter_ The stack top that points to the value that was\n    /// read.\n    /// @return a_ The value that was read.\n    function pop(\n        StackTop stackTop_\n    ) internal pure returns (StackTop stackTopAfter_, uint256 a_) {\n        assembly (\"memory-safe\") {\n            stackTopAfter_ := sub(stackTop_, 0x20)\n            a_ := mload(stackTopAfter_)\n        }\n    }\n\n    function consumeSentinel(\n        StackTop stackTop_,\n        StackTop stackBottom_,\n        uint256 sentinel_,\n        uint256 stepSize_\n    ) internal pure returns (StackTop, uint256[] memory) {\n        uint256[] memory array_;\n        assembly (\"memory-safe\") {\n            // Underflow is not allowed and pointing at position 0 in memory is\n            // corrupt behaviour anyway.\n            if iszero(stackBottom_) {\n                revert(0, 0)\n            }\n            let sentinelLocation_ := 0\n            let length_ := 0\n            let step_ := mul(stepSize_, 0x20)\n            for {\n                stackTop_ := sub(stackTop_, 0x20)\n                let end_ := sub(stackBottom_, 0x20)\n            } gt(stackTop_, end_) {\n                stackTop_ := sub(stackTop_, step_)\n                length_ := add(length_, stepSize_)\n            } {\n                if eq(sentinel_, mload(stackTop_)) {\n                    sentinelLocation_ := stackTop_\n                    break\n                }\n            }\n            // Sentinel MUST exist in the stack if consumer expects it to there.\n            if iszero(sentinelLocation_) {\n                revert(0, 0)\n            }\n            mstore(sentinelLocation_, length_)\n            array_ := sentinelLocation_\n        }\n        return (stackTop_, array_);\n    }\n\n    function consumeStructs(\n        StackTop stackTop_,\n        StackTop stackBottom_,\n        uint256 sentinel_,\n        uint256 structSize_\n    ) internal pure returns (StackTop, uint256[] memory) {\n        uint256[] memory tempArray_;\n        (stackTop_, tempArray_) = stackTop_.consumeSentinel(\n            stackBottom_,\n            sentinel_,\n            structSize_\n        );\n        uint256 structsLength_ = tempArray_.length / structSize_;\n        uint256[] memory refs_ = new uint256[](structsLength_);\n        assembly (\"memory-safe\") {\n            for {\n                let refCursor_ := add(refs_, 0x20)\n                let refEnd_ := add(refCursor_, mul(structsLength_, 0x20))\n                let tempCursor_ := add(tempArray_, 0x20)\n                let tempStepSize_ := mul(structSize_, 0x20)\n            } lt(refCursor_, refEnd_) {\n                refCursor_ := add(refCursor_, 0x20)\n                tempCursor_ := add(tempCursor_, tempStepSize_)\n            } {\n                mstore(refCursor_, tempCursor_)\n            }\n        }\n        return (stackTop_, refs_);\n    }\n\n    /// Write a value at the stack top location. Typically not useful if the\n    /// given stack top is not subsequently moved past the written value , or\n    /// if the given stack top is actually located somewhere below the \"true\"\n    /// stack top.\n    /// @param stackTop_ The stack top to write the value at.\n    /// @param a_ The value to write.\n    function set(StackTop stackTop_, uint256 a_) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(stackTop_, a_)\n        }\n    }\n\n    /// Store a `uint256` at the stack top position and return the stack top\n    /// above the written value. The following statements are equivalent in\n    /// functionality but A may be less gas if the compiler fails to inline\n    /// some function calls.\n    /// A:\n    /// ```\n    /// stackTop_ = stackTop_.push(a_);\n    /// ```\n    /// B:\n    /// ```\n    /// stackTop_.set(a_);\n    /// stackTop_ = stackTop_.up();\n    /// ```\n    /// @param stackTop_ The stack top to write at.\n    /// @param a_ The value to write.\n    /// @return The stack top above where `a_` was written to.\n    function push(\n        StackTop stackTop_,\n        uint256 a_\n    ) internal pure returns (StackTop) {\n        assembly (\"memory-safe\") {\n            mstore(stackTop_, a_)\n            stackTop_ := add(stackTop_, 0x20)\n        }\n        return stackTop_;\n    }\n\n    /// Store a `uint256[]` at the stack top position and return the stack top\n    /// above the written values. The length of the array is NOT written to the\n    /// stack, ONLY the array values are copied to the stack. The following\n    /// statements are equivalent in functionality but A may be less gas if the\n    /// compiler fails to inline some function calls.\n    /// A:\n    /// ```\n    /// stackTop_ = stackTop_.push(array_);\n    /// ```\n    /// B:\n    /// ```\n    /// unchecked {\n    ///   for (uint i_ = 0; i_ < array_.length; i_++) {\n    ///     stackTop_ = stackTop_.push(array_[i_]);\n    ///   }\n    /// }\n    /// ```\n    /// @param stackTop_ The stack top to write at.\n    /// @param array_ The array of values to write.\n    /// @return The stack top above the array.\n    function push(\n        StackTop stackTop_,\n        uint256[] memory array_\n    ) internal pure returns (StackTop) {\n        array_.unsafeCopyValuesTo(StackTop.unwrap(stackTop_));\n        return stackTop_.up(array_.length);\n    }\n\n    /// Store a `uint256[]` at the stack top position and return the stack top\n    /// above the written values. The length of the array IS written to the\n    /// stack.\n    /// @param stackTop_ The stack top to write at.\n    /// @param array_ The array of values and length to write.\n    /// @return The stack top above the array.\n    function pushWithLength(\n        StackTop stackTop_,\n        uint256[] memory array_\n    ) internal pure returns (StackTop) {\n        return stackTop_.push(array_.length).push(array_);\n    }\n\n    /// Store `bytes` at the stack top position and return the stack top above\n    /// the written bytes. The length of the bytes is NOT written to the stack,\n    /// ONLY the bytes are written. As `bytes` may be of arbitrary length, i.e.\n    /// it MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\n    /// ensure that this is safe in context of subsequent reads and writes.\n    /// @param stackTop_ The stack top to write at.\n    /// @param bytes_ The bytes to write at the stack top.\n    /// @return The stack top above the written bytes.\n    function unalignedPush(\n        StackTop stackTop_,\n        bytes memory bytes_\n    ) internal pure returns (StackTop) {\n        StackTop.unwrap(bytes_.asStackTop().up()).unsafeCopyBytesTo(\n            StackTop.unwrap(stackTop_),\n            bytes_.length\n        );\n        return stackTop_.upBytes(bytes_.length);\n    }\n\n    /// Store `bytes` at the stack top position and return the stack top above\n    /// the written bytes. The length of the bytes IS written to the stack in\n    /// addition to the bytes. As `bytes` may be of arbitrary length, i.e. it\n    /// MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\n    /// ensure that this is safe in context of subsequent reads and writes.\n    /// @param stackTop_ The stack top to write at.\n    /// @param bytes_ The bytes to write with their length at the stack top.\n    /// @return The stack top above the written bytes.\n    function unalignedPushWithLength(\n        StackTop stackTop_,\n        bytes memory bytes_\n    ) internal pure returns (StackTop) {\n        return stackTop_.push(bytes_.length).unalignedPush(bytes_);\n    }\n\n    /// Store 8x `uint256` at the stack top position and return the stack top\n    /// above the written value. The following statements are equivalent in\n    /// functionality but A may be cheaper if the compiler fails to\n    /// inline some function calls.\n    /// A:\n    /// ```\n    /// stackTop_ = stackTop_.push(a_, b_, c_, d_, e_, f_, g_, h_);\n    /// ```\n    /// B:\n    /// ```\n    /// stackTop_ = stackTop_\n    ///   .push(a_)\n    ///   .push(b_)\n    ///   .push(c_)\n    ///   .push(d_)\n    ///   .push(e_)\n    ///   .push(f_)\n    ///   .push(g_)\n    ///   .push(h_);\n    /// @param stackTop_ The stack top to write at.\n    /// @param a_ The first value to write.\n    /// @param b_ The second value to write.\n    /// @param c_ The third value to write.\n    /// @param d_ The fourth value to write.\n    /// @param e_ The fifth value to write.\n    /// @param f_ The sixth value to write.\n    /// @param g_ The seventh value to write.\n    /// @param h_ The eighth value to write.\n    /// @return The stack top above where `h_` was written.\n    function push(\n        StackTop stackTop_,\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256 d_,\n        uint256 e_,\n        uint256 f_,\n        uint256 g_,\n        uint256 h_\n    ) internal pure returns (StackTop) {\n        assembly (\"memory-safe\") {\n            mstore(stackTop_, a_)\n            mstore(add(stackTop_, 0x20), b_)\n            mstore(add(stackTop_, 0x40), c_)\n            mstore(add(stackTop_, 0x60), d_)\n            mstore(add(stackTop_, 0x80), e_)\n            mstore(add(stackTop_, 0xA0), f_)\n            mstore(add(stackTop_, 0xC0), g_)\n            mstore(add(stackTop_, 0xE0), h_)\n            stackTop_ := add(stackTop_, 0x100)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256) internal view returns (uint256) fn_\n    ) internal view returns (StackTop) {\n        uint256 a_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n        }\n        a_ = fn_(a_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(Operand, uint256) internal view returns (uint256) fn_,\n        Operand operand_\n    ) internal view returns (StackTop) {\n        uint256 a_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n        }\n        a_ = fn_(operand_, a_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256, uint256) internal view returns (uint256) fn_\n    ) internal view returns (StackTop) {\n        uint256 a_;\n        uint256 b_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            stackTop_ := sub(stackTop_, 0x20)\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTop_)\n        }\n        a_ = fn_(a_, b_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Reduce a function N times, reading and writing inputs and the accumulated\n    /// result on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\n    function applyFnN(\n        StackTop stackTop_,\n        function(uint256, uint256) internal view returns (uint256) fn_,\n        uint256 n_\n    ) internal view returns (StackTop stackTopAfter_) {\n        unchecked {\n            uint256 bottom_;\n            uint256 cursor_;\n            uint256 a_;\n            uint256 b_;\n            assembly (\"memory-safe\") {\n                bottom_ := sub(stackTop_, mul(n_, 0x20))\n                a_ := mload(bottom_)\n                stackTopAfter_ := add(bottom_, 0x20)\n                cursor_ := stackTopAfter_\n            }\n            while (cursor_ < StackTop.unwrap(stackTop_)) {\n                assembly (\"memory-safe\") {\n                    b_ := mload(cursor_)\n                }\n                a_ = fn_(a_, b_);\n                cursor_ += 0x20;\n            }\n            assembly (\"memory-safe\") {\n                mstore(bottom_, a_)\n            }\n        }\n    }\n\n    function applyFnN(\n        StackTop stackTop_,\n        function(uint256) internal view fn_,\n        uint256 n_\n    ) internal view returns (StackTop stackTopAfter_) {\n        uint256 cursor_;\n        uint256 a_;\n        assembly (\"memory-safe\") {\n            stackTopAfter_ := sub(stackTop_, mul(n_, 0x20))\n            cursor_ := stackTopAfter_\n        }\n        while (cursor_ < StackTop.unwrap(stackTop_)) {\n            assembly (\"memory-safe\") {\n                a_ := mload(cursor_)\n                cursor_ := add(cursor_, 0x20)\n            }\n            fn_(a_);\n        }\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256, uint256, uint256) internal view returns (uint256) fn_\n    ) internal view returns (StackTop) {\n        uint256 a_;\n        uint256 b_;\n        uint256 c_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            stackTop_ := sub(stackTop_, 0x40)\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTop_)\n            c_ := mload(add(stackTop_, 0x20))\n        }\n        a_ = fn_(a_, b_, c_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256, uint256, uint256, uint)\n            internal\n            view\n            returns (uint256) fn_\n    ) internal view returns (StackTop) {\n        uint256 a_;\n        uint256 b_;\n        uint256 c_;\n        uint d_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            stackTop_ := sub(stackTop_, 0x60)\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTop_)\n            c_ := mload(add(stackTop_, 0x20))\n            d_ := mload(add(stackTop_, 0x40))\n        }\n        a_ = fn_(a_, b_, c_, d_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param operand_ Operand is passed from the source instead of the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(Operand, uint256, uint256) internal view returns (uint256) fn_,\n        Operand operand_\n    ) internal view returns (StackTop) {\n        uint256 a_;\n        uint256 b_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            stackTop_ := sub(stackTop_, 0x20)\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTop_)\n        }\n        a_ = fn_(operand_, a_, b_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256[] memory) internal view returns (uint256) fn_,\n        uint256 length_\n    ) internal view returns (StackTop stackTopAfter_) {\n        (uint256 a_, uint256[] memory tail_) = stackTop_.list(length_);\n        uint256 b_ = fn_(tail_);\n        return tail_.asStackTop().push(a_).push(b_);\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param length_ The length of the array to pass to fn_ from the stack.\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256, uint256, uint256[] memory)\n            internal\n            view\n            returns (uint256) fn_,\n        uint256 length_\n    ) internal view returns (StackTop stackTopAfter_) {\n        (uint256 b_, uint256[] memory tail_) = stackTop_.list(length_);\n        stackTopAfter_ = tail_.asStackTop();\n        (StackTop location_, uint256 a_) = stackTopAfter_.pop();\n        location_.set(fn_(a_, b_, tail_));\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param length_ The length of the array to pass to fn_ from the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256, uint256, uint256, uint256[] memory)\n            internal\n            view\n            returns (uint256) fn_,\n        uint256 length_\n    ) internal view returns (StackTop) {\n        (uint256 c_, uint256[] memory tail_) = stackTop_.list(length_);\n        (StackTop stackTopAfter_, uint256 b_) = tail_.asStackTop().pop();\n        uint256 a_ = stackTopAfter_.peek();\n        stackTopAfter_.down().set(fn_(a_, b_, c_, tail_));\n        return stackTopAfter_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param length_ The length of the arrays to pass to fn_ from the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256, uint256[] memory, uint256[] memory)\n            internal\n            view\n            returns (uint256[] memory) fn_,\n        uint256 length_\n    ) internal view returns (StackTop) {\n        StackTop csStart_ = stackTop_.down(length_);\n        uint256[] memory cs_ = LibUint256Array.copyToNewUint256Array(\n            StackTop.unwrap(csStart_),\n            length_\n        );\n        (uint256 a_, uint256[] memory bs_) = csStart_.list(length_);\n\n        uint256[] memory results_ = fn_(a_, bs_, cs_);\n        require(results_.length == length_, \"BAD_RESULT_LENGTH\");\n        StackTop bottom_ = bs_.asStackTop();\n        LibUint256Array.unsafeCopyValuesTo(results_, StackTop.unwrap(bottom_));\n        return bottom_.up(length_);\n    }\n\n    /// Returns `length_` values from the stack as an array without allocating\n    /// new memory. As arrays always start with their length, this requires\n    /// writing the length value to the stack below the array values. The value\n    /// that is overwritten in the process is also returned so that data is not\n    /// lost. For example, imagine a stack `[ A B C D ]` and we list 2 values.\n    /// This will write the stack to look like `[ A 2 C D ]` and return both `B`\n    /// and a pointer to `2` represented as a `uint256[]`.\n    /// The returned array is ONLY valid for as long as the stack DOES NOT move\n    /// back into its memory. As soon as the stack moves up again and writes into\n    /// the array it will be corrupt. The caller MUST ensure that it does not\n    /// read from the returned array after it has been corrupted by subsequent\n    /// stack writes.\n    /// @param stackTop_ The stack top to read the values below into an array.\n    /// @param length_ The number of values to include in the returned array.\n    /// @return head_ The value that was overwritten with the length.\n    /// @return tail_ The array constructed from the stack memory.\n    function list(\n        StackTop stackTop_,\n        uint256 length_\n    ) internal pure returns (uint256 head_, uint256[] memory tail_) {\n        assembly (\"memory-safe\") {\n            tail_ := sub(stackTop_, add(0x20, mul(length_, 0x20)))\n            head_ := mload(tail_)\n            mstore(tail_, length_)\n        }\n    }\n\n    /// Cast a `uint256[]` array to a stack top. The stack top will point to the\n    /// length of the array, NOT its first value.\n    /// @param array_ The array to cast to a stack top.\n    /// @return stackTop_ The stack top that points to the length of the array.\n    function asStackTop(\n        uint256[] memory array_\n    ) internal pure returns (StackTop stackTop_) {\n        assembly (\"memory-safe\") {\n            stackTop_ := array_\n        }\n    }\n\n    /// Cast a stack top to an array. The value immediately above the stack top\n    /// will be treated as the length of the array, so the proceeding length\n    /// values will be the items of the array. The caller MUST ensure the values\n    /// above the stack top constitute a valid array. The retured array will be\n    /// corrupt if/when the stack subsequently moves into it and writes to those\n    /// memory locations. The caller MUST ensure that it does NOT read from the\n    /// returned array after the stack writes over it.\n    /// @param stackTop_ The stack top that will be cast to an array.\n    /// @return array_ The array above the stack top.\n    function asUint256Array(\n        StackTop stackTop_\n    ) internal pure returns (uint256[] memory array_) {\n        assembly (\"memory-safe\") {\n            array_ := stackTop_\n        }\n    }\n\n    /// Cast a stack top to bytes. The value immediately above the stack top will\n    /// be treated as the length of the `bytes`, so the proceeding length bytes\n    /// will be the data of the `bytes`. The caller MUST ensure the length and\n    /// bytes above the stack top constitute valid `bytes` data. The returned\n    /// `bytes` will be corrupt if/when the stack subsequently moves into it and\n    /// writes to those memory locations. The caller MUST ensure that it does\n    /// NOT read from the returned bytes after the stack writes over it.\n    /// @param stackTop_ The stack top that will be cast to bytes.\n    /// @return bytes_ The bytes above the stack top.\n    function asBytes(\n        StackTop stackTop_\n    ) internal pure returns (bytes memory bytes_) {\n        assembly (\"memory-safe\") {\n            bytes_ := stackTop_\n        }\n    }\n\n    /// Cast a `uint256[]` array to a stack top after its length. The stack top\n    /// will point to the first item of the array, NOT its length.\n    /// @param array_ The array to cast to a stack top.\n    /// @return stackTop_ The stack top that points to the first item of the array.\n    function asStackTopUp(\n        uint256[] memory array_\n    ) internal pure returns (StackTop stackTop_) {\n        assembly (\"memory-safe\") {\n            stackTop_ := add(array_, 0x20)\n        }\n    }\n\n    function asStackTopAfter(\n        uint256[] memory array_\n    ) internal pure returns (StackTop stackTop_) {\n        assembly (\"memory-safe\") {\n            stackTop_ := add(array_, add(0x20, mul(mload(array_), 0x20)))\n        }\n    }\n\n    /// Cast `bytes` to a stack top. The stack top will point to the length of\n    /// the `bytes`, NOT the first byte.\n    /// @param bytes_ The `bytes` to cast to a stack top.\n    /// @return stackTop_ The stack top that points to the length of the bytes.\n    function asStackTop(\n        bytes memory bytes_\n    ) internal pure returns (StackTop stackTop_) {\n        assembly (\"memory-safe\") {\n            stackTop_ := bytes_\n        }\n    }\n\n    /// Returns the stack top 32 bytes above/past the passed stack top.\n    /// @param stackTop_ The stack top at the starting position.\n    /// @return The stack top 32 bytes above the passed stack top.\n    function up(StackTop stackTop_) internal pure returns (StackTop) {\n        unchecked {\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + 0x20);\n        }\n    }\n\n    /// Returns the stack top `n_ * 32` bytes above/past the passed stack top.\n    /// @param stackTop_ The stack top at the starting position.\n    /// @param n_ The multiplier on the stack movement. MAY be zero.\n    /// @return The stack top `n_ * 32` bytes above/past the passed stack top.\n    function up(\n        StackTop stackTop_,\n        uint256 n_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + 0x20 * n_);\n        }\n    }\n\n    /// Returns the stack top `n_` bytes above/past the passed stack top.\n    /// The returned stack top MAY NOT be aligned with the passed stack top for\n    /// subsequent 32 byte reads and writes. The caller MUST ensure that it is\n    /// safe to read and write data relative to the returned stack top.\n    /// @param stackTop_ The stack top at the starting position.\n    /// @param n_ The number of bytes to move.\n    /// @return The stack top `n_` bytes above/past the passed stack top.\n    function upBytes(\n        StackTop stackTop_,\n        uint256 n_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + n_);\n        }\n    }\n\n    /// Returns the stack top 32 bytes below/before the passed stack top.\n    /// @param stackTop_ The stack top at the starting position.\n    /// @return The stack top 32 bytes below/before the passed stack top.\n    function down(StackTop stackTop_) internal pure returns (StackTop) {\n        unchecked {\n            return StackTop.wrap(StackTop.unwrap(stackTop_) - 0x20);\n        }\n    }\n\n    /// Returns the stack top `n_ * 32` bytes below/before the passed stack top.\n    /// @param stackTop_ The stack top at the starting position.\n    /// @param n_ The multiplier on the movement.\n    /// @return The stack top `n_ * 32` bytes below/before the passed stack top.\n    function down(\n        StackTop stackTop_,\n        uint256 n_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            return StackTop.wrap(StackTop.unwrap(stackTop_) - 0x20 * n_);\n        }\n    }\n\n    /// Convert two stack top values to a single stack index. A stack index is\n    /// the distance in 32 byte increments between two stack positions. The\n    /// calculations assumes the two stack positions are aligned. The caller MUST\n    /// ensure the alignment of both values. The calculation is unchecked and MAY\n    /// underflow. The caller MUST ensure that the stack top is always above the\n    /// stack bottom.\n    /// @param stackBottom_ The lower of the two values.\n    /// @param stackTop_ The higher of the two values.\n    /// @return The stack index as 32 byte distance between the two stack\n    /// positions.\n    function toIndex(\n        StackTop stackBottom_,\n        StackTop stackTop_\n    ) internal pure returns (uint256) {\n        unchecked {\n            return\n                (StackTop.unwrap(stackTop_) - StackTop.unwrap(stackBottom_)) /\n                0x20;\n        }\n    }\n}\n"
    },
    "contracts/interpreter/run/RainInterpreter.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"../../math/SaturatingMath.sol\";\nimport \"../../type/LibCast.sol\";\nimport \"./LibStackTop.sol\";\nimport \"./LibInterpreterState.sol\";\nimport \"../../array/LibUint256Array.sol\";\nimport \"../../sstore2/SSTORE2.sol\";\nimport \"../deploy/IRainInterpreterIntegrity.sol\";\nimport {SafeCastUpgradeable as SafeCast} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\ntype Operand is uint256;\n\n/// @title RainInterpreter\n/// @notice Interpreter for implementing and executing custom contract DSLs.\n/// Libraries and contracts map opcodes to `view` functionality then\n/// `RainInterpreter` runs Rain expressions using these opcodes. Rain expressions\n/// dispatch as pairs of bytes. The first byte is an opcode to run and the\n/// second byte is a value the opcode can use contextually to inform how to run.\n/// Typically opcodes will read/write to the stack to produce some meaningful\n/// final state after all opcodes have been dispatched.\n///\n/// The only thing required to run a Rain expression is a `State` struct to pass\n/// to `eval`, and the index of the source to run. Additional context can\n/// optionally be provided to be used by opcodes. For example, an `ITierV2`\n/// contract can take the input of `report`, abi encode it as context, then\n/// expose a local opcode that copies this account to the stack. The state will\n/// be mutated by reference rather than returned by `eval`, this is to make it\n/// very clear to implementers that the inline mutation is occurring.\n///\n/// Rain expressions run \"top to bottom\", i.e. \"left to right\".\n/// See the tests for examples on how to construct Rain expression in JavaScript\n/// then pass to `ImmutableSource` contracts deployed by a factory that then\n/// run `eval` to produce a final value.\n///\n/// There are only 4 \"core\" opcodes for `RainInterpreter`:\n/// - `0`: Copy value from either `constants` at index `operand` to the top of\n///   the stack.\n/// - `1`: Duplicates the value at stack index `operand_` to the top of the\n///   stack.\n/// - `2`: Zipmap takes N values from the stack, interprets each as an array of\n///   configurable length, then zips them into `arguments` and maps a source\n///   from `sources` over these. See `zipmap` for more details.\n/// - `3`: Debug prints the state to the console log as per hardhat.\n///\n/// To do anything useful the contract that inherits `RainInterpreter` needs to provide\n/// opcodes to build up an internal DSL. This may sound complex but it only\n/// requires mapping opcode integers to functions to call, and reading/writing\n/// values to the stack as input/output for these functions. Further, opcode\n/// packs are provided in rain that any inheriting contract can use as a normal\n/// solidity library. See `MathOps.sol` opcode pack and the\n/// `CalculatorTest.sol` test contract for an example of how to dispatch\n/// opcodes and handle the results in a wrapping contract.\n///\n/// RainInterpreter natively has no concept of branching logic such as `if` or loops.\n/// An opcode pack could implement these similar to the core zipmap by lazily\n/// evaluating a source from `sources` based on some condition, etc. Instead\n/// some simpler, eagerly evaluated selection tools such as `min` and `max` in\n/// the `MathOps` opcode pack are provided. Future versions of `RainInterpreter` MAY\n/// implement lazy `if` and other similar patterns.\n///\n/// The `eval` function is `view` because Rain expressions are expected to\n/// compute results only without modifying any state. The contract wrapping the\n/// Interpreter is free to mutate as usual. This model encourages exposing only\n/// read-only functionality to end-user deployers who provide expressions to an\n/// interpreter factory. Removing all writes removes a lot of potential\n/// foot-guns for expression authors and allows contract authors to reason more\n/// clearly about the input/output of the wrapping solidity code.\n///\n/// Internally `RainInterpreter` makes heavy use of unchecked math and assembly\n/// logic as the opcode dispatch logic runs on a tight loop and so gas costs can\n/// ramp up very quickly.\nabstract contract RainInterpreter {\n    using Math for uint256;\n    using SaturatingMath for uint256;\n    using LibCast for uint256;\n    using LibInterpreterState for InterpreterState;\n    using LibStackTop for uint256[];\n    using LibStackTop for bytes;\n    using LibStackTop for StackTop;\n    using LibCast for function(InterpreterState memory, SourceIndex, StackTop)\n        internal\n        view\n        returns (StackTop);\n    using LibCast for function(InterpreterState memory, Operand, StackTop)\n        internal\n        view\n        returns (StackTop)[];\n    using LibConvert for uint256[];\n    using LibInterpreterState for StateConfig;\n\n    /// Expose all the function pointers for every opcode as 2-byte pointers in\n    /// a bytes list. The implementing Interpreter MUST ensure each pointer is\n    /// to a `function(uint256,uint256) view returns (uint256)` function as this\n    /// is the ONLY supported signature for opcodes. Pointers for the core\n    /// opcodes must be provided in the packed pointers list but will be ignored\n    /// at runtime.\n    function opcodeFunctionPointers()\n        internal\n        view\n        virtual\n        returns (\n            function(InterpreterState memory, Operand, StackTop)\n                internal\n                view\n                returns (StackTop)[]\n                memory\n        );\n\n    /// Builds a new `State` bytes from `StateConfig`.\n    /// Empty stack and arguments with stack index 0.\n    /// @param config_ State config to build the new `State`.\n    function buildStateBytes(\n        IRainInterpreterIntegrity interpreterIntegrity_,\n        StateConfig memory config_,\n        uint[] memory minStackOutputs_\n    ) internal view returns (bytes memory) {\n        unchecked {\n            (, uint256 stackLength_) = interpreterIntegrity_.ensureIntegrity(\n                config_.sources,\n                config_.constants.length,\n                minStackOutputs_\n            );\n\n            return\n                config_.serialize(\n                    stackLength_,\n                    opcodeFunctionPointers()\n                        .asUint256Array()\n                        .unsafeTo16BitBytes()\n                );\n        }\n    }\n}\n"
    },
    "contracts/interpreter/shared/RainterpreterExpressionDeployer.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../deploy/IExpressionDeployerV1.sol\";\nimport \"../deploy/StandardIntegrity.sol\";\nimport \"../ops/core/OpGet.sol\";\n\nbytes constant OPCODE_FUNCTION_POINTERS = hex\"0b0a0b180b6e0bc00c3e0c6a0d030dcd0e020e200ea80eb70ec50ed30ee10eb70eef0efd0f0b0f1a0f290f370f450f530f610fd90fe80ff7100610151024106d107f108d10bf10cd10db10e910f811071116112511341143115211611170117f118e119c11aa11b811c611d411e211f11200120e12850a70\";\nbytes32 constant OPCODE_FUNCTION_POINTERS_HASH = keccak256(\n    OPCODE_FUNCTION_POINTERS\n);\nbytes32 constant INTERPRETER_BYTECODE_HASH = bytes32(\n    0xb46907eb1fb4298a2ad59fd8ffd75a8ecbd9f226bea5e448988d0307f89d1a69\n);\n\ncontract RainterpreterExpressionDeployer is\n    StandardIntegrity,\n    IExpressionDeployerV1\n{\n    using LibInterpreterState for StateConfig;\n\n    event ValidInterpreter(address sender, address interpreter);\n    event DeployExpression(\n        address sender,\n        StateConfig config,\n        address expressionAddress,\n        uint256 contextReads\n    );\n\n    /// THIS IS NOT A SECURITY CHECK. IT IS AN INTEGRITY CHECK TO PREVENT HONEST\n    /// MISTAKES. IT CANNOT PREVENT EITHER A MALICIOUS INTERPRETER OR DEPLOYER\n    /// FROM BEING EXECUTED.\n    constructor(address interpreter_) {\n        // Guard against serializing incorrect function pointers, which would\n        // cause undefined runtime behaviour for corrupted opcodes.\n        bytes memory functionPointers_ = IInterpreterV1(interpreter_)\n            .functionPointers();\n        if (keccak256(functionPointers_) != OPCODE_FUNCTION_POINTERS_HASH) {\n            console.logBytes(functionPointers_);\n            revert(\"BAD_POINTERS\");\n        }\n\n        // Guard against an interpreter with unknown/untrusted bytecode that\n        // could run arbitrary logic even if the function pointers are identical\n        // to the known/trusted interpreter.\n        bytes32 interpreterHash_;\n        assembly (\"memory-safe\") {\n            interpreterHash_ := extcodehash(interpreter_)\n        }\n        if (interpreterHash_ != INTERPRETER_BYTECODE_HASH) {\n            console.logBytes(abi.encodePacked(interpreterHash_));\n            revert(\"BAD_INTERPRETER_HASH\");\n        }\n\n        emit ValidInterpreter(msg.sender, interpreter_);\n    }\n\n    function localIntegrityFunctionPointers()\n        internal\n        pure\n        virtual\n        override\n        returns (\n            function(IntegrityState memory, Operand, StackTop)\n                view\n                returns (StackTop)[]\n                memory\n        )\n    {\n        function(IntegrityState memory, Operand, StackTop)\n            view\n            returns (StackTop)[]\n            memory localFnPtrs_ = new function(\n                IntegrityState memory,\n                Operand,\n                StackTop\n            ) view returns (StackTop)[](1);\n        localFnPtrs_[0] = OpGet.integrity;\n        return localFnPtrs_;\n    }\n\n    function deployExpression(\n        StateConfig memory config_,\n        uint[] memory minStackOutputs_\n    ) external returns (address, uint256) {\n        (uint256 contextReads_, uint256 stackLength_) = ensureIntegrity(\n            config_.sources,\n            config_.constants.length,\n            minStackOutputs_\n        );\n\n        bytes memory stateBytes_ = config_.serialize(\n            stackLength_,\n            OPCODE_FUNCTION_POINTERS\n        );\n\n        address expressionAddress_ = SSTORE2.write(stateBytes_);\n\n        emit DeployExpression(\n            msg.sender,\n            config_,\n            expressionAddress_,\n            contextReads_\n        );\n        return (expressionAddress_, contextReads_);\n    }\n}\n"
    },
    "contracts/kv/LibMemoryKV.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../math/Binary.sol\";\n\ntype MemoryKV is uint;\ntype MemoryKVKey is uint;\ntype MemoryKVPtr is uint;\ntype MemoryKVVal is uint;\n\nlibrary LibMemoryKV {\n    function readPtrVal(MemoryKVPtr ptr_) internal pure returns (MemoryKVVal) {\n        // This is ALWAYS a bug. It means the caller did not check if the ptr is\n        // nonzero before trying to read from it.\n        require(MemoryKVPtr.unwrap(ptr_) > 0, \"INVALID_PTR\");\n        MemoryKVVal v_;\n        assembly (\"memory-safe\") {\n            v_ := mload(add(ptr_, 0x20))\n        }\n        return v_;\n    }\n\n    function getPtr(\n        MemoryKV kv_,\n        MemoryKVKey k_\n    ) internal pure returns (MemoryKVPtr) {\n        uint mask_ = MASK_16BIT;\n        MemoryKVPtr ptr_;\n        assembly (\"memory-safe\") {\n            // loop until k found or give up if ptr is zero\n            for {\n                ptr_ := and(kv_, mask_)\n            } iszero(iszero(ptr_)) {\n                ptr_ := mload(add(ptr_, 0x40))\n            } {\n                if eq(k_, mload(ptr_)) {\n                    break\n                }\n            }\n        }\n        return ptr_;\n    }\n\n    function setVal(\n        MemoryKV kv_,\n        MemoryKVKey k_,\n        MemoryKVVal v_\n    ) internal pure returns (MemoryKV) {\n        MemoryKVPtr ptr_ = getPtr(kv_, k_);\n        uint mask_ = MASK_16BIT;\n        // update\n        if (MemoryKVPtr.unwrap(ptr_) > 0) {\n            assembly (\"memory-safe\") {\n                mstore(add(ptr_, 0x20), v_)\n            }\n        }\n        // insert\n        else {\n            assembly (\"memory-safe\") {\n                // allocate new memory\n                ptr_ := mload(0x40)\n                mstore(0x40, add(ptr_, 0x60))\n                // set k/v/ptr\n                mstore(ptr_, k_)\n                mstore(add(ptr_, 0x20), v_)\n                mstore(add(ptr_, 0x40), and(kv_, mask_))\n                // kv must point to new insertion and update array len\n                kv_ := or(\n                    // inc len by 2\n                    shl(16, add(shr(16, kv_), 2)),\n                    // set ptr\n                    ptr_\n                )\n            }\n        }\n        return kv_;\n    }\n\n    function toUint256Array(\n        MemoryKV kv_\n    ) internal pure returns (uint[] memory) {\n        unchecked {\n            uint ptr_ = MemoryKV.unwrap(kv_) & MASK_16BIT;\n            uint length_ = MemoryKV.unwrap(kv_) >> 16;\n            uint[] memory arr_ = new uint[](length_);\n            assembly (\"memory-safe\") {\n                for {\n                    let cursor_ := add(arr_, 0x20)\n                    let end_ := add(cursor_, mul(mload(arr_), 0x20))\n                } lt(cursor_, end_) {\n                    cursor_ := add(cursor_, 0x20)\n                    ptr_ := mload(add(ptr_, 0x40))\n                } {\n                    // key\n                    mstore(cursor_, mload(ptr_))\n                    cursor_ := add(cursor_, 0x20)\n                    // value\n                    mstore(cursor_, mload(add(ptr_, 0x20)))\n                }\n            }\n            return arr_;\n        }\n    }\n}\n"
    },
    "contracts/math/Binary.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\n/// @dev Binary 1.\nuint constant B_1 = 2 ** 1 - 1;\n/// @dev Binary 11.\nuint constant B_11 = 2 ** 2 - 1;\n/// @dev Binary 111.\nuint constant B_111 = 2 ** 3 - 1;\n/// @dev Binary 1111.\nuint constant B_1111 = 2 ** 4 - 1;\n/// @dev Binary 11111.\nuint constant B_11111 = 2 ** 5 - 1;\n/// @dev Binary 111111.\nuint constant B_111111 = 2 ** 6 - 1;\n/// @dev Binary 1111111.\nuint constant B_1111111 = 2 ** 7 - 1;\n/// @dev Binary 11111111.\nuint constant B_11111111 = 2 ** 8 - 1;\n/// @dev Binary 111111111.\nuint constant B_111111111 = 2 ** 9 - 1;\n/// @dev Binary 1111111111.\nuint constant B_1111111111 = 2 ** 10 - 1;\n/// @dev Binary 11111111111.\nuint constant B_11111111111 = 2 ** 11 - 1;\n/// @dev Binary 111111111111.\nuint constant B_111111111111 = 2 ** 12 - 1;\n/// @dev Binary 1111111111111.\nuint constant B_1111111111111 = 2 ** 13 - 1;\n/// @dev Binary 11111111111111.\nuint constant B_11111111111111 = 2 ** 14 - 1;\n/// @dev Binary 111111111111111.\nuint constant B_111111111111111 = 2 ** 15 - 1;\n/// @dev Binary 1111111111111111.\nuint constant B_1111111111111111 = 2 ** 16 - 1;\n\n/// @dev Bitmask for 1 bit.\nuint constant MASK_1BIT = B_1;\n/// @dev Bitmask for 2 bits.\nuint constant MASK_2BIT = B_11;\n/// @dev Bitmask for 3 bits.\nuint constant MASK_3BIT = B_111;\n/// @dev Bitmask for 4 bits.\nuint constant MASK_4BIT = B_1111;\n/// @dev Bitmask for 5 bits.\nuint constant MASK_5BIT = B_11111;\n/// @dev Bitmask for 6 bits.\nuint constant MASK_6BIT = B_111111;\n/// @dev Bitmask for 7 bits.\nuint constant MASK_7BIT = B_1111111;\n/// @dev Bitmask for 8 bits.\nuint constant MASK_8BIT = B_11111111;\n/// @dev Bitmask for 9 bits.\nuint constant MASK_9BIT = B_111111111;\n/// @dev Bitmask for 10 bits.\nuint constant MASK_10BIT = B_1111111111;\n/// @dev Bitmask for 11 bits.\nuint constant MASK_11BIT = B_11111111111;\n/// @dev Bitmask for 12 bits.\nuint constant MASK_12BIT = B_111111111111;\n/// @dev Bitmask for 13 bits.\nuint constant MASK_13BIT = B_1111111111111;\n/// @dev Bitmask for 14 bits.\nuint constant MASK_14BIT = B_11111111111111;\n/// @dev Bitmask for 15 bits.\nuint constant MASK_15BIT = B_111111111111111;\n/// @dev Bitmask for 16 bits.\nuint constant MASK_16BIT = B_1111111111111111;\n"
    },
    "contracts/math/FixedPointMath.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\n/// @dev The scale of all fixed point math. This is adopting the conventions of\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\nuint256 constant FP_DECIMALS = 18;\n/// @dev The number `1` in the standard fixed point math scaling. Most of the\n/// differences between fixed point math and regular math is multiplying or\n/// dividing by `ONE` after the appropriate scaling has been applied.\nuint256 constant FP_ONE = 1e18;\n\n/// @title FixedPointMath\n/// @notice Sometimes we want to do math with decimal values but all we have\n/// are integers, typically uint256 integers. Floats are very complex so we\n/// don't attempt to simulate them. Instead we provide a standard definition of\n/// \"one\" as 10 ** 18 and scale everything up/down to this as fixed point math.\n/// Overflows are errors as per Solidity.\n///\n/// Note that scaling down ANY fixed point decimal also reduces the precision\n/// which lead to dust or in the worst case trapped funds if subsequent\n/// subtraction overflows a rounded-down number. Consider using saturating\n/// subtraction for safety against previously downscaled values, and whether\n/// trapped dust is a significant issue. If you need to retain full/arbitrary\n/// precision in the case of downscaling DO NOT use this library.\nlibrary FixedPointMath {\n    using Math for uint256;\n\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\n    /// @param a_ Some fixed point decimal value.\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\n    /// @return `a_` scaled to match `DECIMALS`.\n    function scale18(\n        uint256 a_,\n        uint256 aDecimals_\n    ) internal pure returns (uint256) {\n        uint256 decimals_;\n        if (FP_DECIMALS == aDecimals_) {\n            return a_;\n        } else if (FP_DECIMALS > aDecimals_) {\n            unchecked {\n                decimals_ = FP_DECIMALS - aDecimals_;\n            }\n            return a_ * 10 ** decimals_;\n        } else {\n            unchecked {\n                decimals_ = aDecimals_ - FP_DECIMALS;\n            }\n            return a_ / 10 ** decimals_;\n        }\n    }\n\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\n    /// @param a_ A `DECIMALS` fixed point decimals.\n    /// @param targetDecimals_ The new scale of `a_`.\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\n    function scaleN(\n        uint256 a_,\n        uint256 targetDecimals_\n    ) internal pure returns (uint256) {\n        uint256 decimals_;\n        if (targetDecimals_ == FP_DECIMALS) {\n            return a_;\n        } else if (FP_DECIMALS > targetDecimals_) {\n            unchecked {\n                decimals_ = FP_DECIMALS - targetDecimals_;\n            }\n            return a_ / 10 ** decimals_;\n        } else {\n            unchecked {\n                decimals_ = targetDecimals_ - FP_DECIMALS;\n            }\n            return a_ * 10 ** decimals_;\n        }\n    }\n\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\n    /// The caller MUST ensure the end result matches `DECIMALS` if other\n    /// functions in this library are to work correctly.\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\n    /// is supported.\n    /// @param a_ Some integer of any scale.\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\n    /// @return `a_` rescaled according to `scaleBy_`.\n    function scaleBy(\n        uint256 a_,\n        int8 scaleBy_\n    ) internal pure returns (uint256) {\n        if (scaleBy_ == 0) {\n            return a_;\n        } else if (scaleBy_ > 0) {\n            return a_ * 10 ** uint8(scaleBy_);\n        } else {\n            uint256 posScaleDownBy_;\n            unchecked {\n                posScaleDownBy_ = uint8(-1 * scaleBy_);\n            }\n            return a_ / 10 ** posScaleDownBy_;\n        }\n    }\n\n    /// Fixed point multiplication in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointMul(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        return a_.mulDiv(b_, FP_ONE);\n    }\n\n    /// Fixed point division in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointDiv(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        return a_.mulDiv(FP_ONE, b_);\n    }\n}\n"
    },
    "contracts/math/SaturatingMath.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title SaturatingMath\n/// @notice Sometimes we neither want math operations to error nor wrap around\n/// on an overflow or underflow. In the case of transferring assets an error\n/// may cause assets to be locked in an irretrievable state within the erroring\n/// contract, e.g. due to a tiny rounding/calculation error. We also can't have\n/// assets underflowing and attempting to approve/transfer \"infinity\" when we\n/// wanted \"almost or exactly zero\" but some calculation bug underflowed zero.\n/// Ideally there are no calculation mistakes, but in guarding against bugs it\n/// may be safer pragmatically to saturate arithmatic at the numeric bounds.\n/// Note that saturating div is not supported because 0/0 is undefined.\nlibrary SaturatingMath {\n    /// Saturating addition.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ + b_ and max uint256.\n    function saturatingAdd(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 c_ = a_ + b_;\n            return c_ < a_ ? type(uint256).max : c_;\n        }\n    }\n\n    /// Saturating subtraction.\n    /// @param a_ Minuend.\n    /// @param b_ Subtrahend.\n    /// @return Maximum of a_ - b_ and 0.\n    function saturatingSub(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        unchecked {\n            return a_ > b_ ? a_ - b_ : 0;\n        }\n    }\n\n    /// Saturating multiplication.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ * b_ and max uint256.\n    function saturatingMul(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being\n            // zero, but the benefit is lost if 'b' is also tested.\n            // https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a_ == 0) return 0;\n            uint256 c_ = a_ * b_;\n            return c_ / a_ != b_ ? type(uint256).max : c_;\n        }\n    }\n}\n"
    },
    "contracts/memory/LibMemorySize.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\n/// @title LibMemorySize\n/// @notice Reports the size in bytes of type data that represents contigious\n/// regions of memory. Pointers to regions of memory that may not be congigious\n/// are not supported, e.g. fields on structs may point to dynamic data that is\n/// separate to the struct. Length slots for dynamic data are included in the\n/// size and the size is always measured in bytes.\nlibrary LibMemorySize {\n    /// Reports the size of a `uint256` in bytes. Is always 32.\n    /// @return 32.\n    function size(uint256) internal pure returns (uint256) {\n        return 0x20;\n    }\n\n    /// Reports the size of a `uint256[]` in bytes. Is the size of the length\n    /// slot (32 bytes) plus the length of the array multiplied by 32 bytes per\n    /// item.\n    /// @return The size of the array data including its length slot size.\n    function size(uint256[] memory array_) internal pure returns (uint256) {\n        unchecked {\n            return 0x20 + (array_.length * 0x20);\n        }\n    }\n\n    /// Reports the size of `bytes` data. Is the size of the length slot\n    /// (32 bytes) plus the number of bytes as per its length.\n    /// @return The size of the `bytes` data including its length slot size.\n    function size(bytes memory bytes_) internal pure returns (uint256) {\n        unchecked {\n            return 0x20 + bytes_.length;\n        }\n    }\n}\n"
    },
    "contracts/orderbook/IOrderBookV1.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../interpreter/deploy/IExpressionDeployerV1.sol\";\nimport \"../interpreter/run/IInterpreterV1.sol\";\n\nstruct DepositConfig {\n    address token;\n    uint256 vaultId;\n    uint256 amount;\n}\n\nstruct WithdrawConfig {\n    address token;\n    uint256 vaultId;\n    uint256 amount;\n}\n\nstruct IO {\n    address token;\n    uint256 vaultId;\n}\n\nstruct OrderConfig {\n    address expressionDeployer;\n    address interpreter;\n    StateConfig interpreterStateConfig;\n    IO[] validInputs;\n    IO[] validOutputs;\n}\n\nstruct Order {\n    address owner;\n    address interpreter;\n    EncodedDispatch dispatch;\n    EncodedDispatch handleIODispatch;\n    IO[] validInputs;\n    IO[] validOutputs;\n}\n\nstruct TakeOrdersConfig {\n    /// Output token from the perspective of the order taker.\n    address output;\n    /// Input token from the perspective of the order taker.\n    address input;\n    /// Minimum input from the perspective of the order taker.\n    uint256 minimumInput;\n    /// Maximum input from the perspective of the order taker.\n    uint256 maximumInput;\n    /// Maximum IO ratio as calculated by the order being taken. The input is\n    /// from the perspective of the order so higher ratio means worse deal for\n    /// the order taker.\n    uint256 maximumIORatio;\n    /// Ordered list of orders that will be taken until the limit is hit. Takers\n    /// are expected to prioritise orders that appear to be offering better deals\n    /// i.e. lower IO ratios. This prioritisation and sorting MUST happen\n    /// offchain, e.g. via. some simulator.\n    TakeOrderConfig[] orders;\n}\n\nstruct TakeOrderConfig {\n    Order order;\n    uint256 inputIOIndex;\n    uint256 outputIOIndex;\n}\n\nstruct ClearConfig {\n    uint256 aInputIOIndex;\n    uint256 aOutputIOIndex;\n    uint256 bInputIOIndex;\n    uint256 bOutputIOIndex;\n    uint256 aBountyVaultId;\n    uint256 bBountyVaultId;\n}\n\ninterface IOrderBookV1 {\n    /// depositor => token => vault id => token amount.\n    function vaultBalance(\n        address owner,\n        address token,\n        uint id\n    ) external view returns (uint balance);\n\n    function deposit(DepositConfig calldata config) external;\n\n    function withdraw(WithdrawConfig calldata config) external;\n\n    function addOrder(OrderConfig calldata config) external;\n\n    function removeOrder(Order calldata order) external;\n\n    function takeOrders(\n        TakeOrdersConfig calldata takeOrders\n    ) external returns (uint256 totalInput, uint256 totalOutput);\n\n    function clear(\n        Order memory a,\n        Order memory b,\n        ClearConfig calldata clearConfig\n    ) external;\n}\n"
    },
    "contracts/sale/ISaleV2.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// An `ISale` can be in one of 4 possible states and a linear progression is\n/// expected from an \"in flight\" status to an immutable definitive outcome.\n/// - Pending: The sale is deployed onchain but cannot be interacted with yet.\n/// - Active: The sale can now be bought into and otherwise interacted with.\n/// - Success: The sale has ended AND reached its minimum raise target.\n/// - Fail: The sale has ended BUT NOT reached its minimum raise target.\n/// Once an `ISale` reaches `Active` it MUST NOT return `Pending` ever again.\n/// Once an `ISale` reaches `Success` or `Fail` it MUST NOT return any other\n/// status ever again.\nenum SaleStatus {\n    Pending,\n    Active,\n    Success,\n    Fail\n}\n\ninterface ISaleV2 {\n    /// Returns the address of the token being sold in the sale.\n    /// MUST NOT change during the lifecycle of the sale contract.\n    function token() external view returns (address);\n\n    function remainingTokenInventory() external view returns (uint256);\n\n    /// Returns the address of the token that sale prices are denominated in.\n    /// MUST NOT change during the lifecycle of the sale contract.\n    function reserve() external view returns (address);\n\n    /// total reserve taken in to the sale contract via. buys. Does NOT\n    /// include any reserve sent directly to the sale contract outside the\n    /// standard buy/refund loop, e.g. due to a dusting attack.\n    function totalReserveReceived() external view returns (uint256);\n\n    /// Returns the current `SaleStatus` of the sale.\n    /// Represents a linear progression of the sale through its major lifecycle\n    /// events.\n    function saleStatus() external view returns (SaleStatus);\n}\n"
    },
    "contracts/sstore2/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"./utils/Bytecode.sol\";\n\n/**\n  @title A key-value storage with auto-generated keys for storing chunks of\n  data with a lower write & read cost.\n  @author Agustin Aguilar <aa@horizon.io>\n\n  Readme: https://github.com/0xsequence/sstore2#readme\n*/\nlibrary SSTORE2 {\n    error WriteError();\n\n    /**\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\n    @dev The pointer is a contract address with `_data` as code\n    @param _data to be written\n    @return pointer Pointer to the written `_data`\n  */\n    function write(bytes memory _data) internal returns (address pointer) {\n        // Append 00 to _data so contract can't be called\n        // Build init code\n        bytes memory code = Bytecode.creationCodeFor(\n            abi.encodePacked(hex\"00\", _data)\n        );\n\n        // Deploy contract using create\n        assembly (\"memory-safe\") {\n            pointer := create(0, add(code, 32), mload(code))\n        }\n\n        // Address MUST be non-zero\n        if (pointer == address(0)) revert WriteError();\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @return data read from `_pointer` contract\n  */\n    function read(address _pointer) internal view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, 1, type(uint256).max);\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @return data read from `_pointer` contract\n  */\n    function read(\n        address _pointer,\n        uint256 _start\n    ) internal view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @param _end index before which to end extraction\n    @return data read from `_pointer` contract\n  */\n    function read(\n        address _pointer,\n        uint256 _start,\n        uint256 _end\n    ) internal view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\n    }\n}\n"
    },
    "contracts/sstore2/utils/Bytecode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nlibrary Bytecode {\n    error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\n\n    /**\n    @notice Generate a creation code that results on a contract with `_code` as\n    bytecode\n    @param _code The returning value of the resulting `creationCode`\n    @return creationCode (constructor) for new contract\n  */\n    function creationCodeFor(\n        bytes memory _code\n    ) internal pure returns (bytes memory) {\n        /*\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\n      0x01    0x80         0x80        DUP1                size size\n      0x02    0x60         0x600e      PUSH1 14            14 size size\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\n      0x04    0x39         0x39        CODECOPY            size\n      0x05    0x60         0x6000      PUSH1 00            0 size\n      0x06    0xf3         0xf3        RETURN\n      <CODE>\n    */\n\n        return\n            abi.encodePacked(\n                hex\"63\",\n                uint32(_code.length),\n                hex\"80_60_0E_60_00_39_60_00_F3\",\n                _code\n            );\n    }\n\n    /**\n    @notice Returns the size of the code on a given address\n    @param _addr Address that may or may not contain code\n    @return size of the code on the given `_addr`\n  */\n    function codeSize(address _addr) internal view returns (uint256 size) {\n        assembly (\"memory-safe\") {\n            size := extcodesize(_addr)\n        }\n    }\n\n    /**\n    @notice Returns the code of a given address\n    @dev It will fail if `_end < _start`\n    @param _addr Address that may or may not contain code\n    @param _start number of bytes of code to skip on read\n    @param _end index before which to end extraction\n    @return oCode read from `_addr` deployed bytecode\n\n    Forked: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\n  */\n    function codeAt(\n        address _addr,\n        uint256 _start,\n        uint256 _end\n    ) internal view returns (bytes memory oCode) {\n        uint256 csize = codeSize(_addr);\n        if (csize == 0) return bytes(\"\");\n\n        if (_start > csize) return bytes(\"\");\n        if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end);\n\n        unchecked {\n            uint256 reqSize = _end - _start;\n            uint256 maxSize = csize - _start;\n\n            uint256 size = maxSize < reqSize ? maxSize : reqSize;\n\n            assembly (\"memory-safe\") {\n                // allocate output byte array - this could also be done without\n                // assembly\n                // by using o_code = new bytes(size)\n                oCode := mload(0x40)\n                // new \"memory end\" including padding\n                mstore(\n                    0x40,\n                    add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f)))\n                )\n                // store length in memory\n                mstore(oCode, size)\n                // actually retrieve the code, this needs assembly\n                extcodecopy(_addr, add(oCode, 0x20), _start, size)\n            }\n        }\n    }\n}\n"
    },
    "contracts/tier/ITierV2.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title ITierV2\n/// @notice `ITierV2` is a simple interface that contracts can implement to\n/// provide membership lists for other contracts.\n///\n/// There are many use-cases for a time-preserving conditional membership list.\n///\n/// Some examples include:\n///\n/// - Self-serve whitelist to participate in fundraising\n/// - Lists of users who can claim airdrops and perks\n/// - Pooling resources with implied governance/reward tiers\n/// - POAP style attendance proofs allowing access to future exclusive events\n///\n/// @dev Standard interface to a tiered membership.\n///\n/// A \"membership\" can represent many things:\n/// - Exclusive access.\n/// - Participation in some event or process.\n/// - KYC completion.\n/// - Combination of sub-memberships.\n/// - Etc.\n///\n/// The high level requirements for a contract implementing `ITierV2`:\n/// - MUST represent held tiers as a `uint`.\n/// - MUST implement `report`.\n///   - The report is a `uint256` that SHOULD represent the time each tier has\n///     been continuously held since encoded as `uint32`.\n///   - The encoded tiers start at `1`; Tier `0` is implied if no tier has ever\n///     been held.\n///   - Tier `0` is NOT encoded in the report, it is simply the fallback value.\n///   - If a tier is lost the time data is erased for that tier and will be\n///     set if/when the tier is regained to the new time.\n///   - If a tier is held but the historical time information is not available\n///     the report MAY return `0x00000000` for all held tiers.\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\n///   - Context can be a list of numbers that MAY pairwise define tiers such as\n///     minimum thresholds, or MAY simply provide global context such as a\n///     relevant NFT ID for example.\n/// - MUST implement `reportTimeForTier`\n///   - Functions exactly as `report` but only returns a single time for a\n///     single tier\n///   - MUST return the same time value `report` would for any given tier and\n///     context combination.\n///\n/// So the four possible states and report values are:\n/// - Tier is held and time is known: Timestamp is in the report\n/// - Tier is held but time is NOT known: `0` is in the report\n/// - Tier is NOT held: `0xFF..` is in the report\n/// - Tier is unknown: `0xFF..` is in the report\n///\n/// The reason `context` is specified as a list of values rather than arbitrary\n/// bytes is to allow clear and efficient compatibility with interpreter stacks.\n/// Some N values can be taken from an interpreter stack and used directly as a\n/// context, which would be difficult or impossible to ensure is safe for\n/// arbitrary bytes.\ninterface ITierV2 {\n    /// Same as report but only returns the time for a single tier.\n    /// Often the implementing contract can calculate a single tier more\n    /// efficiently than all 8 tiers. If the consumer only needs one or a few\n    /// tiers it MAY be much cheaper to request only those tiers individually.\n    /// This DOES NOT apply to all contracts, an obvious example is token\n    /// balance based tiers which always return `ALWAYS` or `NEVER` for all\n    /// tiers so no efficiency is gained.\n    /// The return value is a `uint256` for gas efficiency but the values will\n    /// be bounded by `type(uint32).max` as no single tier can report a value\n    /// higher than this.\n    function reportTimeForTier(\n        address account,\n        uint256 tier,\n        uint256[] calldata context\n    ) external view returns (uint256 time);\n\n    /// Returns an 8 tier encoded report of 32 bit timestamps for the given\n    /// account.\n    ///\n    /// Same as `ITier` (legacy interface) but with a list of values for\n    /// `context` which allows a single underlying state to present many\n    /// different reports dynamically.\n    ///\n    /// For example:\n    /// - Staking ledgers can calculate different tier thresholds\n    /// - NFTs can give different tiers based on different IDs\n    /// - Snapshot ERC20s can give different reports based on snapshot ID\n    ///\n    /// `context` supercedes `setTier` function and `TierChange` event from\n    /// `ITier` at the interface level.\n    function report(\n        address account,\n        uint256[] calldata context\n    ) external view returns (uint256 report);\n}\n"
    },
    "contracts/tier/libraries/TierConstants.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title TierConstants\n/// @notice Constants for use with tier logic.\nlibrary TierConstants {\n    /// NEVER is 0xFF.. as it is infinitely in the future.\n    /// NEVER for an entire report.\n    uint256 internal constant NEVER_REPORT = type(uint256).max;\n    /// NEVER for a single tier time.\n    uint32 internal constant NEVER_TIME = type(uint32).max;\n\n    /// Always is 0 as negative timestamps are not possible/supported onchain.\n    /// Tiers can't predate the chain but they can predate an `ITierV2`\n    /// contract.\n    uint256 internal constant ALWAYS = 0;\n\n    /// Account has never held a tier.\n    uint256 internal constant TIER_ZERO = 0;\n\n    /// Magic number for tier one.\n    uint256 internal constant TIER_ONE = 1;\n    /// Magic number for tier two.\n    uint256 internal constant TIER_TWO = 2;\n    /// Magic number for tier three.\n    uint256 internal constant TIER_THREE = 3;\n    /// Magic number for tier four.\n    uint256 internal constant TIER_FOUR = 4;\n    /// Magic number for tier five.\n    uint256 internal constant TIER_FIVE = 5;\n    /// Magic number for tier six.\n    uint256 internal constant TIER_SIX = 6;\n    /// Magic number for tier seven.\n    uint256 internal constant TIER_SEVEN = 7;\n    /// Magic number for tier eight.\n    uint256 internal constant TIER_EIGHT = 8;\n    /// Maximum tier is `TIER_EIGHT`.\n    uint256 internal constant MAX_TIER = TIER_EIGHT;\n}\n"
    },
    "contracts/tier/libraries/TierReport.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {ITierV2} from \"../ITierV2.sol\";\nimport \"./TierConstants.sol\";\n\n/// @title TierReport\n/// @notice `TierReport` implements several pure functions that can be\n/// used to interface with reports.\n/// - `tierAtTimeFromReport`: Returns the highest status achieved relative to\n/// a block timestamp and report. Statuses gained after that block are ignored.\n/// - `tierTime`: Returns the timestamp that a given tier has been held\n/// since according to a report.\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\n/// - `updateTimesForTierRange`: Updates a report with a timestamp for every\n///    tier in a range.\n/// - `updateReportWithTierAtTime`: Updates a report to a new tier.\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\n/// The low-level bit shifting can be difficult to get right so this\n/// factors that out.\nlibrary TierReport {\n    /// Enforce upper limit on tiers so we can do unchecked math.\n    /// @param tier_ The tier to enforce bounds on.\n    modifier maxTier(uint256 tier_) {\n        require(tier_ <= TierConstants.MAX_TIER, \"MAX_TIER\");\n        _;\n    }\n\n    /// Returns the highest tier achieved relative to a block timestamp\n    /// and report.\n    ///\n    /// Note that typically the report will be from the _current_ contract\n    /// state, i.e. `block.timestamp` but not always. Tiers gained after the\n    /// reference time are ignored.\n    ///\n    /// When the `report` comes from a later block than the `timestamp_` this\n    /// means the user must have held the tier continuously from `timestamp_`\n    /// _through_ to the report time.\n    /// I.e. NOT a snapshot.\n    ///\n    /// @param report_ A report as per `ITierV2`.\n    /// @param timestamp_ The timestamp to check the tiers against.\n    /// @return tier_ The highest tier held since `timestamp_` as per `report`.\n    function tierAtTimeFromReport(\n        uint256 report_,\n        uint256 timestamp_\n    ) internal pure returns (uint256 tier_) {\n        unchecked {\n            for (tier_ = 0; tier_ < 8; tier_++) {\n                if (uint32(uint256(report_ >> (tier_ * 32))) > timestamp_) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /// Returns the timestamp that a given tier has been held since from a\n    /// report.\n    ///\n    /// The report MUST encode \"never\" as 0xFFFFFFFF. This ensures\n    /// compatibility with `tierAtTimeFromReport`.\n    ///\n    /// @param report_ The report to read a timestamp from.\n    /// @param tier_ The Tier to read the timestamp for.\n    /// @return The timestamp the tier has been held since.\n    function reportTimeForTier(\n        uint256 report_,\n        uint256 tier_\n    ) internal pure maxTier(tier_) returns (uint256) {\n        unchecked {\n            // ZERO is a special case. Everyone has always been at least ZERO,\n            // since block 0.\n            if (tier_ == 0) {\n                return 0;\n            }\n\n            uint256 offset_ = (tier_ - 1) * 32;\n            return uint256(uint32(uint256(report_ >> offset_)));\n        }\n    }\n\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\n    ///\n    /// @param report_ Report to truncate with high bit 1s.\n    /// @param tier_ Tier to truncate above (exclusive).\n    /// @return Truncated report.\n    function truncateTiersAbove(\n        uint256 report_,\n        uint256 tier_\n    ) internal pure maxTier(tier_) returns (uint256) {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            uint256 mask_ = (TierConstants.NEVER_REPORT >> offset_) << offset_;\n            return report_ | mask_;\n        }\n    }\n\n    /// Updates a report with a timestamp for a given tier.\n    /// More gas efficient than `updateTimesForTierRange` if only a single\n    /// tier is being modified.\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\n    /// the time for tier `1`.\n    /// @param report_ Report to use as the baseline for the updated report.\n    /// @param tier_ The tier level to update.\n    /// @param timestamp_ The new block number for `tier_`.\n    /// @return The newly updated `report_`.\n    function updateTimeAtTier(\n        uint256 report_,\n        uint256 tier_,\n        uint256 timestamp_\n    ) internal pure maxTier(tier_) returns (uint256) {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            return\n                (report_ &\n                    ~uint256(uint256(TierConstants.NEVER_TIME) << offset_)) |\n                uint256(timestamp_ << offset_);\n        }\n    }\n\n    /// Updates a report with a block number for every tier in a range.\n    ///\n    /// Does nothing if the end status is equal or less than the start tier.\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier at the start of the range (exclusive).\n    /// @param endTier_ The tier at the end of the range (inclusive).\n    /// @param timestamp_ The timestamp to set for every tier in the range.\n    /// @return The updated report.\n    function updateTimesForTierRange(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) internal pure maxTier(endTier_) returns (uint256) {\n        unchecked {\n            uint256 offset_;\n            for (uint256 i_ = startTier_; i_ < endTier_; i_++) {\n                offset_ = i_ * 32;\n                report_ =\n                    (report_ &\n                        ~uint256(\n                            uint256(TierConstants.NEVER_TIME) << offset_\n                        )) |\n                    uint256(timestamp_ << offset_);\n            }\n            return report_;\n        }\n    }\n\n    /// Updates a report to a new status.\n    ///\n    /// Internally dispatches to `truncateTiersAbove` and\n    /// `updateBlocksForTierRange`.\n    /// The dispatch is based on whether the new tier is above or below the\n    /// current tier.\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\n    /// It is expected the caller will know the current tier when\n    /// calling this function and need to do other things in the calling scope\n    /// with it.\n    ///\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier to start updating relative to. Data above\n    /// this tier WILL BE LOST so probably should be the current tier.\n    /// @param endTier_ The new highest tier held, at the given timestamp_.\n    /// @param timestamp_ The timestamp_ to update the highest tier to, and\n    /// intermediate tiers from `startTier_`.\n    /// @return The updated report.\n    function updateReportWithTierAtTime(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) internal pure returns (uint256) {\n        return\n            endTier_ < startTier_\n                ? truncateTiersAbove(report_, endTier_)\n                : updateTimesForTierRange(\n                    report_,\n                    startTier_,\n                    endTier_,\n                    timestamp_\n                );\n    }\n}\n"
    },
    "contracts/tier/libraries/TierwiseCombine.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./TierReport.sol\";\nimport \"../../math/SaturatingMath.sol\";\n\nlibrary TierwiseCombine {\n    using Math for uint256;\n    using SaturatingMath for uint256;\n\n    /// Every lte check in `selectLte` must pass.\n    uint256 internal constant LOGIC_EVERY = 0;\n    /// Only one lte check in `selectLte` must pass.\n    uint256 internal constant LOGIC_ANY = 1;\n\n    /// Select the minimum block number from passing blocks in `selectLte`.\n    uint256 internal constant MODE_MIN = 0;\n    /// Select the maximum block number from passing blocks in `selectLte`.\n    uint256 internal constant MODE_MAX = 1;\n    /// Select the first block number that passes in `selectLte`.\n    uint256 internal constant MODE_FIRST = 2;\n\n    /// Performs a tierwise saturating subtraction of two reports.\n    /// Intepret as \"# of blocks older report was held before newer report\".\n    /// If older report is in fact newer then `0` will be returned.\n    /// i.e. the diff cannot be negative, older report as simply spent 0 blocks\n    /// existing before newer report, if it is in truth the newer report.\n    /// @param newerReport_ Block to subtract from.\n    /// @param olderReport_ Block to subtract.\n    function saturatingSub(\n        uint256 newerReport_,\n        uint256 olderReport_\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 ret_;\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\n                uint256 newerBlock_ = TierReport.reportTimeForTier(\n                    newerReport_,\n                    tier_\n                );\n                uint256 olderBlock_ = TierReport.reportTimeForTier(\n                    olderReport_,\n                    tier_\n                );\n                uint256 diff_ = newerBlock_.saturatingSub(olderBlock_);\n                ret_ = TierReport.updateTimeAtTier(ret_, tier_ - 1, diff_);\n            }\n            return ret_;\n        }\n    }\n\n    /// Given a list of reports, selects the best tier in a tierwise fashion.\n    /// The \"best\" criteria can be configured by `logic_` and `mode_`.\n    /// Logic can be \"every\" or \"any\", which means that the reports for a given\n    /// tier must either all or any be less than or equal to the reference\n    /// `blockNumber_`.\n    /// Mode can be \"min\", \"max\", \"first\" which selects between all the block\n    /// numbers for a given tier that meet the lte criteria.\n    /// IMPORTANT: If the output of `selectLte` is used to write to storage\n    /// care must be taken to ensure that \"upcoming\" tiers relative to the\n    /// `blockNumber_` are not overwritten inappropriately. Typically this\n    /// function should be used as a filter over reads only from an upstream\n    /// source of truth.\n    /// @param reports_ The list of reports to select over.\n    /// @param blockNumber_ The block number that tier blocks must be lte.\n    /// @param logic_ `LOGIC_EVERY` or `LOGIC_ANY`.\n    /// @param mode_ `MODE_MIN`, `MODE_MAX` or `MODE_FIRST`.\n    function selectLte(\n        uint256 logic_,\n        uint256 mode_,\n        uint256 blockNumber_,\n        uint256[] memory reports_\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 ret_;\n            uint256 block_;\n            bool anyLte_;\n            uint256 length_ = reports_.length;\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\n                uint256 accumulator_;\n                // Nothing lte the reference block for this tier yet.\n                anyLte_ = false;\n\n                // Initialize the accumulator for this tier.\n                if (mode_ == MODE_MIN) {\n                    accumulator_ = TierConstants.NEVER_REPORT;\n                } else {\n                    accumulator_ = 0;\n                }\n\n                // Filter all the blocks at the current tier from all the\n                // reports against the reference tier and each other.\n                for (uint256 i_ = 0; i_ < length_; i_++) {\n                    block_ = TierReport.reportTimeForTier(reports_[i_], tier_);\n\n                    if (block_ <= blockNumber_) {\n                        // Min and max need to compare current value against\n                        // the accumulator.\n                        if (mode_ == MODE_MIN) {\n                            accumulator_ = block_.min(accumulator_);\n                        } else if (mode_ == MODE_MAX) {\n                            accumulator_ = block_.max(accumulator_);\n                        } else if (mode_ == MODE_FIRST && !anyLte_) {\n                            accumulator_ = block_;\n                        }\n                        anyLte_ = true;\n                    } else if (logic_ == LOGIC_EVERY) {\n                        // Can short circuit for an \"every\" check.\n                        accumulator_ = TierConstants.NEVER_REPORT;\n                        break;\n                    }\n                }\n                if (!anyLte_) {\n                    accumulator_ = TierConstants.NEVER_REPORT;\n                }\n                ret_ = TierReport.updateTimeAtTier(\n                    ret_,\n                    tier_ - 1,\n                    accumulator_\n                );\n            }\n            return ret_;\n        }\n    }\n}\n"
    },
    "contracts/type/LibCast.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../interpreter/run/LibStackTop.sol\";\nimport \"../interpreter/run/LibInterpreterState.sol\";\nimport \"../interpreter/deploy/LibIntegrityState.sol\";\nimport \"../interpreter/run/RainInterpreter.sol\";\n\n/// @title LibCast\n/// @notice Additional type casting logic that the Solidity compiler doesn't\n/// give us by default. A type cast (vs. conversion) is considered one where the\n/// structure is unchanged by the cast. The cast does NOT (can't) check that the\n/// input is a valid output, for example any integer MAY be cast to a function\n/// pointer but almost all integers are NOT valid function pointers. It is the\n/// calling context that MUST ensure the validity of the data, the cast will\n/// merely retype the data in place, generally without additional checks.\n/// As most structures in solidity have the same memory structure as a `uint256`\n/// or fixed/dynamic array of `uint256` there are many conversions that can be\n/// done with near zero or minimal overhead.\nlibrary LibCast {\n    /// Retype an integer to an opcode function pointer.\n    /// @param u_ The integer to cast to an opcode function pointer.\n    /// @return fn_ The opcode function pointer.\n    function asOpFunctionPointer(\n        uint256 u_\n    )\n        internal\n        pure\n        returns (\n            function(InterpreterState memory, Operand, StackTop)\n                view\n                returns (StackTop) fn_\n        )\n    {\n        assembly (\"memory-safe\") {\n            fn_ := u_\n        }\n    }\n\n    /// Retype an array of integers to an array of opcode function pointers.\n    /// @param us_ The array of integers to cast to an array of opcode fuction\n    /// pointers.\n    /// @return fns_ The array of opcode function pointers.\n    function asOpcodeFunctionPointers(\n        uint256[] memory us_\n    )\n        internal\n        pure\n        returns (\n            function(InterpreterState memory, Operand, StackTop)\n                view\n                returns (StackTop)[]\n                memory fns_\n        )\n    {\n        assembly (\"memory-safe\") {\n            fns_ := us_\n        }\n    }\n\n    /// Retype an integer to an integrity function pointer.\n    /// @param u_ The integer to cast to an integrity function pointer.\n    /// @return fn_ The integrity function pointer.\n    function asIntegrityFunctionPointer(\n        uint256 u_\n    )\n        internal\n        pure\n        returns (\n            function(IntegrityState memory, Operand, StackTop)\n                internal\n                view\n                returns (StackTop) fn_\n        )\n    {\n        assembly (\"memory-safe\") {\n            fn_ := u_\n        }\n    }\n\n    /// Retype an integer to a pointer to the interpreter eval function.\n    /// @param u_ The integer to cast to the eval function.\n    /// @return fn_ The eval function.\n    function asEvalFunctionPointer(\n        uint256 u_\n    )\n        internal\n        pure\n        returns (\n            function(InterpreterState memory, SourceIndex, StackTop)\n                view\n                returns (StackTop) fn_\n        )\n    {\n        assembly (\"memory-safe\") {\n            fn_ := u_\n        }\n    }\n\n    /// Retype a stack move function pointer to an integer.\n    /// Provided the origin of the function pointer is solidity and NOT yul, the\n    /// returned integer will be valid to run if retyped back via yul. If the\n    /// origin of the function pointer is yul then we cannot guarantee anything\n    /// about the validity beyond the correctness of the yul code in question.\n    ///\n    /// Function pointers as integers are NOT portable across contracts as the\n    /// code in different contracts is different so function pointers will point\n    /// to a different, incompatible part of the code.\n    ///\n    /// Function pointers as integers lose the information about their signature\n    /// so MUST ONLY be called in an appropriate context once restored.\n    /// @param fn_ The stack move function pointer to integerify.\n    /// @return u_ The integer of the function pointer.\n    function asUint256(\n        function(uint256) view returns (uint256) fn_\n    ) internal pure returns (uint256 u_) {\n        assembly (\"memory-safe\") {\n            u_ := fn_\n        }\n    }\n\n    function asUint256(\n        function(IntegrityState memory, Operand, StackTop)\n            internal\n            view\n            returns (StackTop) fn_\n    ) internal pure returns (uint256 u_) {\n        assembly (\"memory-safe\") {\n            u_ := fn_\n        }\n    }\n\n    function asUint256Array(\n        function(IntegrityState memory, Operand, StackTop)\n            internal\n            view\n            returns (StackTop)[]\n            memory fns_\n    ) internal pure returns (uint256[] memory us_) {\n        assembly (\"memory-safe\") {\n            us_ := fns_\n        }\n    }\n\n    function asUint256(bool bool_) internal pure returns (uint256 u_) {\n        assembly (\"memory-safe\") {\n            u_ := bool_\n        }\n    }\n\n    function asUint256(\n        function(InterpreterState memory, SourceIndex, StackTop)\n            view\n            returns (StackTop) fn_\n    ) internal pure returns (uint256 u_) {\n        assembly (\"memory-safe\") {\n            u_ := fn_\n        }\n    }\n\n    function asUint256Array(\n        function(InterpreterState memory, Operand, StackTop)\n            view\n            returns (StackTop)[]\n            memory fns_\n    ) internal pure returns (uint256[] memory us_) {\n        assembly (\"memory-safe\") {\n            us_ := fns_\n        }\n    }\n\n    function asUint256Array(\n        function(uint256) pure returns (uint256)[] memory fns_\n    ) internal pure returns (uint256[] memory us_) {\n        assembly (\"memory-safe\") {\n            us_ := fns_\n        }\n    }\n\n    function asAddresses(\n        uint256[] memory us_\n    ) internal pure returns (address[] memory addresses_) {\n        assembly (\"memory-safe\") {\n            addresses_ := us_\n        }\n    }\n\n    function asIntegrityPointers(\n        uint256[] memory us_\n    )\n        internal\n        pure\n        returns (\n            function(IntegrityState memory, Operand, StackTop)\n                view\n                returns (StackTop)[]\n                memory fns_\n        )\n    {\n        assembly (\"memory-safe\") {\n            fns_ := us_\n        }\n    }\n}\n"
    },
    "contracts/type/LibConvert.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\n/// @title LibConvert\n/// @notice Type conversions that require additional structural changes to\n/// complete safely. These are NOT mere type casts and involve additional\n/// reads and writes to complete, such as recalculating the length of an array.\n/// The convention \"toX\" is adopted from Rust to imply the additional costs and\n/// consumption of the source to produce the target.\nlibrary LibConvert {\n    /// Convert an array of integers to `bytes` data. This requires modifying\n    /// the length in situ as the integer array length is measured in 32 byte\n    /// increments while the length of `bytes` is the literal number of bytes.\n    /// @return bytes_ The integer array converted to `bytes` data.\n    function toBytes(\n        uint256[] memory is_\n    ) internal pure returns (bytes memory bytes_) {\n        assembly (\"memory-safe\") {\n            bytes_ := is_\n            // Length in bytes is 32x the length in uint256\n            mstore(bytes_, mul(0x20, mload(bytes_)))\n        }\n    }\n\n    function unsafeTo16BitBytes(\n        uint256[] memory is_\n    ) internal pure returns (bytes memory) {\n        unchecked {\n            // We will keep 2 bytes (16 bits) from each integer.\n            bytes memory bytes_ = new bytes(is_.length * 2);\n            assembly (\"memory-safe\") {\n                let replaceMask_ := 0xFFFF\n                let preserveMask_ := not(replaceMask_)\n                for {\n                    let cursor_ := add(is_, 0x20)\n                    let end_ := add(cursor_, mul(mload(is_), 0x20))\n                    let bytesCursor_ := add(bytes_, 0x02)\n                } lt(cursor_, end_) {\n                    cursor_ := add(cursor_, 0x20)\n                    bytesCursor_ := add(bytesCursor_, 0x02)\n                } {\n                    let data_ := mload(bytesCursor_)\n                    mstore(\n                        bytesCursor_,\n                        or(and(preserveMask_, data_), mload(cursor_))\n                    )\n                }\n            }\n            return bytes_;\n        }\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000000,
      "details": {
        "peephole": true,
        "inliner": true,
        "jumpdestRemover": true,
        "orderLiterals": true,
        "deduplicate": true,
        "cse": true,
        "constantOptimizer": true
      }
    },
    "evmVersion": "london",
    "metadata": {
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}