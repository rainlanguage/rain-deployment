{
  "language": "Solidity",
  "sources": {
    "contracts/claim/EmissionsERC20.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../tier/libraries/TierConstants.sol\";\nimport {ERC20Config} from \"../erc20/ERC20Config.sol\";\nimport \"./IClaim.sol\";\nimport \"../tier/ReadOnlyTier.sol\";\nimport {RainVM, State} from \"../vm/RainVM.sol\";\nimport {VMState, StateConfig} from \"../vm/libraries/VMState.sol\";\n// solhint-disable-next-line max-line-length\nimport {AllStandardOps, ALL_STANDARD_OPS_START, ALL_STANDARD_OPS_LENGTH} from \"../vm/ops/AllStandardOps.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// Constructor config.\n/// @param allowDelegatedClaims True if accounts can call `claim` on behalf of\n/// another account.\n/// @param Constructor config for the ERC20 token minted according to emissions\n/// schedule in `claim`.\n/// @param Constructor config for the `ImmutableSource` that defines the\n/// emissions schedule for claiming.\nstruct EmissionsERC20Config {\n    bool allowDelegatedClaims;\n    ERC20Config erc20Config;\n    StateConfig vmStateConfig;\n}\n\n/// @title EmissionsERC20\n/// @notice Mints itself according to some predefined schedule. The schedule is\n/// expressed as a rainVM script and the `claim` function is world-callable.\n/// Intended behaviour is to avoid sybils infinitely minting by putting the\n/// claim functionality behind a `ITier` contract. The emissions contract\n/// itself implements `ReadOnlyTier` and every time a claim is processed it\n/// logs the block number of the claim against every tier claimed. So the block\n/// numbers in the tier report for `EmissionsERC20` are the last time that tier\n/// was claimed against this contract. The simplest way to make use of this\n/// information is to take the max block for the underlying tier and the last\n/// claim and then diff it against the current block number.\n/// See `test/Claim/EmissionsERC20.sol.ts` for examples, including providing\n/// staggered rewards where more tokens are minted for higher tier accounts.\ncontract EmissionsERC20 is\n    Initializable,\n    RainVM,\n    VMState,\n    ERC20Upgradeable,\n    IClaim,\n    ReadOnlyTier\n{\n    /// Contract has initialized.\n    /// @param sender `msg.sender` initializing the contract (factory).\n    /// @param allowDelegatedClaims True if accounts can call `claim` on behalf\n    /// of another account.\n    event Initialize(address sender, bool allowDelegatedClaims);\n\n    /// @dev local opcode to put claimant account on the stack.\n    uint256 private constant OPCODE_CLAIMANT_ACCOUNT = 0;\n    /// @dev local opcodes length.\n    uint256 internal constant LOCAL_OPS_LENGTH = 1;\n\n    /// @dev local offset for local ops.\n    uint256 private immutable localOpsStart;\n\n    /// Address of the immutable rain script deployed as a `VMState`.\n    address private vmStatePointer;\n\n    /// Whether the claimant must be the caller of `claim`. If `false` then\n    /// accounts other than claimant can claim. This may or may not be\n    /// desirable depending on the emissions schedule. For example, a linear\n    /// schedule will produce the same end result for the claimant regardless\n    /// of who calls `claim` or when but an exponential schedule is more\n    /// profitable if the claimant waits longer between claims. In the\n    /// non-linear case delegated claims would be inappropriate as third\n    /// party accounts could grief claimants by claiming \"early\", thus forcing\n    /// opportunity cost on claimants who would have preferred to wait.\n    bool public allowDelegatedClaims;\n\n    /// Each claim is modelled as a report so that the claim report can be\n    /// diffed against the upstream report from a tier based emission scheme.\n    mapping(address => uint256) private reports;\n\n    /// Constructs the emissions schedule source, opcodes and ERC20 to mint.\n    constructor() {\n        localOpsStart = ALL_STANDARD_OPS_START + ALL_STANDARD_OPS_LENGTH;\n    }\n\n    /// @param config_ source and token config. Also controls delegated claims.\n    function initialize(EmissionsERC20Config memory config_)\n        external\n        initializer\n    {\n        __ERC20_init(config_.erc20Config.name, config_.erc20Config.symbol);\n        _mint(\n            config_.erc20Config.distributor,\n            config_.erc20Config.initialSupply\n        );\n\n        vmStatePointer = _snapshot(_newState(config_.vmStateConfig));\n\n        /// Log some deploy state for use by claim/opcodes.\n        allowDelegatedClaims = config_.allowDelegatedClaims;\n\n        emit Initialize(msg.sender, config_.allowDelegatedClaims);\n    }\n\n    /// @inheritdoc RainVM\n    function applyOp(\n        bytes memory context_,\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view override {\n        unchecked {\n            if (opcode_ < localOpsStart) {\n                AllStandardOps.applyOp(\n                    state_,\n                    opcode_ - ALL_STANDARD_OPS_START,\n                    operand_\n                );\n            } else {\n                opcode_ -= localOpsStart;\n                require(opcode_ < LOCAL_OPS_LENGTH, \"MAX_OPCODE\");\n                // There's only one opcode, which stacks the account address.\n                address account_ = abi.decode(context_, (address));\n                state_.stack[state_.stackIndex] = uint256(uint160(account_));\n                state_.stackIndex++;\n            }\n        }\n    }\n\n    /// @inheritdoc ITier\n    function report(address account_)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return\n            reports[account_] > 0\n                ? reports[account_]\n                : TierConstants.NEVER_REPORT;\n    }\n\n    /// Calculates the claim without processing it.\n    /// Read only method that may be useful downstream both onchain and\n    /// offchain if a claimant wants to check the claim amount before deciding\n    /// whether to process it.\n    /// As this is read only there are no checks against delegated claims. It\n    /// is possible to return a value from `calculateClaim` and to not be able\n    /// to process the claim with `claim` if `msg.sender` is not the\n    /// `claimant_`.\n    /// @param claimant_ Address to calculate current claim for.\n    function calculateClaim(address claimant_) public view returns (uint256) {\n        State memory state_ = _restore(vmStatePointer);\n        eval(abi.encode(claimant_), state_, 0);\n        return state_.stack[state_.stackIndex - 1];\n    }\n\n    /// Processes the claim for `claimant_`.\n    /// - Enforces `allowDelegatedClaims` if it is `true` so that `msg.sender`\n    /// must also be `claimant_`.\n    /// - Takes the return from `calculateClaim` and mints for `claimant_`.\n    /// - Records the current block as the claim-tier for this contract.\n    /// - emits a `Claim` event as per `IClaim`.\n    /// @param claimant_ address receiving minted tokens. MUST be `msg.sender`\n    /// if `allowDelegatedClaims` is `false`.\n    /// @param data_ NOT used onchain. Forwarded to `Claim` event for potential\n    /// additional offchain processing.\n    /// @inheritdoc IClaim\n    function claim(address claimant_, bytes calldata data_) external {\n        // Disallow delegated claims if appropriate.\n        if (!allowDelegatedClaims) {\n            require(msg.sender == claimant_, \"DELEGATED_CLAIM\");\n        }\n\n        // Mint the claim.\n        uint256 amount_ = calculateClaim(claimant_);\n        _mint(claimant_, amount_);\n\n        // Record the current block as the latest claim.\n        // This can be diffed/combined with external reports in future claim\n        // calculations.\n        reports[claimant_] = TierReport.updateBlocksForTierRange(\n            TierConstants.NEVER_REPORT,\n            TierConstants.TIER_ZERO,\n            TierConstants.TIER_EIGHT,\n            block.number\n        );\n        emit TierChange(\n            msg.sender,\n            claimant_,\n            TierConstants.TIER_ZERO,\n            TierConstants.TIER_EIGHT,\n            // `data_` is emitted under `Claim`.\n            \"\"\n        );\n        emit Claim(msg.sender, claimant_, data_);\n    }\n}\n"
    },
    "contracts/tier/libraries/TierConstants.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title TierConstants\n/// @notice Constants for use with tier logic.\nlibrary TierConstants {\n    /// NEVER is 0xFF.. as it is infinitely in the future.\n    /// NEVER for an entire report.\n    uint256 internal constant NEVER_REPORT = type(uint256).max;\n    /// NEVER for a single tier.\n    uint32 internal constant NEVER_TIER = type(uint32).max;\n\n    /// Always is 0 as it is the genesis block.\n    /// Tiers can't predate the chain but they can predate an `ITier` contract.\n    uint256 internal constant ALWAYS = 0;\n\n    /// Account has never held a tier.\n    uint256 internal constant TIER_ZERO = 0;\n\n    /// Magic number for tier one.\n    uint256 internal constant TIER_ONE = 1;\n    /// Magic number for tier two.\n    uint256 internal constant TIER_TWO = 2;\n    /// Magic number for tier three.\n    uint256 internal constant TIER_THREE = 3;\n    /// Magic number for tier four.\n    uint256 internal constant TIER_FOUR = 4;\n    /// Magic number for tier five.\n    uint256 internal constant TIER_FIVE = 5;\n    /// Magic number for tier six.\n    uint256 internal constant TIER_SIX = 6;\n    /// Magic number for tier seven.\n    uint256 internal constant TIER_SEVEN = 7;\n    /// Magic number for tier eight.\n    uint256 internal constant TIER_EIGHT = 8;\n    /// Maximum tier is `TIER_EIGHT`.\n    uint256 internal constant MAX_TIER = TIER_EIGHT;\n}\n"
    },
    "contracts/erc20/ERC20Config.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// Constructor config for standard Open Zeppelin ERC20.\n/// @param name Name as defined by Open Zeppelin ERC20.\n/// @param symbol Symbol as defined by Open Zeppelin ERC20.\n/// @param distributor Distributor address of the initial supply.\n/// MAY be zero.\n/// @param initialSupply Initial supply to mint.\n/// MAY be zero.\nstruct ERC20Config {\n    string name;\n    string symbol;\n    address distributor;\n    uint256 initialSupply;\n}\n"
    },
    "contracts/claim/IClaim.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title IClaim\n/// @notice Embodies the idea of processing a claim for some kind of reward.\ninterface IClaim {\n\n    /// `Claim` is emitted whenever `claim` is called to signify that the claim\n    /// has been processed. Makes no assumptions about what is being claimed,\n    /// not even requiring an \"amount\" or similar. Instead there is a generic\n    /// `data` field where contextual information can be logged for offchain\n    /// processing.\n    /// @param sender `msg.sender` authorizing the claim.\n    /// @param claimant The claimant receiving the `Claim`.\n    /// @param data Associated data for the claim call.\n    event Claim(\n        address sender,\n        address claimant,\n        bytes data\n    );\n\n    /// Process a claim for `claimant`.\n    /// It is up to the implementing contract to define what a \"claim\" is, but\n    /// broadly it is expected to be some kind of reward.\n    /// Implementing contracts MAY allow addresses other than `claimant` to\n    /// process a claim but be careful if doing so to avoid griefing!\n    /// Implementing contracts MAY allow `claim` to be called arbitrarily many\n    /// times, or restrict themselves to a single or several calls only.\n    /// @param claimant The address that will receive the result of this claim.\n    function claim(address claimant, bytes calldata data) external;\n\n}"
    },
    "contracts/tier/ReadOnlyTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {ITier} from \"./ITier.sol\";\nimport {TierReport} from \"./libraries/TierReport.sol\";\n\n/// @title ReadOnlyTier\n/// @notice `ReadOnlyTier` is a base contract that other contracts\n/// are expected to inherit.\n///\n/// It does not allow `setStatus` and expects `report` to derive from\n/// some existing onchain data.\n///\n/// @dev A contract inheriting `ReadOnlyTier` cannot call `setTier`.\n///\n/// `ReadOnlyTier` is abstract because it does not implement `report`.\n/// The expectation is that `report` will derive tiers from some\n/// external data source.\nabstract contract ReadOnlyTier is ITier {\n    /// Always reverts because it is not possible to set a read only tier.\n    /// @inheritdoc ITier\n    function setTier(\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override {\n        revert(\"SET_TIER\");\n    }\n}\n"
    },
    "contracts/vm/RainVM.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"hardhat/console.sol\";\n\n/// Everything required to evaluate and track the state of a rain script.\n/// As this is a struct it will be in memory when passed to `RainVM` and so\n/// will be modified by reference internally. This is important for gas\n/// efficiency; the stack, arguments and stackIndex will likely be mutated by\n/// the running script.\n/// @param stackIndex Opcodes write to the stack at the stack index and can\n/// consume from the stack by decrementing the index and reading between the\n/// old and new stack index.\n/// IMPORANT: The stack is never zeroed out so the index must be used to\n/// find the \"top\" of the stack as the result of an `eval`.\n/// @param stack Stack is the general purpose runtime state that opcodes can\n/// read from and write to according to their functionality.\n/// @param sources Sources available to be executed by `eval`.\n/// Notably `ZIPMAP` can also select a source to execute by index.\n/// @param constants Constants that can be copied to the stack by index by\n/// `VAL`.\n/// @param arguments `ZIPMAP` populates arguments which can be copied to the\n/// stack by `VAL`.\nstruct State {\n    uint256 stackIndex;\n    uint256[] stack;\n    bytes[] sources;\n    uint256[] constants;\n    uint256[] arguments;\n}\n\n/// @dev Number of provided opcodes for `RainVM`.\nuint256 constant RAIN_VM_OPS_LENGTH = 5;\n\n/// @title RainVM\n/// @notice micro VM for implementing and executing custom contract DSLs.\n/// Libraries and contracts map opcodes to `view` functionality then RainVM\n/// runs rain scripts using these opcodes. Rain scripts dispatch as pairs of\n/// bytes. The first byte is an opcode to run and the second byte is a value\n/// the opcode can use contextually to inform how to run. Typically opcodes\n/// will read/write to the stack to produce some meaningful final state after\n/// all opcodes have been dispatched.\n///\n/// The only thing required to run a rain script is a `State` struct to pass\n/// to `eval`, and the index of the source to run. Additional context can\n/// optionally be provided to be used by opcodes. For example, an `ITier`\n/// contract can take the input of `report`, abi encode it as context, then\n/// expose a local opcode that copies this account to the stack. The state will\n/// be mutated by reference rather than returned by `eval`, this is to make it\n/// very clear to implementers that the inline mutation is occurring.\n///\n/// Rain scripts run \"top to bottom\", i.e. \"left to right\".\n/// See the tests for examples on how to construct rain script in JavaScript\n/// then pass to `ImmutableSource` contracts deployed by a factory that then\n/// run `eval` to produce a final value.\n///\n/// There are only 4 \"core\" opcodes for `RainVM`:\n/// - `0`: Skip self and optionally additional opcodes, `0 0` is a noop.\n///   DEPRECATED! DON'T USE SKIP!\n///   See https://github.com/beehive-innovation/rain-protocol/issues/262\n/// - `1`: Copy value from either `constants` or `arguments` at index `operand`\n///   to the top of the stack. High bit of `operand` is `0` for `constants` and\n///   `1` for `arguments`.\n/// - `2`: Duplicates the value at stack index `operand_` to the top of the\n///   stack.\n/// - `3`: Zipmap takes N values from the stack, interprets each as an array of\n///   configurable length, then zips them into `arguments` and maps a source\n///   from `sources` over these. See `zipmap` for more details.\n///\n/// To do anything useful the contract that inherits `RainVM` needs to provide\n/// opcodes to build up an internal DSL. This may sound complex but it only\n/// requires mapping opcode integers to functions to call, and reading/writing\n/// values to the stack as input/output for these functions. Further, opcode\n/// packs are provided in rain that any inheriting contract can use as a normal\n/// solidity library. See `MathOps.sol` opcode pack and the\n/// `CalculatorTest.sol` test contract for an example of how to dispatch\n/// opcodes and handle the results in a wrapping contract.\n///\n/// RainVM natively has no concept of branching logic such as `if` or loops.\n/// An opcode pack could implement these similar to the core zipmap by lazily\n/// evaluating a source from `sources` based on some condition, etc. Instead\n/// some simpler, eagerly evaluated selection tools such as `min` and `max` in\n/// the `MathOps` opcode pack are provided. Future versions of `RainVM` MAY\n/// implement lazy `if` and other similar patterns.\n///\n/// The `eval` function is `view` because rain scripts are expected to compute\n/// results only without modifying any state. The contract wrapping the VM is\n/// free to mutate as usual. This model encourages exposing only read-only\n/// functionality to end-user deployers who provide scripts to a VM factory.\n/// Removing all writes removes a lot of potential foot-guns for rain script\n/// authors and allows VM contract authors to reason more clearly about the\n/// input/output of the wrapping solidity code.\n///\n/// Internally `RainVM` makes heavy use of unchecked math and assembly logic\n/// as the opcode dispatch logic runs on a tight loop and so gas costs can ramp\n/// up very quickly. Implementing contracts and opcode packs SHOULD require\n/// that opcodes they receive do not exceed the codes they are expecting.\nabstract contract RainVM {\n    /// DEPRECATED! DONT USE SKIP!\n    /// `0` is a skip as this is the fallback value for unset solidity bytes.\n    /// Any additional \"whitespace\" in rain scripts will be noops as `0 0` is\n    /// \"skip self\". The val can be used to skip additional opcodes but take\n    /// care to not underflow the source itself.\n    uint256 private constant OP_SKIP = 0;\n    /// `1` copies a value either off `constants` or `arguments` to the top of\n    /// the stack. The high bit of the operand specifies which, `0` for\n    /// `constants` and `1` for `arguments`.\n    uint256 private constant OP_VAL = 1;\n    /// `2` Duplicates the value at index `operand_` to the top of the stack.\n    uint256 private constant OP_DUP = 2;\n    /// `3` takes N values off the stack, interprets them as an array then zips\n    /// and maps a source from `sources` over them. The source has access to\n    /// the original constants using `1 0` and to zipped arguments as `1 1`.\n    uint256 private constant OP_ZIPMAP = 3;\n    /// `4` ABI encodes the entire stack and logs it to the hardhat console.\n    uint256 private constant OP_DEBUG = 4;\n\n\n    /// Zipmap is rain script's native looping construct.\n    /// N values are taken from the stack as `uint256` then split into `uintX`\n    /// values where X is configurable by `operand_`. Each 1 increment in the\n    /// operand size config doubles the number of items in the implied arrays.\n    /// For example, size 0 is 1 `uint256` value, size 1 is\n    /// `2x `uint128` values, size 2 is 4x `uint64` values and so on.\n    ///\n    /// The implied arrays are zipped and then copied into `arguments` and\n    /// mapped over with a source from `sources`. Each iteration of the mapping\n    /// copies values into `arguments` from index `0` but there is no attempt\n    /// to zero out any values that may already be in the `arguments` array.\n    /// It is the callers responsibility to ensure that the `arguments` array\n    /// is correctly sized and populated for the mapped source.\n    ///\n    /// The `operand_` for the zipmap opcode is split into 3 components:\n    /// - 3 low bits: The index of the source to use from `sources`.\n    /// - 2 middle bits: The size of the loop, where 0 is 1 iteration\n    /// - 3 high bits: The number of vals to be zipped from the stack where 0\n    ///   is 1 value to be zipped.\n    ///\n    /// This is a separate function to avoid blowing solidity compile stack.\n    /// In the future it may be moved inline to `eval` for gas efficiency.\n    ///\n    /// See https://en.wikipedia.org/wiki/Zipping_(computer_science)\n    /// See https://en.wikipedia.org/wiki/Map_(higher-order_function)\n    /// @param context_ Domain specific context the wrapping contract can\n    /// provide to passthrough back to its own opcodes.\n    /// @param state_ The execution state of the VM.\n    /// @param operand_ The operand_ associated with this dispatch to zipmap.\n    function zipmap(\n        bytes memory context_,\n        State memory state_,\n        uint256 operand_\n    ) internal view {\n        unchecked {\n            uint256 sourceIndex_;\n            uint256 stepSize_;\n            uint256 offset_;\n            uint256 valLength_;\n            // assembly here to shave some gas.\n            assembly {\n                // rightmost 3 bits are the index of the source to use from\n                // sources in `state_`.\n                sourceIndex_ := and(operand_, 0x07)\n                // bits 4 and 5 indicate size of the loop. Each 1 increment of\n                // the size halves the bits of the arguments to the zipmap.\n                // e.g. 256 `stepSize_` would copy all 256 bits of the uint256\n                // into args for the inner `eval`. A loop size of `1` would\n                // shift `stepSize_` by 1 (halving it) and meaning the uint256\n                // is `eval` as 2x 128 bit values (runs twice). A loop size of\n                // `2` would run 4 times as 64 bit values, and so on.\n                //\n                // Slither false positive here for the shift of constant `256`.\n                // slither-disable-next-line incorrect-shift\n                stepSize_ := shr(and(shr(3, operand_), 0x03), 256)\n                // `offset_` is used by the actual bit shifting operations and\n                // is precalculated here to save some gas as this is a hot\n                // performance path.\n                offset_ := sub(256, stepSize_)\n                // bits 5+ determine the number of vals to be zipped. At least\n                // one value must be provided so a `valLength_` of `0` is one\n                // value to loop over.\n                valLength_ := add(shr(5, operand_), 1)\n            }\n            state_.stackIndex -= valLength_;\n\n            uint256[] memory baseVals_ = new uint256[](valLength_);\n            for (uint256 a_ = 0; a_ < valLength_; a_++) {\n                baseVals_[a_] = state_.stack[state_.stackIndex + a_];\n            }\n\n            for (uint256 step_ = 0; step_ < 256; step_ += stepSize_) {\n                for (uint256 a_ = 0; a_ < valLength_; a_++) {\n                    state_.arguments[a_] =\n                        (baseVals_[a_] << (offset_ - step_)) >>\n                        offset_;\n                }\n                eval(context_, state_, sourceIndex_);\n            }\n        }\n    }\n\n    /// Evaluates a rain script.\n    /// The main workhorse of the rain VM, `eval` runs any core opcodes and\n    /// dispatches anything it is unaware of to the implementing contract.\n    /// For a script to be useful the implementing contract must override\n    /// `applyOp` and dispatch non-core opcodes to domain specific logic. This\n    /// could be mathematical operations for a calculator, tier reports for\n    /// a membership combinator, entitlements for a minting curve, etc.\n    ///\n    /// Everything required to coordinate the execution of a rain script to\n    /// completion is contained in the `State`. The context and source index\n    /// are provided so the caller can provide additional data and kickoff the\n    /// opcode dispatch from the correct source in `sources`.\n    function eval(\n        bytes memory context_,\n        State memory state_,\n        uint256 sourceIndex_\n    ) internal view {\n        // Everything in eval can be checked statically, there are no dynamic\n        // runtime values read from the stack that can cause out of bounds\n        // behaviour. E.g. sourceIndex in zipmap and size of a skip are both\n        // taken from the operand in the source, not the stack. A program that\n        // operates out of bounds SHOULD be flagged by static code analysis and\n        // avoided by end-users.\n        unchecked {\n            uint256 i_ = 0;\n            uint256 opcode_;\n            uint256 operand_;\n            uint256 len_;\n            uint256 sourceLocation_;\n            uint256 constantsLocation_;\n            uint256 argumentsLocation_;\n            uint256 stackLocation_;\n            assembly {\n                stackLocation_ := mload(add(state_, 0x20))\n                sourceLocation_ := mload(\n                    add(\n                        mload(add(state_, 0x40)),\n                        add(0x20, mul(sourceIndex_, 0x20))\n                    )\n                )\n                constantsLocation_ := mload(add(state_, 0x60))\n                argumentsLocation_ := mload(add(state_, 0x80))\n                len_ := mload(sourceLocation_)\n            }\n\n            // Loop until complete.\n            while (i_ < len_) {\n                assembly {\n                    i_ := add(i_, 2)\n                    let op_ := mload(add(sourceLocation_, i_))\n                    opcode_ := byte(30, op_)\n                    operand_ := byte(31, op_)\n                }\n                if (opcode_ < RAIN_VM_OPS_LENGTH) {\n                    if (opcode_ == OP_VAL) {\n                        assembly {\n                            let location_ := argumentsLocation_\n                            if iszero(and(operand_, 0x80)) {\n                                location_ := constantsLocation_\n                            }\n\n                            let stackIndex_ := mload(state_)\n                            // Copy value to stack.\n                            mstore(\n                                add(\n                                    stackLocation_,\n                                    add(0x20, mul(stackIndex_, 0x20))\n                                ),\n                                mload(\n                                    add(\n                                        location_,\n                                        add(\n                                            0x20,\n                                            mul(and(operand_, 0x7F), 0x20)\n                                        )\n                                    )\n                                )\n                            )\n                            mstore(state_, add(stackIndex_, 1))\n                        }\n                    } else if (opcode_ == OP_DUP) {\n                        assembly {\n                            let stackIndex_ := mload(state_)\n                            mstore(\n                                add(\n                                    stackLocation_,\n                                    add(0x20, mul(stackIndex_, 0x20))\n                                ),\n                                mload(\n                                    add(\n                                        stackLocation_,\n                                        add(0x20, mul(operand_, 0x20))\n                                    )\n                                )\n                            )\n                            mstore(state_, add(stackIndex_, 1))\n                        }\n                    } else if (opcode_ == OP_ZIPMAP) {\n                        zipmap(context_, state_, operand_);\n                    } else if (opcode_ == OP_DEBUG) {\n                        console.logBytes(abi.encode(state_));\n                    } else {\n                        // DEPRECATED! DON'T USE SKIP!\n                        // if the high bit of the operand is nonzero then take\n                        // the top of the stack and if it is zero we do NOT\n                        // skip.\n                        // analogous to `JUMPI` in evm opcodes.\n                        // If high bit of the operand is zero then we always\n                        // skip.\n                        // analogous to `JUMP` in evm opcodes.\n                        // the operand is interpreted as a signed integer so\n                        // that we can skip forwards or backwards. Notable\n                        // difference between skip and jump from evm is that\n                        // skip moves a relative distance from the current\n                        // position and is known at compile time, while jump\n                        // moves to an absolute position read from the stack at\n                        // runtime. The relative simplicity of skip means we\n                        // can check for out of bounds behaviour at compile\n                        // time and each source can never goto a position in a\n                        // different source.\n\n                        // manually sign extend 1 bit.\n                        // normal signextend works on bytes not bits.\n                        int8 shift_ = int8(\n                            uint8(operand_) & ((uint8(operand_) << 1) | 0x7F)\n                        );\n\n                        // if the high bit is 1...\n                        if (operand_ & 0x80 > 0) {\n                            // take the top of the stack and only skip if it is\n                            // nonzero.\n                            state_.stackIndex--;\n                            if (state_.stack[state_.stackIndex] == 0) {\n                                continue;\n                            }\n                        }\n                        if (shift_ != 0) {\n                            if (shift_ < 0) {\n                                // This is not particularly intuitive.\n                                // Converting between int and uint and then\n                                // moving `i_` back another 2 bytes to\n                                // compensate for the addition of 2 bytes at\n                                // the start of the next loop.\n                                i_ -= uint8(~shift_ + 2) * 2;\n                            } else {\n                                i_ += uint8(shift_ * 2);\n                            }\n                        }\n                    }\n                } else {\n                    applyOp(context_, state_, opcode_, operand_);\n                }\n            }\n        }\n    }\n\n    /// Every contract that implements `RainVM` should override `applyOp` so\n    /// that useful opcodes are available to script writers.\n    /// For an example of a simple and efficient `applyOp` implementation that\n    /// dispatches over several opcode packs see `CalculatorTest.sol`.\n    /// Implementing contracts are encouraged to handle the dispatch with\n    /// unchecked math as the dispatch is a critical performance path and\n    /// default solidity checked math can significantly increase gas cost for\n    /// each opcode dispatched. Consider that a single zipmap could loop over\n    /// dozens of opcode dispatches internally.\n    /// Stack is modified by reference NOT returned.\n    /// @param context_ Bytes that the implementing contract can passthrough\n    /// to be ready internally by its own opcodes. RainVM ignores the context.\n    /// @param state_ The RainVM state that tracks the execution progress.\n    /// @param opcode_ The current opcode to dispatch.\n    /// @param operand_ Additional information to inform the opcode dispatch.\n    function applyOp(\n        bytes memory context_,\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view virtual {} //solhint-disable-line no-empty-blocks\n}\n"
    },
    "contracts/vm/libraries/VMState.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {State} from \"../RainVM.sol\";\nimport \"../../sstore2/SSTORE2.sol\";\n\n/// Config required to build a new `State`.\n/// @param sources Sources verbatim.\n/// @param constants Constants verbatim.\n/// @param stackLength Sets the length of the uint256[] of the stack.\n/// @param argumentsLength Sets the length of the uint256[] of the arguments.\nstruct StateConfig {\n    bytes[] sources;\n    uint256[] constants;\n    uint256 stackLength;\n    uint256 argumentsLength;\n}\n\n/// @title StateSnapshot\n/// @notice Deploys everything required to build a fresh `State` for rainVM\n/// execution as an evm contract onchain. Uses SSTORE2 to abi encode rain\n/// script into evm bytecode, then stores an immutable pointer to the resulting\n/// contract. Allows arbitrary length rain script source, constants and stack.\n/// Gas scales for reads much better for longer data than attempting to put\n/// all the source into storage.\n/// See https://github.com/0xsequence/sstore2\ncontract VMState {\n    /// A new shapshot has been deployed onchain.\n    /// @param sender `msg.sender` of the deployer.\n    /// @param pointer Pointer to the onchain snapshot contract.\n    /// @param state `State` of the snapshot that was deployed.\n    event Snapshot(address sender, address pointer, State state);\n\n    /// Builds a new `State` from `StateConfig`.\n    /// Empty stack and arguments with stack index 0.\n    /// @param config_ State config to build the new `State`.\n    function _newState(StateConfig memory config_)\n        internal\n        pure\n        returns (State memory)\n    {\n        require(config_.sources.length > 0, \"0_SOURCES\");\n        return\n            State(\n                0,\n                new uint256[](config_.stackLength),\n                config_.sources,\n                config_.constants,\n                new uint256[](config_.argumentsLength)\n            );\n    }\n\n    /// Snapshot a RainVM state as an immutable onchain contract.\n    /// Usually `State` will be new as per `newState` but can be a snapshot of\n    /// an \"in flight\" execution state also.\n    /// @param state_ The state to snapshot.\n    function _snapshot(State memory state_) internal returns (address) {\n        address pointer_ = SSTORE2.write(abi.encode(state_));\n        emit Snapshot(msg.sender, pointer_, state_);\n        return pointer_;\n    }\n\n    /// Builds a fresh state for rainVM execution from all construction data.\n    /// This can be passed directly to `eval` for a `RainVM` contract.\n    /// @param pointer_ The pointer (address) of the snapshot to restore.\n    function _restore(address pointer_) internal view returns (State memory) {\n        return abi.decode(SSTORE2.read(pointer_), (State));\n    }\n}\n"
    },
    "contracts/vm/ops/AllStandardOps.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {State, RainVM, RAIN_VM_OPS_LENGTH} from \"../RainVM.sol\";\n// solhint-disable-next-line max-line-length\nimport {EVMConstantOps, EVM_CONSTANT_OPS_LENGTH} from \"./evm/EVMConstantOps.sol\";\n// solhint-disable-next-line max-line-length\nimport {FixedPointMathOps, FIXED_POINT_MATH_OPS_LENGTH} from \"./math/FixedPointMathOps.sol\";\nimport {IERC20Ops, IERC20_OPS_LENGTH} from \"./token/IERC20Ops.sol\";\nimport {IERC721Ops, IERC721_OPS_LENGTH} from \"./token/IERC721Ops.sol\";\nimport {IERC1155Ops, IERC1155_OPS_LENGTH} from \"./token/IERC1155Ops.sol\";\nimport {LogicOps, LOGIC_OPS_LENGTH} from \"./math/LogicOps.sol\";\nimport {MathOps, MATH_OPS_LENGTH} from \"./math/MathOps.sol\";\nimport {TierOps, TIER_OPS_LENGTH} from \"./tier/TierOps.sol\";\n\nuint256 constant ALL_STANDARD_OPS_START = RAIN_VM_OPS_LENGTH;\nuint256 constant FIXED_POINT_MATH_OPS_START = EVM_CONSTANT_OPS_LENGTH;\nuint256 constant MATH_OPS_START = FIXED_POINT_MATH_OPS_START +\n    FIXED_POINT_MATH_OPS_LENGTH;\nuint256 constant LOGIC_OPS_START = MATH_OPS_START + MATH_OPS_LENGTH;\nuint256 constant TIER_OPS_START = LOGIC_OPS_START + LOGIC_OPS_LENGTH;\nuint256 constant IERC20_OPS_START = TIER_OPS_START + TIER_OPS_LENGTH;\nuint256 constant IERC721_OPS_START = IERC20_OPS_START + IERC20_OPS_LENGTH;\nuint256 constant IERC1155_OPS_START = IERC721_OPS_START + IERC721_OPS_LENGTH;\nuint256 constant ALL_STANDARD_OPS_LENGTH = IERC1155_OPS_START +\n    IERC1155_OPS_LENGTH;\n\n/// @title AllStandardOps\n/// @notice RainVM opcode pack to expose all other packs.\nlibrary AllStandardOps {\n    function applyOp(\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view {\n        unchecked {\n            if (opcode_ < FIXED_POINT_MATH_OPS_START) {\n                EVMConstantOps.applyOp(state_, opcode_, operand_);\n            } else if (opcode_ < TIER_OPS_START) {\n                if (opcode_ < MATH_OPS_START) {\n                    FixedPointMathOps.applyOp(\n                        state_,\n                        opcode_ - FIXED_POINT_MATH_OPS_START,\n                        operand_\n                    );\n                } else if (opcode_ < LOGIC_OPS_START) {\n                    MathOps.applyOp(state_, opcode_ - MATH_OPS_START, operand_);\n                } else {\n                    LogicOps.applyOp(\n                        state_,\n                        opcode_ - LOGIC_OPS_START,\n                        operand_\n                    );\n                }\n            } else if (opcode_ < IERC20_OPS_START) {\n                TierOps.applyOp(state_, opcode_ - TIER_OPS_START, operand_);\n            } else {\n                if (opcode_ < IERC721_OPS_START) {\n                    IERC20Ops.applyOp(\n                        state_,\n                        opcode_ - IERC20_OPS_START,\n                        operand_\n                    );\n                } else if (opcode_ < IERC1155_OPS_START) {\n                    IERC721Ops.applyOp(\n                        state_,\n                        opcode_ - IERC721_OPS_START,\n                        operand_\n                    );\n                } else {\n                    IERC1155Ops.applyOp(\n                        state_,\n                        opcode_ - IERC1155_OPS_START,\n                        operand_\n                    );\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/tier/ITier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title ITier\n/// @notice `ITier` is a simple interface that contracts can\n/// implement to provide membership lists for other contracts.\n///\n/// There are many use-cases for a time-preserving conditional membership list.\n///\n/// Some examples include:\n///\n/// - Self-serve whitelist to participate in fundraising\n/// - Lists of users who can claim airdrops and perks\n/// - Pooling resources with implied governance/reward tiers\n/// - POAP style attendance proofs allowing access to future exclusive events\n///\n/// @dev Standard interface to a tiered membership.\n///\n/// A \"membership\" can represent many things:\n/// - Exclusive access.\n/// - Participation in some event or process.\n/// - KYC completion.\n/// - Combination of sub-memberships.\n/// - Etc.\n///\n/// The high level requirements for a contract implementing `ITier`:\n/// - MUST represent held tiers as a `uint`.\n/// - MUST implement `report`.\n///   - The report is a `uint256` that SHOULD represent the block each tier has\n///     been continuously held since encoded as `uint32`.\n///   - The encoded tiers start at `1`; Tier `0` is implied if no tier has ever\n///     been held.\n///   - Tier `0` is NOT encoded in the report, it is simply the fallback value.\n///   - If a tier is lost the block data is erased for that tier and will be\n///     set if/when the tier is regained to the new block.\n///   - If a tier is held but the historical block information is not available\n///     the report MAY return `0x00000000` for all held tiers.\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\n/// - SHOULD implement `setTier`.\n///   - Contracts SHOULD revert with `SET_TIER` error if they cannot\n///     meaningfully set a tier directly.\n///     For example a contract that can only derive a membership tier by\n///     reading the state of an external contract cannot set tiers.\n///   - Contracts implementing `setTier` SHOULD error with `SET_ZERO_TIER`\n///     if tier 0 is being set.\n/// - MUST emit `TierChange` when `setTier` successfully writes a new tier.\n///   - Contracts that cannot meaningfully set a tier are exempt.\n///\n/// So the four possible states and report values are:\n/// - Tier is held and block is known: Block is in the report\n/// - Tier is held but block is NOT known: `0` is in the report\n/// - Tier is NOT held: `0xFF..` is in the report\n/// - Tier is unknown: `0xFF..` is in the report\ninterface ITier {\n    /// Every time a tier changes we log start and end tier against the\n    /// account.\n    /// This MAY NOT be emitted if reports are being read from the state of an\n    /// external contract.\n    /// The start tier MAY be lower than the current tier as at the block this\n    /// event is emitted in.\n    /// @param sender The `msg.sender` that authorized the tier change.\n    /// @param account The account changing tier.\n    /// @param startTier The previous tier the account held.\n    /// @param endTier The newly acquired tier the account now holds.\n    /// @param data The associated data for the tier change.\n    event TierChange(\n        address sender,\n        address account,\n        uint256 startTier,\n        uint256 endTier,\n        bytes data\n    );\n\n    /// @notice Users can set their own tier by calling `setTier`.\n    ///\n    /// The contract that implements `ITier` is responsible for checking\n    /// eligibility and/or taking actions required to set the tier.\n    ///\n    /// For example, the contract must take/refund any tokens relevant to\n    /// changing the tier.\n    ///\n    /// Obviously the user is responsible for any approvals for this action\n    /// prior to calling `setTier`.\n    ///\n    /// When the tier is changed a `TierChange` event will be emmited as:\n    /// ```\n    /// event TierChange(address account, uint startTier, uint endTier);\n    /// ```\n    ///\n    /// The `setTier` function includes arbitrary data as the third\n    /// parameter. This can be used to disambiguate in the case that\n    /// there may be many possible options for a user to achieve some tier.\n    ///\n    /// For example, consider the case where tier 3 can be achieved\n    /// by EITHER locking 1x rare NFT or 3x uncommon NFTs. A user with both\n    /// could use `data` to explicitly state their intent.\n    ///\n    /// NOTE however that _any_ address can call `setTier` for any other\n    /// address.\n    ///\n    /// If you implement `data` or anything that changes state then be very\n    /// careful to avoid griefing attacks.\n    ///\n    /// The `data` parameter can also be ignored by the contract implementing\n    /// `ITier`. For example, ERC20 tokens are fungible so only the balance\n    /// approved by the user is relevant to a tier change.\n    ///\n    /// The `setTier` function SHOULD prevent users from reassigning\n    /// tier 0 to themselves.\n    ///\n    /// The tier 0 status represents never having any status.\n    /// @dev Updates the tier of an account.\n    ///\n    /// The implementing contract is responsible for all checks and state\n    /// changes required to set the tier. For example, taking/refunding\n    /// funds/NFTs etc.\n    ///\n    /// Contracts may disallow directly setting tiers, preferring to derive\n    /// reports from other onchain data.\n    /// In this case they should `revert(\"SET_TIER\");`.\n    ///\n    /// @param account Account to change the tier for.\n    /// @param endTier Tier after the change.\n    /// @param data Arbitrary input to disambiguate ownership\n    /// (e.g. NFTs to lock).\n    function setTier(\n        address account,\n        uint256 endTier,\n        bytes calldata data\n    ) external;\n\n    /// @notice A tier report is a `uint256` that contains each of the block\n    /// numbers each tier has been held continously since as a `uint32`.\n    /// There are 9 possible tier, starting with tier 0 for `0` offset or\n    /// \"never held any tier\" then working up through 8x 4 byte offsets to the\n    /// full 256 bits.\n    ///\n    /// Low bits = Lower tier.\n    ///\n    /// In hexadecimal every 8 characters = one tier, starting at tier 8\n    /// from high bits and working down to tier 1.\n    ///\n    /// `uint32` should be plenty for any blockchain that measures block times\n    /// in seconds, but reconsider if deploying to an environment with\n    /// significantly sub-second block times.\n    ///\n    /// ~135 years of 1 second blocks fit into `uint32`.\n    ///\n    /// `2^8 / (365 * 24 * 60 * 60)`\n    ///\n    /// When a user INCREASES their tier they keep all the block numbers they\n    /// already had, and get new block times for each increased tiers they have\n    /// earned.\n    ///\n    /// When a user DECREASES their tier they return to `0xFFFFFFFF` (never)\n    /// for every tier level they remove, but keep their block numbers for the\n    /// remaining tiers.\n    ///\n    /// GUIs are encouraged to make this dynamic very clear for users as\n    /// round-tripping to a lower status and back is a DESTRUCTIVE operation\n    /// for block times.\n    ///\n    /// The intent is that downstream code can provide additional benefits for\n    /// members who have maintained a certain tier for/since a long time.\n    /// These benefits can be provided by inspecting the report, and by\n    /// on-chain contracts directly,\n    /// rather than needing to work with snapshots etc.\n    /// @dev Returns the earliest block the account has held each tier for\n    /// continuously.\n    /// This is encoded as a uint256 with blocks represented as 8x\n    /// concatenated uint32.\n    /// I.e. Each 4 bytes of the uint256 represents a u32 tier start time.\n    /// The low bits represent low tiers and high bits the high tiers.\n    /// Implementing contracts should return 0xFFFFFFFF for lost and\n    /// never-held tiers.\n    ///\n    /// @param account Account to get the report for.\n    /// @return The report blocks encoded as a uint256.\n    function report(address account) external view returns (uint256);\n}\n"
    },
    "contracts/tier/libraries/TierReport.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {ITier} from \"../ITier.sol\";\nimport \"./TierConstants.sol\";\n\n/// @title TierReport\n/// @notice `TierReport` implements several pure functions that can be\n/// used to interface with reports.\n/// - `tierAtBlockFromReport`: Returns the highest status achieved relative to\n/// a block number and report. Statuses gained after that block are ignored.\n/// - `tierBlock`: Returns the block that a given tier has been held\n/// since according to a report.\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\n/// - `updateBlocksForTierRange`: Updates a report with a block\n/// number for every tier in a range.\n/// - `updateReportWithTierAtBlock`: Updates a report to a new tier.\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\n/// The low-level bit shifting can be difficult to get right so this\n/// factors that out.\nlibrary TierReport {\n    /// Enforce upper limit on tiers so we can do unchecked math.\n    /// @param tier_ The tier to enforce bounds on.\n    modifier maxTier(uint256 tier_) {\n        require(tier_ <= TierConstants.MAX_TIER, \"MAX_TIER\");\n        _;\n    }\n\n    /// Returns the highest tier achieved relative to a block number\n    /// and report.\n    ///\n    /// Note that typically the report will be from the _current_ contract\n    /// state, i.e. `block.number` but not always. Tiers gained after the\n    /// reference block are ignored.\n    ///\n    /// When the `report` comes from a later block than the `blockNumber` this\n    /// means the user must have held the tier continuously from `blockNumber`\n    /// _through_ to the report block.\n    /// I.e. NOT a snapshot.\n    ///\n    /// @param report_ A report as per `ITier`.\n    /// @param blockNumber_ The block number to check the tiers against.\n    /// @return The highest tier held since `blockNumber` as per `report`.\n    function tierAtBlockFromReport(uint256 report_, uint256 blockNumber_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            for (uint256 i_ = 0; i_ < 8; i_++) {\n                if (uint32(uint256(report_ >> (i_ * 32))) > blockNumber_) {\n                    return i_;\n                }\n            }\n            return TierConstants.MAX_TIER;\n        }\n    }\n\n    /// Returns the block that a given tier has been held since from a report.\n    ///\n    /// The report MUST encode \"never\" as 0xFFFFFFFF. This ensures\n    /// compatibility with `tierAtBlockFromReport`.\n    ///\n    /// @param report_ The report to read a block number from.\n    /// @param tier_ The Tier to read the block number for.\n    /// @return The block number this has been held since.\n    function tierBlock(uint256 report_, uint256 tier_)\n        internal\n        pure\n        maxTier(tier_)\n        returns (uint256)\n    {\n        unchecked {\n            // ZERO is a special case. Everyone has always been at least ZERO,\n            // since block 0.\n            if (tier_ == 0) {\n                return 0;\n            }\n\n            uint256 offset_ = (tier_ - 1) * 32;\n            return uint256(uint32(uint256(report_ >> offset_)));\n        }\n    }\n\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\n    ///\n    /// @param report_ Report to truncate with high bit 1s.\n    /// @param tier_ Tier to truncate above (exclusive).\n    /// @return Truncated report.\n    function truncateTiersAbove(uint256 report_, uint256 tier_)\n        internal\n        pure\n        maxTier(tier_)\n        returns (uint256)\n    {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            uint256 mask_ = (TierConstants.NEVER_REPORT >> offset_) << offset_;\n            return report_ | mask_;\n        }\n    }\n\n    /// Updates a report with a block number for a given tier.\n    /// More gas efficient than `updateBlocksForTierRange` if only a single\n    /// tier is being modified.\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\n    /// the block for tier `1`.\n    /// @param report_ Report to use as the baseline for the updated report.\n    /// @param tier_ The tier level to update.\n    /// @param blockNumber_ The new block number for `tier_`.\n    function updateBlockAtTier(\n        uint256 report_,\n        uint256 tier_,\n        uint256 blockNumber_\n    ) internal pure maxTier(tier_) returns (uint256) {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            return\n                (report_ &\n                    ~uint256(uint256(TierConstants.NEVER_TIER) << offset_)) |\n                uint256(blockNumber_ << offset_);\n        }\n    }\n\n    /// Updates a report with a block number for every tier in a range.\n    ///\n    /// Does nothing if the end status is equal or less than the start tier.\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier at the start of the range (exclusive).\n    /// @param endTier_ The tier at the end of the range (inclusive).\n    /// @param blockNumber_ The block number to set for every tier in the\n    /// range.\n    /// @return The updated report.\n    function updateBlocksForTierRange(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 blockNumber_\n    ) internal pure maxTier(endTier_) returns (uint256) {\n        unchecked {\n            uint256 offset_;\n            for (uint256 i_ = startTier_; i_ < endTier_; i_++) {\n                offset_ = i_ * 32;\n                report_ =\n                    (report_ &\n                        ~uint256(\n                            uint256(TierConstants.NEVER_TIER) << offset_\n                        )) |\n                    uint256(blockNumber_ << offset_);\n            }\n            return report_;\n        }\n    }\n\n    /// Updates a report to a new status.\n    ///\n    /// Internally dispatches to `truncateTiersAbove` and\n    /// `updateBlocksForTierRange`.\n    /// The dispatch is based on whether the new tier is above or below the\n    /// current tier.\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\n    /// It is expected the caller will know the current tier when\n    /// calling this function and need to do other things in the calling scope\n    /// with it.\n    ///\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier to start updating relative to. Data above\n    /// this tier WILL BE LOST so probably should be the current tier.\n    /// @param endTier_ The new highest tier held, at the given block number.\n    /// @param blockNumber_ The block number to update the highest tier to, and\n    /// intermediate tiers from `startTier_`.\n    /// @return The updated report.\n    function updateReportWithTierAtBlock(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 blockNumber_\n    ) internal pure returns (uint256) {\n        return\n            endTier_ < startTier_\n                ? truncateTiersAbove(report_, endTier_)\n                : updateBlocksForTierRange(\n                    report_,\n                    startTier_,\n                    endTier_,\n                    blockNumber_\n                );\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/sstore2/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nimport \"./utils/Bytecode.sol\";\n\n/**\n  @title A key-value storage with auto-generated keys for storing chunks of\n  data with a lower write & read cost.\n  @author Agustin Aguilar <aa@horizon.io>\n\n  Readme: https://github.com/0xsequence/sstore2#readme\n*/\nlibrary SSTORE2 {\n    error WriteError();\n\n    /**\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\n    @dev The pointer is a contract address with `_data` as code\n    @param _data to be written\n    @return pointer Pointer to the written `_data`\n  */\n    function write(bytes memory _data) internal returns (address pointer) {\n        // Append 00 to _data so contract can't be called\n        // Build init code\n        bytes memory code = Bytecode.creationCodeFor(\n            abi.encodePacked(hex\"00\", _data)\n        );\n\n        // Deploy contract using create\n        assembly {\n            pointer := create(0, add(code, 32), mload(code))\n        }\n\n        // Address MUST be non-zero\n        if (pointer == address(0)) revert WriteError();\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @return data read from `_pointer` contract\n  */\n    function read(address _pointer) internal view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, 1, type(uint256).max);\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @return data read from `_pointer` contract\n  */\n    function read(address _pointer, uint256 _start)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @param _end index before which to end extraction\n    @return data read from `_pointer` contract\n  */\n    function read(\n        address _pointer,\n        uint256 _start,\n        uint256 _end\n    ) internal view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\n    }\n}\n"
    },
    "contracts/sstore2/utils/Bytecode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nlibrary Bytecode {\n    error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\n\n    /**\n    @notice Generate a creation code that results on a contract with `_code` as\n    bytecode\n    @param _code The returning value of the resulting `creationCode`\n    @return creationCode (constructor) for new contract\n  */\n    function creationCodeFor(bytes memory _code)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        /*\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\n      0x01    0x80         0x80        DUP1                size size\n      0x02    0x60         0x600e      PUSH1 14            14 size size\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\n      0x04    0x39         0x39        CODECOPY            size\n      0x05    0x60         0x6000      PUSH1 00            0 size\n      0x06    0xf3         0xf3        RETURN\n      <CODE>\n    */\n\n        return\n            abi.encodePacked(\n                hex\"63\",\n                uint32(_code.length),\n                hex\"80_60_0E_60_00_39_60_00_F3\",\n                _code\n            );\n    }\n\n    /**\n    @notice Returns the size of the code on a given address\n    @param _addr Address that may or may not contain code\n    @return size of the code on the given `_addr`\n  */\n    function codeSize(address _addr) internal view returns (uint256 size) {\n        assembly {\n            size := extcodesize(_addr)\n        }\n    }\n\n    /**\n    @notice Returns the code of a given address\n    @dev It will fail if `_end < _start`\n    @param _addr Address that may or may not contain code\n    @param _start number of bytes of code to skip on read\n    @param _end index before which to end extraction\n    @return oCode read from `_addr` deployed bytecode\n\n    Forked: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\n  */\n    function codeAt(\n        address _addr,\n        uint256 _start,\n        uint256 _end\n    ) internal view returns (bytes memory oCode) {\n        uint256 csize = codeSize(_addr);\n        if (csize == 0) return bytes(\"\");\n\n        if (_start > csize) return bytes(\"\");\n        if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end);\n\n        unchecked {\n            uint256 reqSize = _end - _start;\n            uint256 maxSize = csize - _start;\n\n            uint256 size = maxSize < reqSize ? maxSize : reqSize;\n\n            assembly {\n                // allocate output byte array - this could also be done without\n                // assembly\n                // by using o_code = new bytes(size)\n                oCode := mload(0x40)\n                // new \"memory end\" including padding\n                mstore(\n                    0x40,\n                    add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f)))\n                )\n                // store length in memory\n                mstore(oCode, size)\n                // actually retrieve the code, this needs assembly\n                extcodecopy(_addr, add(oCode, 0x20), _start, size)\n            }\n        }\n    }\n}\n"
    },
    "contracts/vm/ops/evm/EVMConstantOps.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {State} from \"../../RainVM.sol\";\n\n/// @dev Opcode for the block number.\nuint256 constant OPCODE_BLOCK_NUMBER = 0;\n/// @dev Opcode for the block timestamp.\nuint256 constant OPCODE_BLOCK_TIMESTAMP = 1;\n/// @dev Opcode for the `msg.sender`.\nuint256 constant OPCODE_SENDER = 2;\n/// @dev Opcode for `this` address of the current contract.\nuint256 constant OPCODE_THIS_ADDRESS = 3;\n/// @dev Number of provided opcodes for `BlockOps`.\nuint256 constant EVM_CONSTANT_OPS_LENGTH = 4;\n\n/// @title EVMConstantOps\n/// @notice RainVM opcode pack to access constants from the EVM environment.\nlibrary EVMConstantOps {\n    function applyOp(\n        State memory state_,\n        uint256 opcode_,\n        uint256\n    ) internal view {\n        unchecked {\n            require(opcode_ < EVM_CONSTANT_OPS_LENGTH, \"MAX_OPCODE\");\n            // Stack the current `block.number`.\n            if (opcode_ == OPCODE_BLOCK_NUMBER) {\n                state_.stack[state_.stackIndex] = block.number;\n            }\n            // Stack the current `block.timestamp`.\n            else if (opcode_ == OPCODE_BLOCK_TIMESTAMP) {\n                // solhint-disable-next-line not-rely-on-time\n                state_.stack[state_.stackIndex] = block.timestamp;\n            } else if (opcode_ == OPCODE_SENDER) {\n                // Stack the `msg.sender`.\n                state_.stack[state_.stackIndex] = uint256(uint160(msg.sender));\n            } else {\n                state_.stack[state_.stackIndex] = uint256(\n                    uint160(address(this))\n                );\n            }\n            state_.stackIndex++;\n        }\n    }\n}\n"
    },
    "contracts/vm/ops/math/FixedPointMathOps.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {State} from \"../../RainVM.sol\";\nimport \"../../../math/FixedPointMath.sol\";\n\n/// @dev Opcode for multiplication.\nuint256 constant OPCODE_SCALE18_MUL = 0;\n/// @dev Opcode for division.\nuint256 constant OPCODE_SCALE18_DIV = 1;\n/// @dev Opcode to rescale some fixed point number to 18 OOMs in situ.\nuint256 constant OPCODE_SCALE18 = 2;\n/// @dev Opcode to rescale an 18 OOMs fixed point number to scale N.\nuint256 constant OPCODE_SCALEN = 3;\n/// @dev Opcode to rescale an arbitrary fixed point number by some OOMs.\nuint256 constant OPCODE_SCALE_BY = 4;\n/// @dev Opcode for stacking the definition of one.\nuint256 constant OPCODE_ONE = 5;\n/// @dev Opcode for stacking number of fixed point decimals used.\nuint256 constant OPCODE_DECIMALS = 6;\n/// @dev Number of provided opcodes for `FixedPointMathOps`.\nuint256 constant FIXED_POINT_MATH_OPS_LENGTH = 7;\n\n/// @title FixedPointMathOps\n/// @notice RainVM opcode pack to perform basic checked math operations.\n/// Underflow and overflow will error as per default solidity behaviour.\nlibrary FixedPointMathOps {\n    using FixedPointMath for uint256;\n\n    function applyOp(\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal pure {\n        unchecked {\n            require(opcode_ < FIXED_POINT_MATH_OPS_LENGTH, \"MAX_OPCODE\");\n\n            if (opcode_ < OPCODE_SCALE18) {\n                uint256 baseIndex_ = state_.stackIndex - 2;\n                if (opcode_ == OPCODE_SCALE18_MUL) {\n                    state_.stack[baseIndex_] =\n                        state_.stack[baseIndex_].scale18(operand_) *\n                        state_.stack[baseIndex_ + 1];\n                } else if (opcode_ == OPCODE_SCALE18_DIV) {\n                    state_.stack[baseIndex_] =\n                        state_.stack[baseIndex_].scale18(operand_) /\n                        state_.stack[baseIndex_ + 1];\n                }\n                state_.stackIndex--;\n            } else if (opcode_ < OPCODE_ONE) {\n                uint256 baseIndex_ = state_.stackIndex - 1;\n                if (opcode_ == OPCODE_SCALE18) {\n                    state_.stack[baseIndex_] = state_.stack[baseIndex_].scale18(\n                        operand_\n                    );\n                } else if (opcode_ == OPCODE_SCALEN) {\n                    state_.stack[baseIndex_] = state_.stack[baseIndex_].scaleN(\n                        operand_\n                    );\n                } else if (opcode_ == OPCODE_SCALE_BY) {\n                    state_.stack[baseIndex_] = state_.stack[baseIndex_].scaleBy(\n                        int8(uint8(operand_))\n                    );\n                }\n            } else {\n                if (opcode_ == OPCODE_ONE) {\n                    state_.stack[state_.stackIndex] = FP_ONE;\n                    state_.stackIndex++;\n                } else if (opcode_ == OPCODE_DECIMALS) {\n                    state_.stack[state_.stackIndex] = FP_DECIMALS;\n                    state_.stackIndex++;\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/vm/ops/token/IERC20Ops.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {State} from \"../../RainVM.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @dev Opcode for `IERC20` `balanceOf`.\nuint256 constant OPCODE_BALANCE_OF = 0;\n/// @dev Opcode for `IERC20` `totalSupply`.\nuint256 constant OPCODE_TOTAL_SUPPLY = 1;\n/// @dev Number of provided opcodes for `IERC20Ops`.\nuint256 constant IERC20_OPS_LENGTH = 2;\n\n/// @title IERC20Ops\n/// @notice RainVM opcode pack to read the IERC20 interface.\nlibrary IERC20Ops {\n    function applyOp(\n        State memory state_,\n        uint256 opcode_,\n        uint256\n    ) internal view {\n        unchecked {\n            require(opcode_ < IERC20_OPS_LENGTH, \"MAX_OPCODE\");\n\n            // Stack the return of `balanceOf`.\n            if (opcode_ == OPCODE_BALANCE_OF) {\n                state_.stackIndex--;\n                state_.stack[state_.stackIndex - 1] = IERC20(\n                    address(uint160(state_.stack[state_.stackIndex - 1]))\n                ).balanceOf(address(uint160(state_.stack[state_.stackIndex])));\n            }\n            // Stack the return of `totalSupply`.\n            else if (opcode_ == OPCODE_TOTAL_SUPPLY) {\n                state_.stack[state_.stackIndex - 1] = IERC20(\n                    address(uint160(state_.stack[state_.stackIndex - 1]))\n                ).totalSupply();\n            }\n        }\n    }\n}\n"
    },
    "contracts/vm/ops/token/IERC721Ops.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {State} from \"../../RainVM.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/// @dev Opcode for `IERC721` `balanceOf`.\nuint256 constant OPCODE_BALANCE_OF = 0;\n/// @dev Opcode for `IERC721` `ownerOf`.\nuint256 constant OPCODE_OWNER_OF = 1;\n/// @dev Number of provided opcodes for `IERC721Ops`.\nuint256 constant IERC721_OPS_LENGTH = 2;\n\n/// @title IERC721Ops\n/// @notice RainVM opcode pack to read the IERC721 interface.\nlibrary IERC721Ops {\n    function applyOp(\n        State memory state_,\n        uint256 opcode_,\n        uint256\n    ) internal view {\n        unchecked {\n            require(opcode_ < IERC721_OPS_LENGTH, \"MAX_OPCODE\");\n\n            state_.stackIndex--;\n            // Stack the return of `balanceOf`.\n            if (opcode_ == OPCODE_BALANCE_OF) {\n                state_.stack[state_.stackIndex - 1] = IERC721(\n                    address(uint160(state_.stack[state_.stackIndex - 1]))\n                ).balanceOf(address(uint160(state_.stack[state_.stackIndex])));\n            }\n            // Stack the return of `ownerOf`.\n            else if (opcode_ == OPCODE_OWNER_OF) {\n                state_.stack[state_.stackIndex - 1] = uint256(\n                    uint160(\n                        IERC721(\n                            address(\n                                uint160(state_.stack[state_.stackIndex - 1])\n                            )\n                        ).ownerOf(state_.stack[state_.stackIndex])\n                    )\n                );\n            }\n        }\n    }\n}\n"
    },
    "contracts/vm/ops/token/IERC1155Ops.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {State} from \"../../RainVM.sol\";\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\n/// @dev Opcode for `IERC1155` `balanceOf`.\nuint256 constant OPCODE_BALANCE_OF = 0;\n/// @dev Opcode for `IERC1155` `balanceOfBatch`.\nuint256 constant OPCODE_BALANCE_OF_BATCH = 1;\n/// @dev Number of provided opcodes for `IERC1155Ops`.\nuint256 constant IERC1155_OPS_LENGTH = 2;\n\n/// @title IERC1155Ops\n/// @notice RainVM opcode pack to read the IERC1155 interface.\nlibrary IERC1155Ops {\n    function applyOp(\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view {\n        unchecked {\n            require(opcode_ < IERC1155_OPS_LENGTH, \"MAX_OPCODE\");\n\n            // Stack the return of `balanceOf`.\n            if (opcode_ == OPCODE_BALANCE_OF) {\n                state_.stackIndex -= 2;\n                uint256 baseIndex_ = state_.stackIndex - 1;\n                state_.stack[baseIndex_] = IERC1155(\n                    address(uint160(state_.stack[baseIndex_]))\n                ).balanceOf(\n                        address(uint160(state_.stack[baseIndex_ + 1])),\n                        state_.stack[baseIndex_ + 2]\n                    );\n            }\n            // Stack the return of `balanceOfBatch`.\n            // Operand will be the length\n            else if (opcode_ == OPCODE_BALANCE_OF_BATCH) {\n                uint256 len_ = operand_ + 1;\n                address[] memory addresses_ = new address[](len_);\n                uint256[] memory ids_ = new uint256[](len_);\n\n                // Consumes (2 * len_ + 1) inputs and produces len_ outputs.\n                state_.stackIndex = state_.stackIndex - (len_ + 1);\n                uint256 baseIndex_ = state_.stackIndex - len_;\n\n                IERC1155 token_ = IERC1155(\n                    address(uint160(state_.stack[baseIndex_]))\n                );\n                for (uint256 i_ = 0; i_ < len_; i_++) {\n                    addresses_[i_] = address(\n                        uint160(state_.stack[baseIndex_ + i_ + 1])\n                    );\n                    ids_[i_] = state_.stack[baseIndex_ + len_ + i_ + 1];\n                }\n\n                uint256[] memory balances_ = token_.balanceOfBatch(\n                    addresses_,\n                    ids_\n                );\n\n                for (uint256 i_ = 0; i_ < len_; i_++) {\n                    state_.stack[baseIndex_ + i_] = balances_[i_];\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/vm/ops/math/LogicOps.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {State} from \"../../RainVM.sol\";\n\n/// @dev Number of provided opcodes for `LogicOps`.\n/// The opcodes are NOT listed on the library as they are all internal to\n/// the assembly and yul doesn't seem to support using solidity constants\n/// as switch case values.\nuint256 constant LOGIC_OPS_LENGTH = 7;\n\n/// @title LogicOps\n/// @notice RainVM opcode pack to perform some basic logic operations.\nlibrary LogicOps {\n    function applyOp(\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal pure {\n        require(opcode_ < LOGIC_OPS_LENGTH, \"MAX_OPCODE\");\n        assembly {\n            let stackIndex_ := mload(state_)\n            // This is the start of the stack, adjusted for the leading length\n            // 32 bytes.\n            // i.e. reading from stackLocation_ gives the first value of the\n            // stack and NOT its length.\n            let stackTopLocation_ := add(\n                // pointer to the stack.\n                mload(add(state_, 0x20)),\n                add(\n                    // length of the stack\n                    0x20,\n                    // index of the stack\n                    mul(stackIndex_, 0x20)\n                )\n            )\n\n            switch opcode_\n            // ISZERO\n            case 0 {\n                // The stackIndex_ doesn't change for iszero as there is\n                // one input and output.\n                let location_ := sub(stackTopLocation_, 0x20)\n                mstore(location_, iszero(mload(location_)))\n            }\n            // EAGER_IF\n            // Eager because BOTH x_ and y_ must be eagerly evaluated\n            // before EAGER_IF will select one of them. If both x_ and y_\n            // are cheap (e.g. constant values) then this may also be the\n            // simplest and cheapest way to select one of them. If either\n            // x_ or y_ is expensive consider using the conditional form\n            // of OP_SKIP to carefully avoid it instead.\n            case 1 {\n                // decrease stack index by 2 (3 inputs, 1 output)\n                mstore(state_, sub(stackIndex_, 2))\n                let location_ := sub(stackTopLocation_, 0x60)\n                switch mload(location_)\n                // false => use second value\n                case 0 {\n                    mstore(location_, mload(add(location_, 0x40)))\n                }\n                // true => use first value\n                default {\n                    mstore(location_, mload(add(location_, 0x20)))\n                }\n            }\n            // EQUAL_TO\n            case 2 {\n                // decrease stack index by 1 (2 inputs, 1 output)\n                mstore(state_, sub(stackIndex_, 1))\n                let location_ := sub(stackTopLocation_, 0x40)\n                mstore(\n                    location_,\n                    eq(mload(location_), mload(add(location_, 0x20)))\n                )\n            }\n            // LESS_THAN\n            case 3 {\n                // decrease stack index by 1 (2 inputs, 1 output)\n                mstore(state_, sub(stackIndex_, 1))\n                let location_ := sub(stackTopLocation_, 0x40)\n                mstore(\n                    location_,\n                    lt(mload(location_), mload(add(location_, 0x20)))\n                )\n            }\n            // GREATER_THAN\n            case 4 {\n                // decrease stack index by 1 (2 inputs, 1 output)\n                mstore(state_, sub(stackIndex_, 1))\n                let location_ := sub(stackTopLocation_, 0x40)\n                mstore(\n                    location_,\n                    gt(mload(location_), mload(add(location_, 0x20)))\n                )\n            }\n            // EVERY\n            // EVERY is either the first item if every item is nonzero, else 0.\n            // operand_ is the length of items to check.\n            // EVERY of length `0` is a noop.\n            case 5 {\n                if iszero(iszero(operand_)) {\n                    // decrease stack index by 1 less than operand_\n                    mstore(state_, sub(stackIndex_, sub(operand_, 1)))\n                    let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n                    for {\n                        let cursor_ := location_\n                    } lt(cursor_, stackTopLocation_) {\n                        cursor_ := add(cursor_, 0x20)\n                    } {\n                        // If anything is zero then EVERY is a failed check.\n                        if iszero(mload(cursor_)) {\n                            // Prevent further looping.\n                            cursor_ := stackTopLocation_\n                            mstore(location_, 0)\n                        }\n                    }\n                }\n            }\n            // ANY\n            // ANY is the first nonzero item, else 0.\n            // operand_ id the length of items to check.\n            // ANY of length `0` is a noop.\n            case 6 {\n                if iszero(iszero(operand_)) {\n                    // decrease stack index by 1 less than the operand_\n                    mstore(state_, sub(stackIndex_, sub(operand_, 1)))\n                    let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n                    for {\n                        let cursor_ := location_\n                    } lt(cursor_, stackTopLocation_) {\n                        cursor_ := add(cursor_, 0x20)\n                    } {\n                        // If anything is NOT zero then ANY is a successful\n                        // check and can short-circuit.\n                        let item_ := mload(cursor_)\n                        if iszero(iszero(item_)) {\n                            // Prevent further looping.\n                            cursor_ := stackTopLocation_\n                            // Write the usable value to the top of the stack.\n                            mstore(location_, item_)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/vm/ops/math/MathOps.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {State} from \"../../RainVM.sol\";\nimport \"../../../math/SaturatingMath.sol\";\n\n/// @dev Opcode for addition.\nuint256 constant OPCODE_ADD = 0;\n/// @dev Opcode for saturating addition.\nuint256 constant OPCODE_SATURATING_ADD = 1;\n/// @dev Opcode for subtraction.\nuint256 constant OPCODE_SUB = 2;\n/// @dev Opcode for saturating subtraction.\nuint256 constant OPCODE_SATURATING_SUB = 3;\n/// @dev Opcode for multiplication.\nuint256 constant OPCODE_MUL = 4;\n/// @dev Opcode for saturating multiplication.\nuint256 constant OPCODE_SATURATING_MUL = 5;\n/// @dev Opcode for division.\nuint256 constant OPCODE_DIV = 6;\n/// @dev Opcode for modulo.\nuint256 constant OPCODE_MOD = 7;\n/// @dev Opcode for exponentiation.\nuint256 constant OPCODE_EXP = 8;\n/// @dev Opcode for minimum.\nuint256 constant OPCODE_MIN = 9;\n/// @dev Opcode for maximum.\nuint256 constant OPCODE_MAX = 10;\n/// @dev Number of provided opcodes for `MathOps`.\nuint256 constant MATH_OPS_LENGTH = 11;\n\n/// @title MathOps\n/// @notice RainVM opcode pack to perform basic checked math operations.\n/// Underflow and overflow will error as per default solidity behaviour.\n/// SaturatingMath opcodes are provided as \"core\" math because the VM has no\n/// ability to lazily execute code, which means that overflows cannot be\n/// guarded with conditional logic. Saturation is a quick and dirty solution to\n/// overflow that is valid in many situations.\nlibrary MathOps {\n    using SaturatingMath for uint256;\n\n    function applyOp(\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal pure {\n        require(opcode_ < MATH_OPS_LENGTH, \"MAX_OPCODE\");\n        uint256 baseIndex_;\n        uint256 top_;\n        unchecked {\n            baseIndex_ = state_.stackIndex - operand_;\n            top_ = state_.stackIndex - 1;\n        }\n        uint256 cursor_ = baseIndex_;\n        uint256 accumulator_ = state_.stack[cursor_];\n\n        // Addition.\n        if (opcode_ == OPCODE_ADD) {\n            while (cursor_ < top_) {\n                unchecked {\n                    cursor_++;\n                }\n                accumulator_ += state_.stack[cursor_];\n            }\n        }\n        // Saturating addition.\n        else if (opcode_ == OPCODE_SATURATING_ADD) {\n            while (cursor_ < top_) {\n                unchecked {\n                    cursor_++;\n                    accumulator_ = accumulator_.saturatingAdd(\n                        state_.stack[cursor_]\n                    );\n                }\n            }\n        }\n        // Subtraction.\n        else if (opcode_ == OPCODE_SUB) {\n            while (cursor_ < top_) {\n                unchecked {\n                    cursor_++;\n                }\n                accumulator_ -= state_.stack[cursor_];\n            }\n        }\n        // Saturating subtraction.\n        else if (opcode_ == OPCODE_SATURATING_SUB) {\n            while (cursor_ < top_) {\n                unchecked {\n                    cursor_++;\n                    accumulator_ = accumulator_.saturatingSub(\n                        state_.stack[cursor_]\n                    );\n                }\n            }\n        }\n        // Multiplication.\n        // Slither false positive here complaining about dividing before\n        // multiplying but both are mututally exclusive according to `opcode_`.\n        else if (opcode_ == OPCODE_MUL) {\n            while (cursor_ < top_) {\n                unchecked {\n                    cursor_++;\n                }\n                accumulator_ *= state_.stack[cursor_];\n            }\n        }\n        // Saturating multiplication.\n        else if (opcode_ == OPCODE_SATURATING_MUL) {\n            while (cursor_ < top_) {\n                unchecked {\n                    cursor_++;\n                    accumulator_ = accumulator_.saturatingMul(\n                        state_.stack[cursor_]\n                    );\n                }\n            }\n        }\n        // Division.\n        else if (opcode_ == OPCODE_DIV) {\n            while (cursor_ < top_) {\n                unchecked {\n                    cursor_++;\n                }\n                accumulator_ /= state_.stack[cursor_];\n            }\n        }\n        // Modulo.\n        else if (opcode_ == OPCODE_MOD) {\n            while (cursor_ < top_) {\n                unchecked {\n                    cursor_++;\n                }\n                accumulator_ %= state_.stack[cursor_];\n            }\n        }\n        // Exponentiation.\n        else if (opcode_ == OPCODE_EXP) {\n            while (cursor_ < top_) {\n                unchecked {\n                    cursor_++;\n                }\n                accumulator_ = accumulator_**state_.stack[cursor_];\n            }\n        }\n        // Minimum.\n        else if (opcode_ == OPCODE_MIN) {\n            uint256 item_;\n            while (cursor_ < top_) {\n                unchecked {\n                    cursor_++;\n                }\n                item_ = state_.stack[cursor_];\n                if (item_ < accumulator_) {\n                    accumulator_ = item_;\n                }\n            }\n        }\n        // Maximum.\n        else if (opcode_ == OPCODE_MAX) {\n            uint256 item_;\n            while (cursor_ < top_) {\n                unchecked {\n                    cursor_++;\n                }\n                item_ = state_.stack[cursor_];\n                if (item_ > accumulator_) {\n                    accumulator_ = item_;\n                }\n            }\n        }\n\n        unchecked {\n            state_.stack[baseIndex_] = accumulator_;\n            state_.stackIndex = baseIndex_ + 1;\n        }\n    }\n}\n"
    },
    "contracts/vm/ops/tier/TierOps.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {State} from \"../../RainVM.sol\";\nimport \"../../../tier/libraries/TierReport.sol\";\nimport \"../../../tier/libraries/TierwiseCombine.sol\";\n\n/// @dev Opcode to call `report` on an `ITier` contract.\nuint256 constant OPCODE_REPORT = 0;\n/// @dev Opcode to stack a report that has never been held for all tiers.\nuint256 constant OPCODE_NEVER = 1;\n/// @dev Opcode to stack a report that has always been held for all tiers.\nuint256 constant OPCODE_ALWAYS = 2;\n/// @dev Opcode to calculate the tierwise diff of two reports.\nuint256 constant OPCODE_SATURATING_DIFF = 3;\n/// @dev Opcode to update the blocks over a range of tiers for a report.\nuint256 constant OPCODE_UPDATE_BLOCKS_FOR_TIER_RANGE = 4;\n/// @dev Opcode to tierwise select the best block lte a reference block.\nuint256 constant OPCODE_SELECT_LTE = 5;\n/// @dev Number of provided opcodes for `TierOps`.\nuint256 constant TIER_OPS_LENGTH = 6;\n\n/// @title TierOps\n/// @notice RainVM opcode pack to operate on tier reports.\n/// The opcodes all map to functions from `ITier` and associated libraries such\n/// as `TierConstants`, `TierwiseCombine`, and `TierReport`. For each, the\n/// order of consumed values on the stack corresponds to the order of arguments\n/// to interface/library functions.\nlibrary TierOps {\n    function applyOp(\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view {\n        unchecked {\n            require(opcode_ < TIER_OPS_LENGTH, \"MAX_OPCODE\");\n            uint256 baseIndex_;\n            // Stack the report returned by an `ITier` contract.\n            // Top two stack vals are used as `ITier` contract and address\n            // to check the report for.\n            if (opcode_ == OPCODE_REPORT) {\n                state_.stackIndex -= 1;\n                baseIndex_ = state_.stackIndex - 1;\n                state_.stack[baseIndex_] = ITier(\n                    address(uint160(state_.stack[baseIndex_]))\n                ).report(address(uint160(state_.stack[baseIndex_ + 1])));\n            }\n            // Stack a report that has never been held at any tier.\n            else if (opcode_ == OPCODE_NEVER) {\n                state_.stack[state_.stackIndex] = TierConstants.NEVER_REPORT;\n                state_.stackIndex++;\n            }\n            // Stack a report that has always been held at every tier.\n            else if (opcode_ == OPCODE_ALWAYS) {\n                state_.stack[state_.stackIndex] = TierConstants.ALWAYS;\n                state_.stackIndex++;\n            }\n            // Stack the tierwise saturating subtraction of two reports.\n            // If the older report is newer than newer report the result will\n            // be `0`, else a tierwise diff in blocks will be obtained.\n            // The older and newer report are taken from the stack.\n            else if (opcode_ == OPCODE_SATURATING_DIFF) {\n                state_.stackIndex -= 2;\n                baseIndex_ = state_.stackIndex;\n                uint256 newerReport_ = state_.stack[baseIndex_];\n                uint256 olderReport_ = state_.stack[baseIndex_ + 1];\n                state_.stack[baseIndex_] = TierwiseCombine.saturatingSub(\n                    newerReport_,\n                    olderReport_\n                );\n                state_.stackIndex++;\n            }\n            // Stacks a report with updated blocks over tier range.\n            // The start and end tier are taken from the low and high bits of\n            // the `operand_` respectively.\n            // The report to update and block number to update to are both\n            // taken from the stack.\n            else if (opcode_ == OPCODE_UPDATE_BLOCKS_FOR_TIER_RANGE) {\n                uint256 startTier_ = operand_ & 0x0f; // & 00001111\n                uint256 endTier_ = (operand_ >> 4) & 0x0f; // & 00001111\n                state_.stackIndex -= 2;\n                baseIndex_ = state_.stackIndex;\n                uint256 report_ = state_.stack[baseIndex_];\n                uint256 blockNumber_ = state_.stack[baseIndex_ + 1];\n                state_.stack[baseIndex_] = TierReport.updateBlocksForTierRange(\n                    report_,\n                    startTier_,\n                    endTier_,\n                    blockNumber_\n                );\n                state_.stackIndex++;\n            }\n            // Stacks the result of a `selectLte` combinator.\n            // All `selectLte` share the same stack and argument handling.\n            // Takes the `logic_` and `mode_` from the `operand_` high bits.\n            // `logic_` is the highest bit.\n            // `mode_` is the 2 highest bits after `logic_`.\n            // The other bits specify how many values to take from the stack\n            // as reports to compare against each other and the block number.\n            else if (opcode_ == OPCODE_SELECT_LTE) {\n                uint256 logic_ = operand_ >> 7;\n                uint256 mode_ = (operand_ >> 5) & 0x3; // & 00000011\n                uint256 reportsLength_ = operand_ & 0x1F; // & 00011111\n\n                // Need one more than reports length to include block number.\n                state_.stackIndex -= reportsLength_ + 1;\n                baseIndex_ = state_.stackIndex;\n                uint256 cursor_ = baseIndex_;\n\n                uint256[] memory reports_ = new uint256[](reportsLength_);\n                for (uint256 a_ = 0; a_ < reportsLength_; a_++) {\n                    reports_[a_] = state_.stack[cursor_];\n                    cursor_++;\n                }\n                uint256 blockNumber_ = state_.stack[cursor_];\n\n                state_.stack[baseIndex_] = TierwiseCombine.selectLte(\n                    reports_,\n                    blockNumber_,\n                    logic_,\n                    mode_\n                );\n                state_.stackIndex++;\n            }\n        }\n    }\n}\n"
    },
    "contracts/math/FixedPointMath.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @dev The scale of all fixed point math. This is adopting the conventions of\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\nuint256 constant FP_DECIMALS = 18;\n/// @dev The number `1` in the standard fixed point math scaling. Most of the\n/// differences between fixed point math and regular math is multiplying or\n/// dividing by `ONE` after the appropriate scaling has been applied.\nuint256 constant FP_ONE = 10**FP_DECIMALS;\n\n/// @title FixedPointMath\n/// @notice Sometimes we want to do math with decimal values but all we have\n/// are integers, typically uint256 integers. Floats are very complex so we\n/// don't attempt to simulate them. Instead we provide a standard definition of\n/// \"one\" as 10 ** 18 and scale everything up/down to this as fixed point math.\n/// Overflows are errors as per Solidity.\nlibrary FixedPointMath {\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\n    /// @param a_ Some fixed point decimal value.\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\n    /// @return `a_` scaled to match `DECIMALS`.\n    function scale18(uint256 a_, uint256 aDecimals_)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (FP_DECIMALS == aDecimals_) {\n            return a_;\n        } else if (FP_DECIMALS > aDecimals_) {\n            return a_ * 10**(FP_DECIMALS - aDecimals_);\n        } else {\n            return a_ / 10**(aDecimals_ - FP_DECIMALS);\n        }\n    }\n\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\n    /// @param a_ A `DECIMALS` fixed point decimals.\n    /// @param targetDecimals_ The new scale of `a_`.\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\n    function scaleN(uint256 a_, uint256 targetDecimals_)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (targetDecimals_ == FP_DECIMALS) {\n            return a_;\n        } else if (FP_DECIMALS > targetDecimals_) {\n            return a_ / 10**(FP_DECIMALS - targetDecimals_);\n        } else {\n            return a_ * 10**(targetDecimals_ - FP_DECIMALS);\n        }\n    }\n\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\n    /// The caller MUST ensure the end result matches `DECIMALS` if other\n    /// functions in this library are to work correctly.\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\n    /// is supported.\n    /// @param a_ Some integer of any scale.\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\n    /// @return `a_` rescaled according to `scaleBy_`.\n    function scaleBy(uint256 a_, int8 scaleBy_)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (scaleBy_ == 0) {\n            return a_;\n        } else if (scaleBy_ > 0) {\n            return a_ * 10**uint8(scaleBy_);\n        } else {\n            return a_ / 10**(~uint8(scaleBy_) + 1);\n        }\n    }\n\n    /// Fixed point multiplication in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointMul(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (a_ * b_) / FP_ONE;\n    }\n\n    /// Fixed point division in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointDiv(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (a_ * FP_ONE) / b_;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/math/SaturatingMath.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title SaturatingMath\n/// @notice Sometimes we neither want math operations to error nor wrap around\n/// on an overflow or underflow. In the case of transferring assets an error\n/// may cause assets to be locked in an irretrievable state within the erroring\n/// contract, e.g. due to a tiny rounding/calculation error. We also can't have\n/// assets underflowing and attempting to approve/transfer \"infinity\" when we\n/// wanted \"almost or exactly zero\" but some calculation bug underflowed zero.\n/// Ideally there are no calculation mistakes, but in guarding against bugs it\n/// may be safer pragmatically to saturate arithmatic at the numeric bounds.\n/// Note that saturating div is not supported because 0/0 is undefined.\nlibrary SaturatingMath {\n    /// Saturating addition.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ + b_ and max uint256.\n    function saturatingAdd(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint256 c_ = a_ + b_;\n            return c_ < a_ ? type(uint256).max : c_;\n        }\n    }\n\n    /// Saturating subtraction.\n    /// @param a_ Minuend.\n    /// @param b_ Subtrahend.\n    /// @return Maximum of a_ - b_ and 0.\n    function saturatingSub(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return a_ > b_ ? a_ - b_ : 0;\n        }\n    }\n\n    /// Saturating multiplication.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ * b_ and max uint256.\n    function saturatingMul(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being\n            // zero, but the benefit is lost if 'b' is also tested.\n            // https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a_ == 0) return 0;\n            uint256 c_ = a_ * b_;\n            return c_ / a_ != b_ ? type(uint256).max : c_;\n        }\n    }\n}\n"
    },
    "contracts/tier/libraries/TierwiseCombine.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./TierReport.sol\";\nimport \"../../math/SaturatingMath.sol\";\n\nlibrary TierwiseCombine {\n    using Math for uint256;\n    using SaturatingMath for uint256;\n\n    /// Every lte check in `selectLte` must pass.\n    uint256 internal constant LOGIC_EVERY = 0;\n    /// Only one lte check in `selectLte` must pass.\n    uint256 internal constant LOGIC_ANY = 1;\n\n    /// Select the minimum block number from passing blocks in `selectLte`.\n    uint256 internal constant MODE_MIN = 0;\n    /// Select the maximum block number from passing blocks in `selectLte`.\n    uint256 internal constant MODE_MAX = 1;\n    /// Select the first block number that passes in `selectLte`.\n    uint256 internal constant MODE_FIRST = 2;\n\n    /// Performs a tierwise saturating subtraction of two reports.\n    /// Intepret as \"# of blocks older report was held before newer report\".\n    /// If older report is in fact newer then `0` will be returned.\n    /// i.e. the diff cannot be negative, older report as simply spent 0 blocks\n    /// existing before newer report, if it is in truth the newer report.\n    /// @param newerReport_ Block to subtract from.\n    /// @param olderReport_ Block to subtract.\n    function saturatingSub(uint256 newerReport_, uint256 olderReport_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint256 ret_;\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\n                uint256 newerBlock_ = TierReport.tierBlock(newerReport_, tier_);\n                uint256 olderBlock_ = TierReport.tierBlock(olderReport_, tier_);\n                uint256 diff_ = newerBlock_.saturatingSub(olderBlock_);\n                ret_ = TierReport.updateBlockAtTier(ret_, tier_ - 1, diff_);\n            }\n            return ret_;\n        }\n    }\n\n    /// Given a list of reports, selects the best tier in a tierwise fashion.\n    /// The \"best\" criteria can be configured by `logic_` and `mode_`.\n    /// Logic can be \"every\" or \"any\", which means that the reports for a given\n    /// tier must either all or any be less than or equal to the reference\n    /// `blockNumber_`.\n    /// Mode can be \"min\", \"max\", \"first\" which selects between all the block\n    /// numbers for a given tier that meet the lte criteria.\n    /// IMPORTANT: If the output of `selectLte` is used to write to storage\n    /// care must be taken to ensure that \"upcoming\" tiers relative to the\n    /// `blockNumber_` are not overwritten inappropriately. Typically this\n    /// function should be used as a filter over reads only from an upstream\n    /// source of truth.\n    /// @param reports_ The list of reports to select over.\n    /// @param blockNumber_ The block number that tier blocks must be lte.\n    /// @param logic_ `LOGIC_EVERY` or `LOGIC_ANY`.\n    /// @param mode_ `MODE_MIN`, `MODE_MAX` or `MODE_FIRST`.\n    function selectLte(\n        uint256[] memory reports_,\n        uint256 blockNumber_,\n        uint256 logic_,\n        uint256 mode_\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 ret_;\n            uint256 block_;\n            bool anyLte_;\n            uint256 length_ = reports_.length;\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\n                uint256 accumulator_;\n                // Nothing lte the reference block for this tier yet.\n                anyLte_ = false;\n\n                // Initialize the accumulator for this tier.\n                if (mode_ == MODE_MIN) {\n                    accumulator_ = TierConstants.NEVER_REPORT;\n                } else {\n                    accumulator_ = 0;\n                }\n\n                // Filter all the blocks at the current tier from all the\n                // reports against the reference tier and each other.\n                for (uint256 i_ = 0; i_ < length_; i_++) {\n                    block_ = TierReport.tierBlock(reports_[i_], tier_);\n\n                    if (block_ <= blockNumber_) {\n                        // Min and max need to compare current value against\n                        // the accumulator.\n                        if (mode_ == MODE_MIN) {\n                            accumulator_ = block_.min(accumulator_);\n                        } else if (mode_ == MODE_MAX) {\n                            accumulator_ = block_.max(accumulator_);\n                        } else if (mode_ == MODE_FIRST && !anyLte_) {\n                            accumulator_ = block_;\n                        }\n                        anyLte_ = true;\n                    } else if (logic_ == LOGIC_EVERY) {\n                        // Can short circuit for an \"every\" check.\n                        accumulator_ = TierConstants.NEVER_REPORT;\n                        break;\n                    }\n                }\n                if (!anyLte_) {\n                    accumulator_ = TierConstants.NEVER_REPORT;\n                }\n                ret_ = TierReport.updateBlockAtTier(\n                    ret_,\n                    tier_ - 1,\n                    accumulator_\n                );\n            }\n            return ret_;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/claim/EmissionsERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport {EmissionsERC20, EmissionsERC20Config} from \"./EmissionsERC20.sol\";\nimport {ITier} from \"../tier/ITier.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title EmissionsERC20Factory\n/// @notice Factory for deploying and registering `EmissionsERC20` contracts.\ncontract EmissionsERC20Factory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new EmissionsERC20());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        EmissionsERC20Config memory config_ = abi.decode(\n            data_,\n            (EmissionsERC20Config)\n        );\n        address clone_ = Clones.clone(implementation);\n        EmissionsERC20(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `EmissionsERC20Config` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `EmissionsERC20` constructor configuration.\n    /// @return New `EmissionsERC20` child contract address.\n    function createChildTyped(EmissionsERC20Config calldata config_)\n        external\n        returns (EmissionsERC20)\n    {\n        return EmissionsERC20(this.createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/factory/Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IFactory} from \"./IFactory.sol\";\n// solhint-disable-next-line max-line-length\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Factory\n/// @notice Base contract for deploying and registering child contracts.\nabstract contract Factory is IFactory, ReentrancyGuard {\n    /// @dev state to track each deployed contract address. A `Factory` will\n    /// never lie about deploying a child, unless `isChild` is overridden to do\n    /// so.\n    mapping(address => bool) private contracts;\n\n    /// Implements `IFactory`.\n    ///\n    /// `_createChild` hook must be overridden to actually create child\n    /// contract.\n    ///\n    /// Implementers may want to overload this function with a typed equivalent\n    /// to expose domain specific structs etc. to the compiled ABI consumed by\n    /// tooling and other scripts. To minimise gas costs for deployment it is\n    /// expected that the tooling will consume the typed ABI, then encode the\n    /// arguments and pass them to this function directly.\n    ///\n    /// @param data_ ABI encoded data to pass to child contract constructor.\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        returns (address);\n\n    /// Implements `IFactory`.\n    ///\n    /// Calls the `_createChild` hook that inheriting contracts must override.\n    /// Registers child contract address such that `isChild` is `true`.\n    /// Emits `NewChild` event.\n    ///\n    /// @param data_ Encoded data to pass down to child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_)\n        external\n        virtual\n        override\n        nonReentrant\n        returns (address)\n    {\n        // Create child contract using hook.\n        address child_ = _createChild(data_);\n        // Ensure the child at this address has not previously been deployed.\n        require(!contracts[child_], \"DUPLICATE_CHILD\");\n        // Register child contract address to `contracts` mapping.\n        contracts[child_] = true;\n        // Emit `NewChild` event with child contract address.\n        emit IFactory.NewChild(msg.sender, child_);\n        return child_;\n    }\n\n    /// Implements `IFactory`.\n    ///\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// @param maybeChild_ Address of child contract to look up.\n    /// @return Returns `true` if address is a contract created by this\n    /// contract factory, otherwise `false`.\n    function isChild(address maybeChild_)\n        external\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return contracts[maybeChild_];\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/factory/IFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\ninterface IFactory {\n    /// Whenever a new child contract is deployed, a `NewChild` event\n    /// containing the new child contract address MUST be emitted.\n    /// @param sender `msg.sender` that deployed the contract (factory).\n    /// @param child address of the newly deployed child.\n    event NewChild(address sender, address child);\n\n    /// Factories that clone a template contract MUST emit an event any time\n    /// they set the implementation being cloned. Factories that deploy new\n    /// contracts without cloning do NOT need to emit this.\n    /// @param sender `msg.sender` that deployed the implementation (factory).\n    /// @param implementation address of the implementation contract that will\n    /// be used for future clones if relevant.\n    event Implementation(address sender, address implementation);\n\n    /// Creates a new child contract.\n    ///\n    /// @param data_ Domain specific data for the child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_) external returns (address);\n\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// Addresses that were not deployed by `createChild` MUST NOT return\n    /// `true` from `isChild`. This is CRITICAL to the security guarantees for\n    /// any contract implementing `IFactory`.\n    ///\n    /// @param maybeChild_ Address to check registration for.\n    /// @return `true` if address was deployed by this contract factory,\n    /// otherwise `false`.\n    function isChild(address maybeChild_) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/verify/VerifyFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport {Verify, VerifyConfig} from \"./Verify.sol\";\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title VerifyFactory\n/// @notice Factory for creating and deploying `Verify` contracts.\ncontract VerifyFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new Verify());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        VerifyConfig memory config_ = abi.decode(data_, (VerifyConfig));\n        address clone_ = Clones.clone(implementation);\n        Verify(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with admin address.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ Initialization config for the new `Verify` child.\n    /// @return New `Verify` child contract address.\n    function createChildTyped(VerifyConfig calldata config_)\n        external\n        returns (Verify)\n    {\n        return Verify(this.createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/verify/Verify.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"./IVerifyCallback.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./libraries/VerifyConstants.sol\";\n\n/// Records the block a verify session reaches each status.\n/// If a status is not reached it is left as UNINITIALIZED, i.e. 0xFFFFFFFF.\n/// Most accounts will never be banned so most accounts will never reach every\n/// status, which is a good thing.\n/// @param addedSince Block the address was added else 0xFFFFFFFF.\n/// @param approvedSince Block the address was approved else 0xFFFFFFFF.\n/// @param bannedSince Block the address was banned else 0xFFFFFFFF.\nstruct State {\n    uint32 addedSince;\n    uint32 approvedSince;\n    uint32 bannedSince;\n}\n\n/// Structure of arbitrary evidence to support any action taken.\n/// Priviledged roles are expected to provide evidence just as applicants as an\n/// audit trail will be preserved permanently in the logs.\n/// @param account The account this evidence is relevant to.\n/// @param data Arbitrary bytes representing evidence. MAY be e.g. a reference\n/// to a sufficiently decentralised external system such as an IPFS hash.\nstruct Evidence {\n    address account;\n    bytes data;\n}\n\n/// Config to initialize a Verify contract with.\n/// @param admin The address to ASSIGN ALL ADMIN ROLES to initially. This\n/// address is free and encouraged to delegate fine grained permissions to\n/// many other sub-admin addresses, then revoke it's own \"root\" access.\n/// @param callback The address of the `IVerifyCallback` contract if it exists.\n/// MAY be `address(0)` to signify that callbacks should NOT run.\nstruct VerifyConfig {\n    address admin;\n    address callback;\n}\n\n/// @title Verify\n/// Trust-minimised contract to record the state of some verification process.\n/// When some off-chain identity is to be reified on chain there is inherently\n/// some multi-party, multi-faceted trust relationship. For example, the DID\n/// (Decentralized Identifiers) specification from W3C outlines that the\n/// controller and the subject of an identity are two different entities.\n///\n/// This is because self-identification is always problematic to the point of\n/// being uselessly unbelievable.\n///\n/// For example, I can simply say \"I am the queen of England\" and what\n/// onchain mechanism could possibly check, let alone stop me?\n/// The same problem exists in any situation where some priviledge or right is\n/// associated with identity. Consider passports, driver's licenses,\n/// celebrity status, age, health, accredited investor, social media account,\n/// etc. etc.\n///\n/// Typically crypto can't and doesn't want to deal with this issue. The usual\n/// scenario is that some system demands personal information, which leads to:\n///\n/// - Data breaches that put individual's safety at risk. Consider the December\n///   2020 leak from Ledger that dumped 270 000 home addresses and phone\n///   numbers, and another million emails, of hardware wallet owners on a\n///   public forum.\n/// - Discriminatory access, undermining an individual's self-sovereign right\n///   to run a full node, self-host a GUI and broadcast transactions onchain.\n///   Consider the dydx airdrop of 2021 where metadata about a user's access\n///   patterns logged on a server were used to deny access to presumed\n///   Americans over regulatory fears.\n/// - An entrenched supply chain of centralized actors from regulators, to\n///   government databases, through KYC corporations, platforms, etc. each of\n///   which holds an effective monopoly over, and ability to manipulate user's\n///   \"own\" identity.\n///\n/// These examples and others are completely antithetical to and undermine the\n/// safety of an opt-in, permissionless system based on pseudonomous actors\n/// self-signing actions into a shared space.\n///\n/// That said, one can hardly expect a permissionless pseudonomous system\n/// founded on asynchronous value transfers to succeed without at least some\n/// concept of curation and reputation.\n///\n/// Anon, will you invest YOUR money in anon's project?\n///\n/// Clearly for every defi blue chip there are 10 000 scams and nothing onchain\n/// can stop a scam, this MUST happen at the social layer.\n///\n/// Rain protocol is agnostic to how this verification happens. A government\n/// regulator is going to want a government issued ID cross-referenced against\n/// international sanctions. A fan of some social media influencer wants to\n/// see a verified account on that platform. An open source software project\n/// should show a github profile. A security token may need evidence from an\n/// accountant showing accredited investor status. There are so many ways in\n/// which BOTH sides of a fundraise may need to verify something about\n/// themselves to each other via a THIRD PARTY that Rain cannot assume much.\n///\n/// The trust model and process for Rain verification is:\n///\n/// - There are many `Verify` contracts, each represents a specific\n///   verification method with a (hopefully large) set of possible reviewers.\n/// - The verifyee compiles some evidence that can be referenced in some\n///   relevant system. It could be a session ID in a KYC provider's database or\n///   a tweet from a verified account, etc. The evidence is passed to the\n///   `Verify` contract as raw bytes so it is opaque onchain, but visible as an\n///   event to verifiers.\n/// - The verifyee calls `add` _for themselves_ to initialize their state and\n///   emit the evidence for their account, after which they _cannot change_\n///   their submission without appealing to someone who can remove. This costs\n///   gas, so why don't we simply ask the user to sign something and have an\n///   approver verify the signed data? Because we want to leverage both the\n///   censorship resistance and asynchronous nature of the underlying\n///   blockchain. Assuming there are N possible approvers, we want ANY 1 of\n///   those N approvers to be able to review and approve an application. If the\n///   user is forced to submit their application directly to one SPECIFIC\n///   approver we lose this property. In the gasless model the user must then\n///   rely on their specific approver both being online and not to censor the\n///   request. It's also possible that many accounts add the same evidence,\n///   after all it will be public in the event logs, so it is important for\n///   approvers to verify the PAIRING between account and evidence.\n/// - ANY account with the `APPROVER` role can review the evidence by\n///   inspecting the event logs. IF the evidence is valid then the `approve`\n///   function should be called by the approver.\n/// - ANY account with the `BANNER` role can veto either an add OR a prior\n///   approval. In the case of a false positive, i.e. where an account was\n///   mistakenly approved, an appeal can be made to a banner to update the\n///   status. Bad accounts SHOULD BE BANNED NOT REMOVED. When an account is\n///   removed, its onchain state is once again open for the attacker to\n///   resubmit new fraudulent evidence and potentially be reapproved.\n///   Once an account is banned, any attempt by the account holder to change\n///   their status, or an approver to approve will be rejected. Downstream\n///   consumers of a `State` MUST check for an existing ban.\n///   - ANY account with the `REMOVER` role can scrub the `State` from an\n///   account. Of course, this is a blockchain so the state changes are all\n///   still visible to full nodes and indexers in historical data, in both the\n///   onchain history and the event logs for each state change. This allows an\n///   account to appeal to a remover in the case of a MISTAKEN BAN or also in\n///   the case of a MISTAKEN ADD (e.g. mistake in evidence), effecting a\n///   \"hard reset\" at the contract storage level.\n///\n/// Banning some account with an invalid session is NOT required. It is\n/// harmless for an added session to remain as `Status.Added` indefinitely.\n/// For as long as no approver decides to approve some invalid added session it\n/// MUST be treated as equivalent to a ban by downstream contracts. This is\n/// important so that admins are only required to spend gas on useful actions.\n///\n/// In addition to `Approve`, `Ban`, `Remove` there are corresponding events\n/// `RequestApprove`, `RequestBan`, `RequestRemove` that allow for admins to be\n/// notified that some new evidence must be considered that may lead to each\n/// action. `RequestApprove` is automatically submitted as part of the `add`\n/// call, but `RequestBan` and `RequestRemove` must be manually called\n///\n/// Rain uses standard Open Zeppelin `AccessControl` and is agnostic to how the\n/// approver/remover/banner roles and associated admin roles are managed.\n/// Ideally the more credibly neutral qualified parties assigend to each role\n/// for each `Verify` contract the better. This improves the censorship\n/// resistance of the verification process and the responsiveness of the\n/// end-user experience.\n///\n/// Ideally the admin account assigned at deployment would renounce their admin\n/// rights after establishing a more granular and appropriate set of accounts\n/// with each specific role.\ncontract Verify is AccessControl, Initializable {\n    /// Any state never held is UNINITIALIZED.\n    /// Note that as per default evm an unset state is 0 so always check the\n    /// `addedSince` block on a `State` before trusting an equality check on\n    /// any other block number.\n    /// (i.e. removed or never added)\n    uint32 private constant UNINITIALIZED = type(uint32).max;\n\n    /// Emitted when the `Verify` contract is initialized.\n    event Initialize(address sender, VerifyConfig config);\n\n    /// Emitted when evidence is first submitted to approve an account.\n    /// The requestor is always the `msg.sender` of the user calling `add`.\n    /// @param sender The `msg.sender` that submitted its own evidence.\n    /// @param evidence The evidence to support an approval.\n    /// NOT written to contract storage.\n    event RequestApprove(address sender, Evidence evidence);\n    /// Emitted when a previously added account is approved.\n    /// @param sender The `msg.sender` that approved `account`.\n    /// @param evidence The approval data.\n    event Approve(address sender, Evidence evidence);\n\n    /// Currently approved accounts can request that any account be banned.\n    /// The requestor is expected to provide supporting data for the ban.\n    /// The requestor MAY themselves be banned if vexatious.\n    /// @param sender The `msg.sender` requesting a ban of `account`.\n    /// @param evidence Account + data the `requestor` feels will strengthen\n    /// its case for the ban. NOT written to contract storage.\n    event RequestBan(address sender, Evidence evidence);\n    /// Emitted when an added or approved account is banned.\n    /// @param sender The `msg.sender` that banned `account`.\n    /// @param evidence Account + the evidence to support a ban.\n    /// NOT written to contract storage.\n    event Ban(address sender, Evidence evidence);\n\n    /// Currently approved accounts can request that any account be removed.\n    /// The requestor is expected to provide supporting data for the removal.\n    /// The requestor MAY themselves be banned if vexatious.\n    /// @param sender The `msg.sender` requesting a removal of `account`.\n    /// @param evidence `Evidence` to justify a removal.\n    event RequestRemove(address sender, Evidence evidence);\n    /// Emitted when an account is scrubbed from blockchain state.\n    /// Historical logs still visible offchain of course.\n    /// @param sender The `msg.sender` that removed `account`.\n    /// @param evidence `Evidence` to justify the removal.\n    event Remove(address sender, Evidence evidence);\n\n    /// Admin role for `APPROVER`.\n    bytes32 public constant APPROVER_ADMIN = keccak256(\"APPROVER_ADMIN\");\n    /// Role for `APPROVER`.\n    bytes32 public constant APPROVER = keccak256(\"APPROVER\");\n\n    /// Admin role for `REMOVER`.\n    bytes32 public constant REMOVER_ADMIN = keccak256(\"REMOVER_ADMIN\");\n    /// Role for `REMOVER`.\n    bytes32 public constant REMOVER = keccak256(\"REMOVER\");\n\n    /// Admin role for `BANNER`.\n    bytes32 public constant BANNER_ADMIN = keccak256(\"BANNER_ADMIN\");\n    /// Role for `BANNER`.\n    bytes32 public constant BANNER = keccak256(\"BANNER\");\n\n    /// Account => State\n    mapping(address => State) private states;\n\n    /// Optional IVerifyCallback contract.\n    /// MAY be address 0.\n    IVerifyCallback public callback = IVerifyCallback(address(0));\n\n    /// Initializes the `Verify` contract e.g. as cloned by a factory.\n    /// @param config_ The config required to initialize the contract.\n    function initialize(VerifyConfig calldata config_) external initializer {\n        require(config_.admin != address(0), \"0_ACCOUNT\");\n\n        // `APPROVER_ADMIN` can admin each other in addition to\n        // `APPROVER` addresses underneath.\n        _setRoleAdmin(APPROVER_ADMIN, APPROVER_ADMIN);\n        _setRoleAdmin(APPROVER, APPROVER_ADMIN);\n\n        // `REMOVER_ADMIN` can admin each other in addition to\n        // `REMOVER` addresses underneath.\n        _setRoleAdmin(REMOVER_ADMIN, REMOVER_ADMIN);\n        _setRoleAdmin(REMOVER, REMOVER_ADMIN);\n\n        // `BANNER_ADMIN` can admin each other in addition to\n        // `BANNER` addresses underneath.\n        _setRoleAdmin(BANNER_ADMIN, BANNER_ADMIN);\n        _setRoleAdmin(BANNER, BANNER_ADMIN);\n\n        // It is STRONGLY RECOMMENDED that the `admin_` delegates specific\n        // admin roles then revokes the `X_ADMIN` roles. From themselves.\n        // It is ALSO RECOMMENDED that each of the sub-`X_ADMIN` roles revokes\n        // their admin rights once sufficient approvers/removers/banners have\n        // been assigned, if possible. Admins can instantly/atomically assign\n        // and revoke admin priviledges from each other, so a compromised key\n        // can irreperably damage a `Verify` contract instance.\n        _grantRole(APPROVER_ADMIN, config_.admin);\n        _grantRole(REMOVER_ADMIN, config_.admin);\n        _grantRole(BANNER_ADMIN, config_.admin);\n\n        callback = IVerifyCallback(config_.callback);\n\n        emit Initialize(msg.sender, config_);\n    }\n\n    /// Typed accessor into states.\n    /// @param account_ The account to return the current `State` for.\n    function state(address account_) external view returns (State memory) {\n        return states[account_];\n    }\n\n    /// Derives a single `Status` from a `State` and a reference block number.\n    /// @param state_ The raw `State` to reduce into a `Status`.\n    /// @param blockNumber_ The block number to compare `State` against.\n    function statusAtBlock(State memory state_, uint256 blockNumber_)\n        public\n        pure\n        returns (uint256)\n    {\n        // The state hasn't even been added so is picking up block zero as the\n        // evm fallback value. In this case if we checked other blocks using\n        // a `<=` equality they would incorrectly return `true` always due to\n        // also having a `0` fallback value.\n        // Using `< 1` here to silence slither.\n        if (state_.addedSince < 1) {\n            return VerifyConstants.STATUS_NIL;\n        }\n        // Banned takes priority over everything.\n        else if (state_.bannedSince <= blockNumber_) {\n            return VerifyConstants.STATUS_BANNED;\n        }\n        // Approved takes priority over added.\n        else if (state_.approvedSince <= blockNumber_) {\n            return VerifyConstants.STATUS_APPROVED;\n        }\n        // Added is lowest priority.\n        else if (state_.addedSince <= blockNumber_) {\n            return VerifyConstants.STATUS_ADDED;\n        }\n        // The `addedSince` block is after `blockNumber_` so `Status` is nil\n        // relative to `blockNumber_`.\n        else {\n            return VerifyConstants.STATUS_NIL;\n        }\n    }\n\n    /// Requires that `msg.sender` is approved as at the current block.\n    modifier onlyApproved() {\n        require(\n            statusAtBlock(states[msg.sender], block.number) ==\n                VerifyConstants.STATUS_APPROVED,\n            \"ONLY_APPROVED\"\n        );\n        _;\n    }\n\n    /// @dev Builds a new `State` for use by `add` and `approve`.\n    function newState() private view returns (State memory) {\n        return State(uint32(block.number), UNINITIALIZED, UNINITIALIZED);\n    }\n\n    /// An account adds their own verification evidence.\n    /// Internally `msg.sender` is used; delegated `add` is not supported.\n    /// @param data_ The evidence to support approving the `msg.sender`.\n    function add(bytes calldata data_) external {\n        State memory state_ = states[msg.sender];\n        uint256 currentStatus_ = statusAtBlock(state_, block.number);\n        require(\n            currentStatus_ != VerifyConstants.STATUS_APPROVED &&\n                currentStatus_ != VerifyConstants.STATUS_BANNED,\n            \"ALREADY_EXISTS\"\n        );\n        // An account that hasn't already been added need a new state.\n        // If an account has already been added but not approved or banned\n        // they can emit many `RequestApprove` events without changing\n        // their state. This facilitates multi-step workflows for the KYC\n        // provider, e.g. to implement a commit+reveal scheme or simply\n        // request additional evidence from the applicant before final\n        // verdict.\n        if (currentStatus_ == VerifyConstants.STATUS_NIL) {\n            states[msg.sender] = newState();\n        }\n        Evidence memory evidence_ = Evidence(msg.sender, data_);\n        emit RequestApprove(msg.sender, evidence_);\n\n        // Call the `afterAdd_` hook to allow inheriting contracts to enforce\n        // requirements.\n        // The inheriting contract MUST `require` or otherwise enforce its\n        // needs to rollback a bad add.\n        if (address(callback) != address(0)) {\n            callback.afterAdd(msg.sender, evidence_);\n        }\n    }\n\n    /// An `APPROVER` can review added evidence and approve accounts.\n    /// Typically many approvals would be submitted in a single call which is\n    /// more convenient and gas efficient than sending individual transactions\n    /// for every approval. However, as there are many individual agents\n    /// acting concurrently and independently this requires that the approval\n    /// process be infallible so that no individual approval can rollback the\n    /// entire batch due to the actions of some other approver/banner. It is\n    /// possible to approve an already approved or banned account. The\n    /// `Approve` event will always emit but the approved block will only be\n    /// set if it was previously uninitialized. A banned account will always\n    /// be seen as banned when calling `statusAtBlock` regardless of the\n    /// approval block, even if the approval is more recent than the ban. The\n    /// only way to reset a ban is to remove and reapprove the account.\n    /// @param evidences_ All evidence for all approvals.\n    function approve(Evidence[] calldata evidences_)\n        external\n        onlyRole(APPROVER)\n    {\n        uint256 dirty_ = 0;\n        State memory state_;\n        for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n            state_ = states[evidences_[i_].account];\n            // If the account hasn't been added an approver can still add and\n            // approve it on their behalf.\n            if (state_.addedSince < 1) {\n                state_ = newState();\n                dirty_ = 1;\n            }\n            // If the account hasn't been approved we approve it. As there are\n            // many approvers operating independently and concurrently we do\n            // NOT `require` the approval be unique, but we also do NOT change\n            // the block as the oldest approval is most important. However we\n            // emit an event for every approval even if the state does not\n            // change.\n            // It is possible to approve a banned account but `statusAtBlock`\n            // will ignore the approval time for any banned account and use the\n            // banned block only.\n            if (state_.approvedSince == UNINITIALIZED) {\n                state_.approvedSince = uint32(block.number);\n                dirty_ = 1;\n            }\n\n            if (dirty_ > 0) {\n                states[evidences_[i_].account] = state_;\n                dirty_ = 0;\n            }\n\n            // Always emit an `Approve` event even if we didn't write state.\n            // This ensures that supporting evidence hits the logs for offchain\n            // review.\n            emit Approve(msg.sender, evidences_[i_]);\n        }\n        if (address(callback) != address(0)) {\n            callback.afterApprove(msg.sender, evidences_);\n        }\n    }\n\n    /// Any approved address can request some other address be approved.\n    /// Frivolous requestors SHOULD expect to find themselves banned.\n    /// @param evidences_ Array of evidences to request approvals for.\n    function requestApprove(Evidence[] calldata evidences_)\n        external\n        onlyApproved\n    {\n        for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n            emit RequestApprove(msg.sender, evidences_[i_]);\n        }\n    }\n\n    /// A `BANNER` can ban an added OR approved account.\n    /// @param evidences_ All evidence appropriate for all bans.\n    function ban(Evidence[] calldata evidences_) external onlyRole(BANNER) {\n        uint256 dirty_ = 0;\n        State memory state_;\n        for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n            state_ = states[evidences_[i_].account];\n\n            // There is no requirement that an account be formally added before\n            // it is banned. For example some fraud may be detected in an\n            // affiliated `Verify` contract and the evidence can be used to ban\n            // the same address in the current contract.\n            if (state_.addedSince < 1) {\n                state_ = newState();\n                dirty_ = 1;\n            }\n            // Respect prior bans by leaving the older block number in place.\n            if (state_.bannedSince == UNINITIALIZED) {\n                state_.bannedSince = uint32(block.number);\n                dirty_ = 1;\n            }\n\n            if (dirty_ > 0) {\n                states[evidences_[i_].account] = state_;\n                dirty_ = 0;\n            }\n\n            // Always emit a `Ban` event even if we didn't write state. This\n            // ensures that supporting evidence hits the logs for offchain\n            // review.\n            emit Ban(msg.sender, evidences_[i_]);\n        }\n\n        if (address(callback) != address(0)) {\n            callback.afterBan(msg.sender, evidences_);\n        }\n    }\n\n    /// Any approved address can request some other address be banned.\n    /// Frivolous requestors SHOULD expect to find themselves banned.\n    /// @param evidences_ Array of evidences to request banning for.\n    function requestBan(Evidence[] calldata evidences_) external onlyApproved {\n        for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n            emit RequestBan(msg.sender, evidences_[i_]);\n        }\n    }\n\n    /// A `REMOVER` can scrub state mapping from an account.\n    /// A malicious account MUST be banned rather than removed.\n    /// Removal is useful to reset the whole process in case of some mistake.\n    /// @param evidences_ All evidence to suppor the removal.\n    function remove(Evidence[] calldata evidences_) external onlyRole(REMOVER) {\n        State memory state_;\n        for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n            state_ = states[evidences_[i_].account];\n            if (state_.addedSince > 0) {\n                delete (states[evidences_[i_].account]);\n            }\n            emit Remove(msg.sender, evidences_[i_]);\n        }\n\n        if (address(callback) != address(0)) {\n            callback.afterRemove(msg.sender, evidences_);\n        }\n    }\n\n    /// Any approved address can request some other address be removed.\n    /// Frivolous requestors SHOULD expect to find themselves banned.\n    /// @param evidences_ Array of evidences to request removal of.\n    function requestRemove(Evidence[] calldata evidences_)\n        external\n        onlyApproved\n    {\n        for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n            emit RequestRemove(msg.sender, evidences_[i_]);\n        }\n    }\n}\n"
    },
    "contracts/verify/IVerifyCallback.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {Evidence} from \"./Verify.sol\";\n\n/// Deployers of `Verify` contracts (e.g. via `VerifyFactory`) may want to\n/// apply additional processing and/or restrictions to each of the basic\n/// verification actions. Examples may be reading from onchain state or\n/// requiring token transfers to complete before allowing an add/approve to\n/// complete successfully. The reason this is an interface rather than\n/// implementors extending `Verify` directly is that it allows for more\n/// implementations to sit under a single `VerifyFactory` which in turn allows\n/// a more readily composed ecosystem of verified accounts.\n///\n/// There's no reentrancy concerns for external calls from the `Verify`\n/// contract to the `IVerifyCallback` contract because:\n/// - All the callbacks happen after state changes in `Verify`\n/// - All `Verify` actions are bound to the authority of the `msg.sender`\n/// The `IVerifyCallback` contract can and should rollback transactions if\n/// their restrictions/processing requirements are not met, but otherwise have\n/// no more authority over the `Verify` state than anon users.\n///\n/// The security model for platforms consuming `Verify` contracts is that they\n/// should index or otherwise filter children from the `VerifyFactory` down to\n/// those that also set a supported `IVerifyCallback` contract. The factory is\n/// completely agnostic to callback concerns and doesn't even require that a\n/// callback contract be set at all.\ninterface IVerifyCallback {\n    /// Additional processing after an address has been added.\n    /// SHOULD revert/rollback transactions if processing fails.\n    /// @param adder_ The `msg.sender` in the `add`. Will be the addee.\n    /// @param evidence_ The evidence associated with the add.\n    function afterAdd(address adder_, Evidence calldata evidence_) external;\n\n    /// Additional processing after a batch of approvals.\n    /// SHOULD revert/rollback transactions if processing fails.\n    /// @param approver_ The `msg.sender` that authorized the approvals.\n    /// @param evidences_ All evidences associated with the approvals.\n    function afterApprove(address approver_, Evidence[] calldata evidences_)\n        external;\n\n    /// Additional processing after a batch of bannings.\n    /// SHOULD revert/rollback transactions if processing fails.\n    /// @param banner_ The `msg.sender` that authorized the bannings.\n    /// @param evidences_ All evidences associated with the bannings.\n    function afterBan(address banner_, Evidence[] calldata evidences_) external;\n\n    /// Additional processing after a batch of removals.\n    /// SHOULD revert/rollback transactions if processing fails.\n    /// @param remover_ The `msg.sender` that authorized the removals.\n    /// @param evidences_ All evidences associated with the removals.\n    function afterRemove(address remover_, Evidence[] calldata evidences_)\n        external;\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/verify/libraries/VerifyConstants.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// Summary statuses derived from a `State` by comparing the `Since` times\n/// against a specific block number.\nlibrary VerifyConstants {\n    /// Account has not interacted with the system yet or was removed.\n    uint256 internal constant STATUS_NIL = 0;\n    /// Account has added evidence for themselves.\n    uint256 internal constant STATUS_ADDED = 1;\n    /// Approver has reviewed added/approve evidence and approved the account.\n    uint256 internal constant STATUS_APPROVED = 2;\n    /// Banner has reviewed a request to ban an account and banned it.\n    uint256 internal constant STATUS_BANNED = 3;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/tier/VerifyTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"./ReadOnlyTier.sol\";\nimport \"../verify/libraries/VerifyConstants.sol\";\nimport {State, Verify} from \"../verify/Verify.sol\";\nimport \"./libraries/TierReport.sol\";\n\n/// @title VerifyTier\n///\n/// @dev A contract that is `VerifyTier` expects to derive tiers from the time\n/// the account was approved by the underlying `Verify` contract. The approval\n/// block numbers defer to `State.since` returned from `Verify.state`.\ncontract VerifyTier is ReadOnlyTier, Initializable {\n    /// Result of initializing.\n    /// @param sender `msg.sender` that initialized the contract.\n    /// @param verify The `Verify` contract checked for reports.ww\n    event Initialize(address sender, address verify);\n    /// The contract to check to produce reports.\n    Verify private verify;\n\n    /// Sets the `verify` contract.\n    /// @param verify_ The contract to check to produce reports.\n    function initialize(address verify_) external initializer {\n        require(verify_ != address(0), \"0_ADDRESS\");\n        verify = Verify(verify_);\n        emit Initialize(msg.sender, verify_);\n    }\n\n    /// Every tier will be the `State.since` block if `account_` is approved\n    /// otherwise every tier will be uninitialized.\n    /// @inheritdoc ITier\n    function report(address account_) public view override returns (uint256) {\n        State memory state_ = verify.state(account_);\n        if (\n            // This is comparing an enum variant so it must be equal.\n            // slither-disable-next-line incorrect-equality\n            verify.statusAtBlock(state_, block.number) ==\n            VerifyConstants.STATUS_APPROVED\n        ) {\n            return\n                TierReport.updateBlocksForTierRange(\n                    TierConstants.NEVER_REPORT,\n                    TierConstants.TIER_ZERO,\n                    TierConstants.TIER_EIGHT,\n                    state_.approvedSince\n                );\n        } else {\n            return TierConstants.NEVER_REPORT;\n        }\n    }\n}\n"
    },
    "contracts/tier/VerifyTierFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport {VerifyTier} from \"./VerifyTier.sol\";\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title VerifyTierFactory\n/// @notice Factory for creating and deploying `VerifyTier` contracts.\ncontract VerifyTierFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new VerifyTier());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        address verify_ = abi.decode(data_, (address));\n        address clone_ = Clones.clone(implementation);\n        VerifyTier(clone_).initialize(verify_);\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with `Verify`.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param verify_ `Verify` of the `VerifyTier` logic.\n    /// @return New `VerifyTier` child contract address.\n    function createChildTyped(address verify_) external returns (VerifyTier) {\n        return VerifyTier(this.createChild(abi.encode(verify_)));\n    }\n}\n"
    },
    "contracts/tier/ERC721BalanceTierFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport \"./ERC721BalanceTier.sol\";\n\n/// @title ERC721BalanceTierFactory\n/// @notice Factory for creating and deploying `ERC721BalanceTier` contracts.\ncontract ERC721BalanceTierFactory is Factory {\n    address private implementation;\n\n    constructor() {\n        address implementation_ = address(new ERC721BalanceTier());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        ERC721BalanceTierConfig memory config_ = abi.decode(\n            data_,\n            (ERC721BalanceTierConfig)\n        );\n        address clone_ = Clones.clone(implementation);\n        ERC721BalanceTier(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with `ERC721BalanceTierConfig`.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ Constructor config for `ERC721BalanceTier`.\n    /// @return New `ERC721BalanceTier` child contract address.\n    function createChildTyped(ERC721BalanceTierConfig memory config_)\n        external\n        returns (ERC721BalanceTier)\n    {\n        return ERC721BalanceTier(this.createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/tier/ERC721BalanceTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n//solhint-disable-next-line max-line-length\nimport {TierReport} from \"./libraries/TierReport.sol\";\nimport {ValueTier} from \"./ValueTier.sol\";\nimport {ITier} from \"./ITier.sol\";\nimport {TierConstants} from \"./libraries/TierConstants.sol\";\nimport \"./ReadOnlyTier.sol\";\n\n/// Constructor config for ERC721BalanceTier.\nstruct ERC721BalanceTierConfig {\n    /// The erc721 token contract to check the balance\n    /// of at `report` time.\n    IERC721 erc721;\n    /// 8 values corresponding to minimum erc721\n    /// balances for tier 1 through tier 8.\n    uint256[8] tierValues;\n}\n\n/// @title ERC721BalanceTier\n/// @notice `ERC721BalanceTier` inherits from `ReadOnlyTier`.\n///\n/// There is no internal accounting, the balance tier simply reads the balance\n/// of the user whenever `report` is called.\n///\n/// `setTier` always fails.\n///\n/// There is no historical information so each tier will either be `0x00000000`\n/// or `0xFFFFFFFF` for the block number.\n///\n/// @dev The `ERC721BalanceTier` simply checks the current balance of an erc721\n/// against tier values. As the current balance is always read from the erc721\n/// contract directly there is no historical block data.\n/// All tiers held at the current value will be `0x00000000` and tiers not held\n/// will be `0xFFFFFFFF`.\n/// `setTier` will error as this contract has no ability to write to the erc721\n/// contract state.\n///\n/// Balance tiers are useful for:\n/// - Claim contracts that don't require backdated tier holding\n///   (be wary of griefing!).\n/// - Assets that cannot be transferred, so are not eligible for\n///   `ERC721TransferTier`.\n/// - Lightweight, realtime checks that encumber the tiered address\n///   as little as possible.\ncontract ERC721BalanceTier is ReadOnlyTier, ValueTier, Initializable {\n    \n    event Initialize(\n        /// `msg.sender` of the initialize.\n        address sender,\n        /// erc20 to transfer.\n        address erc721\n    );\n\n    IERC721 public erc721;\n\n    /// @param config_ Initialize config.\n    function initialize(ERC721BalanceTierConfig memory config_)\n        external\n        initializer\n    {\n        initializeValueTier(config_.tierValues);\n        erc721 = config_.erc721;\n        emit Initialize(msg.sender, address(config_.erc721));\n    }\n\n    /// Report simply truncates all tiers above the highest value held.\n    /// @inheritdoc ITier\n    function report(address account_) public view override returns (uint256) {\n        return\n            TierReport.truncateTiersAbove(\n                TierConstants.ALWAYS,\n                valueToTier(tierValues(), erc721.balanceOf(account_))\n            );\n    }\n}\n"
    },
    "contracts/tier/ValueTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {ITier} from \"./ITier.sol\";\nimport \"./libraries/TierConstants.sol\";\n\nimport \"../sstore2/SSTORE2.sol\";\n\n/// @title ValueTier\n///\n/// @dev A contract that is `ValueTier` expects to derive tiers from explicit\n/// values. For example an address must send or hold an amount of something to\n/// reach a given tier.\n/// Anything with predefined values that map to tiers can be a `ValueTier`.\n///\n/// Note that `ValueTier` does NOT implement `ITier`.\n/// `ValueTier` does include state however, to track the `tierValues` so is not\n/// a library.\ncontract ValueTier {\n    /// TODO: Typescript errors on uint256[8] so can't include tierValues here.\n    /// @param sender The `msg.sender` initializing value tier.\n    /// @param pointer Pointer to the uint256[8] values.\n    event InitializeValueTier(\n        address sender,\n        address pointer\n    );\n\n    /// Pointer to the uint256[8] values.\n    address private tierValuesPointer;\n\n    /// Set the `tierValues` on construction to be referenced immutably.\n    function initializeValueTier(uint256[8] memory tierValues_) internal {\n        // Reinitialization is a bug.\n        assert(tierValuesPointer == address(0));\n        unchecked {\n            uint256 accumulator_ = 0;\n            for (uint256 i_ = 0; i_ < 8; i_++) {\n                require(\n                    tierValues_[i_] >= accumulator_,\n                    \"OUT_OF_ORDER_TIER_VALUES\"\n                );\n                accumulator_ = tierValues_[i_];\n            }\n        }\n        address tierValuesPointer_ = SSTORE2.write(abi.encode(tierValues_));\n        emit InitializeValueTier(msg.sender, tierValuesPointer_);\n        tierValuesPointer = tierValuesPointer_;\n    }\n\n    /// Complements the default solidity accessor for `tierValues`.\n    /// Returns all the values in a list rather than requiring an index be\n    /// specified.\n    /// @return tierValues_ The immutable `tierValues`.\n    function tierValues() public view returns (uint256[8] memory tierValues_) {\n        return abi.decode(SSTORE2.read(tierValuesPointer), (uint256[8]));\n    }\n\n    /// Converts a Tier to the minimum value it requires.\n    /// tier 0 is always value 0 as it is the fallback.\n    /// @param tier_ The Tier to convert to a value.\n    function tierToValue(uint256[8] memory tierValues_, uint256 tier_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return tier_ > TierConstants.TIER_ZERO ? tierValues_[tier_ - 1] : 0;\n        }\n    }\n\n    /// Converts a value to the maximum Tier it qualifies for.\n    /// @param value_ The value to convert to a tier.\n    function valueToTier(uint256[8] memory tierValues_, uint256 value_)\n        internal\n        pure\n        returns (uint256)\n    {\n        for (uint256 i_ = 0; i_ < TierConstants.MAX_TIER; i_++) {\n            if (value_ < tierValues_[i_]) {\n                return i_;\n            }\n        }\n        return TierConstants.MAX_TIER;\n    }\n}\n"
    },
    "contracts/tier/ERC20BalanceTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n//solhint-disable-next-line max-line-length\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {TierConstants} from \"./libraries/TierConstants.sol\";\nimport {ValueTier} from \"./ValueTier.sol\";\nimport {ITier} from \"./ITier.sol\";\nimport \"./ReadOnlyTier.sol\";\n\n/// Constructor config for ERC20BalanceTier.\n/// @param erc20 The erc20 token contract to check the balance of at `report`\n/// time.\n/// @param tierValues 8 values corresponding to minimum erc20 balances for\n/// tier 1 through tier 8.\nstruct ERC20BalanceTierConfig {\n    IERC20 erc20;\n    uint256[8] tierValues;\n}\n\n/// @title ERC20BalanceTier\n/// @notice `ERC20BalanceTier` inherits from `ReadOnlyTier`.\n///\n/// There is no internal accounting, the balance tier simply reads the balance\n/// of the user whenever `report` is called.\n///\n/// `setTier` always fails.\n///\n/// There is no historical information so each tier will either be `0x00000000`\n/// or `0xFFFFFFFF` for the block number.\n///\n/// @dev The `ERC20BalanceTier` simply checks the current balance of an erc20\n/// against tier values. As the current balance is always read from the erc20\n/// contract directly there is no historical block data.\n/// All tiers held at the current value will be `0x00000000` and tiers not held\n/// will be `0xFFFFFFFF`.\n/// `setTier` will error as this contract has no ability to write to the erc20\n/// contract state.\n///\n/// IMPORTANT: Simply checking the balance of an unrestricted token is\n/// typically INSECURE. If users can transfer tokens freely they can use it\n/// to exploit claim, access, voting, etc. by serially granting many accounts\n/// some tier simply by transferring or flash-loaning tokens underneath.\n/// `ERC20TransferTier` can be used as a partial solution to this problem.\n/// See https://github.com/beehive-innovation/rain-protocol/issues/252\n///\n/// Balance tiers are useful for:\n/// - Claim contracts that don't require backdated tier holding\n///   (be wary of griefing!).\n/// - Assets that cannot be transferred, so are not eligible for\n///   `ERC20TransferTier`.\n/// - Lightweight, realtime checks that encumber the tiered address\n///   as little as possible.\ncontract ERC20BalanceTier is ReadOnlyTier, ValueTier, Initializable {\n    /// Result of initialize.\n    /// @param sender `msg.sender` of the initialize.\n    /// @param erc20 erc20 token to check balance of.\n    event Initialize(address sender, address erc20);\n\n    /// The erc20 to check balances against.\n    IERC20 internal erc20;\n\n    /// @param config_ Initialize config.\n    function initialize(ERC20BalanceTierConfig memory config_)\n        external\n        initializer\n    {\n        initializeValueTier(config_.tierValues);\n        erc20 = config_.erc20;\n        emit Initialize(msg.sender, address(config_.erc20));\n    }\n\n    /// Report simply truncates all tiers above the highest value held.\n    /// @inheritdoc ITier\n    function report(address account_) public view override returns (uint256) {\n        return\n            TierReport.truncateTiersAbove(\n                TierConstants.ALWAYS,\n                valueToTier(tierValues(), erc20.balanceOf(account_))\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/tier/ERC20BalanceTierFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport \"./ERC20BalanceTier.sol\";\n\n/// @title ERC20BalanceTierFactory\n/// @notice Factory for creating and deploying `ERC20BalanceTier` contracts.\ncontract ERC20BalanceTierFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new ERC20BalanceTier());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        ERC20BalanceTierConfig memory config_ = abi.decode(\n            data_,\n            (ERC20BalanceTierConfig)\n        );\n        address clone_ = Clones.clone(implementation);\n        ERC20BalanceTier(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with `ERC20BalanceTierConfig`.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ Constructor config for `ERC20BalanceTier`.\n    /// @return New `ERC20BalanceTier` child contract address.\n    function createChildTyped(ERC20BalanceTierConfig calldata config_)\n        external\n        returns (ERC20BalanceTier)\n    {\n        return ERC20BalanceTier(this.createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/tier/ReadWriteTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {ITier} from \"./ITier.sol\";\nimport \"./libraries/TierConstants.sol\";\nimport \"./libraries/TierReport.sol\";\n\n/// @title ReadWriteTier\n/// @notice `ReadWriteTier` is a base contract that other contracts are\n/// expected to inherit.\n///\n/// It handles all the internal accounting and state changes for `report`\n/// and `setTier`.\n///\n/// It calls an `_afterSetTier` hook that inheriting contracts can override to\n/// enforce tier requirements.\n///\n/// @dev ReadWriteTier can `setTier` in addition to generating reports.\n/// When `setTier` is called it automatically sets the current blocks in the\n/// report for the new tiers. Lost tiers are scrubbed from the report as tiered\n/// addresses move down the tiers.\ncontract ReadWriteTier is ITier {\n    /// account => reports\n    mapping(address => uint256) private reports;\n\n    /// Either fetch the report from storage or return UNINITIALIZED.\n    /// @inheritdoc ITier\n    function report(address account_)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        // Inequality here to silence slither warnings.\n        return\n            reports[account_] > 0\n                ? reports[account_]\n                : TierConstants.NEVER_REPORT;\n    }\n\n    /// Errors if the user attempts to return to the ZERO tier.\n    /// Updates the report from `report` using default `TierReport` logic.\n    /// Calls `_afterSetTier` that inheriting contracts SHOULD\n    /// override to enforce status requirements.\n    /// Emits `TierChange` event.\n    /// @inheritdoc ITier\n    function setTier(\n        address account_,\n        uint256 endTier_,\n        bytes calldata data_\n    ) external virtual override {\n        // The user must move to at least tier 1.\n        // The tier 0 status is reserved for users that have never\n        // interacted with the contract.\n        require(endTier_ > 0, \"SET_ZERO_TIER\");\n\n        uint256 report_ = report(account_);\n\n        uint256 startTier_ = TierReport.tierAtBlockFromReport(\n            report_,\n            block.number\n        );\n\n        reports[account_] = TierReport.updateReportWithTierAtBlock(\n            report_,\n            startTier_,\n            endTier_,\n            block.number\n        );\n\n        // Emit this event for ITier.\n        emit TierChange(msg.sender, account_, startTier_, endTier_, data_);\n\n        // Call the `_afterSetTier` hook to allow inheriting contracts to\n        // enforce requirements.\n        // The inheriting contract MUST `require` or otherwise enforce its\n        // needs to rollback a bad status change.\n        _afterSetTier(account_, startTier_, endTier_, data_);\n    }\n\n    /// Inheriting contracts SHOULD override this to enforce requirements.\n    ///\n    /// All the internal accounting and state changes are complete at\n    /// this point.\n    /// Use `require` to enforce additional requirements for tier changes.\n    ///\n    /// @param account_ The account with the new tier.\n    /// @param startTier_ The tier the account had before this update.\n    /// @param endTier_ The tier the account will have after this update.\n    /// @param data_ Additional arbitrary data to inform update requirements.\n    function _afterSetTier(\n        address account_,\n        uint256 startTier_,\n        uint256 endTier_,\n        bytes calldata data_\n    ) internal virtual {} // solhint-disable-line no-empty-blocks\n}\n"
    },
    "contracts/tier/ERC20TransferTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n//solhint-disable-next-line max-line-length\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../math/SaturatingMath.sol\";\nimport {TierReport} from \"./libraries/TierReport.sol\";\nimport {ValueTier} from \"./ValueTier.sol\";\nimport \"./ReadWriteTier.sol\";\n\n/// @param erc20_ The erc20 token contract to transfer balances\n/// from/to during `setTier`.\n/// @param tierValues_ 8 values corresponding to minimum erc20\n/// balances for tiers ONE through EIGHT.\nstruct ERC20TransferTierConfig {\n    IERC20 erc20;\n    uint256[8] tierValues;\n}\n\n/// @title ERC20TransferTier\n/// @notice `ERC20TransferTier` inherits from `ReadWriteTier`.\n///\n/// In addition to the standard accounting it requires that users transfer\n/// erc20 tokens to achieve a tier.\n///\n/// Data is ignored, the only requirement is that the user has approved\n/// sufficient balance to gain the next tier.\n///\n/// To avoid griefing attacks where accounts remove tiers from arbitrary third\n/// parties, we `require(msg.sender == account_);` when a tier is removed.\n/// When a tier is added the `msg.sender` is responsible for payment.\n///\n/// The 8 values for gainable tiers and erc20 contract must be set upon\n/// construction and are immutable.\n///\n/// The `_afterSetTier` simply transfers the diff between the start/end tier\n/// to/from the user as required.\n///\n/// If a user sends erc20 tokens directly to the contract without calling\n/// `setTier` the FUNDS ARE LOST.\n///\n/// @dev The `ERC20TransferTier` takes ownership of an erc20 balance by\n/// transferring erc20 token to itself. The `msg.sender` must pay the\n/// difference on upgrade; the tiered address receives refunds on downgrade.\n/// This allows users to \"gift\" tiers to each other.\n/// As the transfer is a state changing event we can track historical block\n/// times.\n/// As the tiered address moves up/down tiers it sends/receives the value\n/// difference between its current tier only.\n///\n/// The user is required to preapprove enough erc20 to cover the tier change or\n/// they will fail and lose gas.\n///\n/// `ERC20TransferTier` is useful for:\n/// - Claims that rely on historical holdings so the tiered address\n///   cannot simply \"flash claim\"\n/// - Token demand and lockup where liquidity (trading) is a secondary goal\n/// - erc20 tokens without additonal restrictions on transfer\ncontract ERC20TransferTier is ReadWriteTier, ValueTier, Initializable {\n    using SafeERC20 for IERC20;\n    using SaturatingMath for uint256;\n\n    /// Result of initialize.\n    /// @param sender `msg.sender` of the initialize.\n    /// @param erc20 erc20 to transfer.\n    event Initialize(\n        address sender,\n        address erc20\n    );\n\n    /// The erc20 to transfer balances of.\n    IERC20 internal erc20;\n\n    /// @param config_ Constructor config.\n    function initialize(ERC20TransferTierConfig memory config_)\n        external\n        initializer\n    {\n        initializeValueTier(config_.tierValues);\n        erc20 = config_.erc20;\n        emit Initialize(msg.sender, address(config_.erc20));\n    }\n\n    /// Transfers balances of erc20 from/to the tiered account according to the\n    /// difference in values. Any failure to transfer in/out will rollback the\n    /// tier change. The tiered account must ensure sufficient approvals before\n    /// attempting to set a new tier.\n    /// The `msg.sender` is responsible for paying the token cost of a tier\n    /// increase.\n    /// The tiered account is always the recipient of a refund on a tier\n    /// decrease.\n    /// @inheritdoc ReadWriteTier\n    function _afterSetTier(\n        address account_,\n        uint256 startTier_,\n        uint256 endTier_,\n        bytes calldata\n    ) internal override {\n        // As _anyone_ can call `setTier` we require that `msg.sender` and\n        // `account_` are the same if the end tier is not an improvement.\n        // Anyone can increase anyone else's tier as the `msg.sender` is\n        // responsible to pay the difference.\n        if (endTier_ <= startTier_) {\n            require(msg.sender == account_, \"DELEGATED_TIER_LOSS\");\n        }\n\n        uint256[8] memory tierValues_ = tierValues();\n\n        // Handle the erc20 transfer.\n        // Convert the start tier to an erc20 amount.\n        uint256 startValue_ = tierToValue(tierValues_, startTier_);\n        // Convert the end tier to an erc20 amount.\n        uint256 endValue_ = tierToValue(tierValues_, endTier_);\n\n        unchecked {\n            // Short circuit if the values are the same for both tiers.\n            if (endValue_ == startValue_) {\n                return;\n            }\n            if (endValue_ > startValue_) {\n                // Going up, take ownership of erc20 from the `msg.sender`.\n                erc20.safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    endValue_ - startValue_\n                );\n            } else {\n                // Going down, process a refund for the tiered account.\n                // Guaranteed to be `msg.sender` for a tier loss (see above) and\n                // using `msg.sender` is cheaper gas than using `account_`.\n                erc20.safeTransfer(msg.sender, startValue_ - endValue_);\n            }\n        }\n    }\n}\n"
    },
    "contracts/tier/ERC20TransferTierFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport \"./ERC20TransferTier.sol\";\n\n/// @title ERC20TransferTierFactory\n/// @notice Factory for creating and deploying `ERC20TransferTier` contracts.\ncontract ERC20TransferTierFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new ERC20TransferTier());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        ERC20TransferTierConfig memory config_ = abi.decode(\n            data_,\n            (ERC20TransferTierConfig)\n        );\n        address clone_ = Clones.clone(implementation);\n        ERC20TransferTier(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with `ERC20TransferTierConfig`.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ Constructor config for `ERC20TransferTier`.\n    /// @return New `ERC20TransferTier` child contract address.\n    function createChildTyped(ERC20TransferTierConfig calldata config_)\n        external\n        returns (ERC20TransferTier)\n    {\n        return ERC20TransferTier(this.createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/tier/CombineTierFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {Factory} from \"../factory/Factory.sol\";\nimport {CombineTier} from \"./CombineTier.sol\";\nimport {StateConfig} from \"../vm/libraries/VMState.sol\";\n\n/// @title CombineTierFactory\n/// @notice Factory for creating and deploying `CombineTier` contracts.\ncontract CombineTierFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new CombineTier());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        StateConfig memory config_ = abi.decode(data_, (StateConfig));\n        address clone_ = Clones.clone(implementation);\n        CombineTier(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with Source.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `ImmutableSourceConfig` of the `CombineTier` logic.\n    /// @return New `CombineTier` child contract address.\n    function createChildTyped(StateConfig calldata config_)\n        external\n        returns (CombineTier)\n    {\n        return CombineTier(this.createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/tier/CombineTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport {RainVM, State} from \"../vm/RainVM.sol\";\nimport {VMState, StateConfig} from \"../vm/libraries/VMState.sol\";\n// solhint-disable-next-line max-line-length\nimport {AllStandardOps, ALL_STANDARD_OPS_START, ALL_STANDARD_OPS_LENGTH} from \"../vm/ops/AllStandardOps.sol\";\nimport {TierwiseCombine} from \"./libraries/TierwiseCombine.sol\";\nimport {ReadOnlyTier, ITier} from \"./ReadOnlyTier.sol\";\n\n/// @title CombineTier\n/// @notice Implements `ReadOnlyTier` over RainVM. Allows combining the reports\n/// from any other `ITier` contracts referenced in the `ImmutableSource` set at\n/// construction.\n/// The value at the top of the stack after executing the rain script will be\n/// used as the return of `report`.\ncontract CombineTier is ReadOnlyTier, RainVM, VMState, Initializable {\n    /// @dev local opcode to put tier report account on the stack.\n    uint256 private constant OPCODE_ACCOUNT = 0;\n    /// @dev local opcodes length.\n    uint256 internal constant LOCAL_OPS_LENGTH = 1;\n\n    /// @dev local offset for combine tier ops.\n    uint256 private immutable localOpsStart;\n\n    address private vmStatePointer;\n\n    constructor() {\n        localOpsStart = ALL_STANDARD_OPS_START + ALL_STANDARD_OPS_LENGTH;\n    }\n\n    /// @param config_ The StateConfig will be deployed as a pointer under\n    /// `vmStatePointer`.\n    function initialize(StateConfig memory config_) external initializer {\n        vmStatePointer = _snapshot(_newState(config_));\n    }\n\n    /// @inheritdoc RainVM\n    function applyOp(\n        bytes memory context_,\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view override {\n        unchecked {\n            if (opcode_ < localOpsStart) {\n                AllStandardOps.applyOp(\n                    state_,\n                    opcode_ - ALL_STANDARD_OPS_START,\n                    operand_\n                );\n            } else {\n                opcode_ -= localOpsStart;\n                require(opcode_ < LOCAL_OPS_LENGTH, \"MAX_OPCODE\");\n                // There's only one opcode, which stacks the address to report.\n                address account_ = abi.decode(context_, (address));\n                state_.stack[state_.stackIndex] = uint256(\n                    uint160(account_)\n                );\n                state_.stackIndex++;\n            }\n        }\n    }\n\n    /// @inheritdoc ITier\n    function report(address account_)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        State memory state_ = _restore(vmStatePointer);\n        eval(abi.encode(account_), state_, 0);\n        return state_.stack[state_.stackIndex - 1];\n    }\n}\n"
    },
    "contracts/test/SaturatingMathTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity 0.8.10;\n\nimport {SaturatingMath} from \"../math/SaturatingMath.sol\";\n\n/// @title SaturatingMathTest\n/// Thin wrapper around the `SaturatingMath` library for hardhat unit testing.\ncontract SaturatingMathTest {\n    /// Wraps `SaturatingMath.saturatingAdd`.\n    /// Saturating addition.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ + b_ and max uint256.\n    function saturatingAdd(uint256 a_, uint256 b_)\n        external\n        pure\n        returns (uint256)\n    {\n      unchecked {\n        return SaturatingMath.saturatingAdd(a_, b_);\n      }\n    }\n\n    /// Wraps `SaturatingMath.saturatingSub`.\n    /// Saturating subtraction.\n    /// @param a_ Minuend.\n    /// @param b_ Subtrahend.\n    /// @return a_ - b_ if a_ greater than b_, else 0.\n    function saturatingSub(uint256 a_, uint256 b_)\n        external\n        pure\n        returns (uint256)\n    {\n      unchecked {\n        return SaturatingMath.saturatingSub(a_, b_);\n      }\n    }\n\n    /// Wraps `SaturatingMath.saturatingMul`.\n    /// Saturating multiplication.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ * b_ and max uint256.\n    function saturatingMul(uint256 a_, uint256 b_)\n        external\n        pure\n        returns (uint256)\n    {\n      unchecked {\n        return SaturatingMath.saturatingMul(a_, b_);\n      }\n    }\n}\n"
    },
    "contracts/test/CalculatorTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {RainVM, State, RAIN_VM_OPS_LENGTH} from \"../vm/RainVM.sol\";\nimport {VMState, StateConfig} from \"../vm/libraries/VMState.sol\";\n// solhint-disable-next-line max-line-length\nimport {EVMConstantOps, EVM_CONSTANT_OPS_LENGTH} from \"../vm/ops/evm/EVMConstantOps.sol\";\nimport {MathOps} from \"../vm/ops/math/MathOps.sol\";\n\n/// @title CalculatorTest\n/// Simple calculator that exposes basic math ops and block ops for testing.\ncontract CalculatorTest is RainVM, VMState {\n    uint256 private immutable evmConstantOpsStart;\n    uint256 private immutable mathOpsStart;\n    address private immutable vmStatePointer;\n\n    constructor(StateConfig memory config_) {\n        /// These local opcode offsets are calculated as immutable but are\n        /// really just compile time constants. They only depend on the\n        /// imported libraries and contracts. These are calculated at\n        /// construction to future-proof against underlying ops being\n        /// added/removed and potentially breaking the offsets here.\n        evmConstantOpsStart = RAIN_VM_OPS_LENGTH;\n        mathOpsStart = evmConstantOpsStart + EVM_CONSTANT_OPS_LENGTH;\n        vmStatePointer = _snapshot(_newState(config_));\n    }\n\n    /// @inheritdoc RainVM\n    function applyOp(\n        bytes memory,\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view override {\n        unchecked {\n            if (opcode_ < mathOpsStart) {\n                EVMConstantOps.applyOp(\n                    state_,\n                    opcode_ - evmConstantOpsStart,\n                    operand_\n                );\n            } else {\n                MathOps.applyOp(\n                    state_,\n                    opcode_ - mathOpsStart,\n                    operand_\n                );\n            }\n        }\n    }\n\n    /// Wraps `runState` and returns top of stack.\n    /// @return top of `runState` stack.\n    function run() external view returns (uint256) {\n        State memory state_ = runState();\n        return state_.stack[state_.stackIndex - 1];\n    }\n\n    /// Runs `eval` and returns full state.\n    /// @return `State` after running own immutable source.\n    function runState() public view returns (State memory) {\n        State memory state_ = _restore(vmStatePointer);\n        eval(\"\", state_, 0);\n        return state_;\n    }\n}\n"
    },
    "contracts/test/ops/TokenOpsTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Cooldown} from \"../../cooldown/Cooldown.sol\";\n\nimport \"../../vm/RainVM.sol\";\nimport {IERC20Ops, IERC20_OPS_LENGTH} from \"../../vm/ops/token/IERC20Ops.sol\";\n// solhint-disable-next-line max-line-length\nimport {IERC721Ops, IERC721_OPS_LENGTH} from \"../../vm/ops/token/IERC721Ops.sol\";\n// solhint-disable-next-line max-line-length\nimport {IERC1155Ops, IERC1155_OPS_LENGTH} from \"../../vm/ops/token/IERC1155Ops.sol\";\nimport {VMState, StateConfig} from \"../../vm/libraries/VMState.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\ncontract TokenOpsTest is RainVM, VMState {\n    uint256 private immutable ierc20OpsStart;\n    uint256 private immutable ierc721OpsStart;\n    uint256 private immutable ierc1155OpsStart;\n    address private immutable vmStatePointer;\n\n    constructor(StateConfig memory config_) {\n        ierc20OpsStart = RAIN_VM_OPS_LENGTH;\n        ierc721OpsStart = ierc20OpsStart + IERC20_OPS_LENGTH;\n        ierc1155OpsStart = ierc721OpsStart + IERC721_OPS_LENGTH;\n\n        vmStatePointer = _snapshot(_newState(config_));\n    }\n\n    /// Wraps `runState` and returns top of stack.\n    /// @return top of `runState` stack.\n    function run() external view returns (uint256) {\n        State memory state_ = runState();\n        return state_.stack[state_.stackIndex - 1];\n    }\n\n    /// Wraps `runState` and returns top `length_` values on the stack.\n    /// @return top `length_` values on `runState` stack.\n    function runLength(uint256 length_)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        State memory state_ = runState();\n\n        uint256[] memory stackArray = new uint256[](length_);\n\n        for (uint256 i = 0; i < length_; ++i) {\n            stackArray[i] = state_.stack[state_.stackIndex - length_ + i];\n        }\n\n        return stackArray;\n    }\n\n    /// Runs `eval` and returns full state.\n    /// @return `State` after running own immutable source.\n    function runState() public view returns (State memory) {\n        State memory state_ = _restore(vmStatePointer);\n        eval(\"\", state_, 0);\n        return state_;\n    }\n\n    /// @inheritdoc RainVM\n    function applyOp(\n        bytes memory,\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view override {\n        unchecked {\n            if (opcode_ < ierc721OpsStart) {\n                IERC20Ops.applyOp(state_, opcode_ - ierc20OpsStart, operand_);\n            } else if (opcode_ < ierc1155OpsStart) {\n                IERC721Ops.applyOp(state_, opcode_ - ierc721OpsStart, operand_);\n            } else {\n                IERC1155Ops.applyOp(\n                    state_,\n                    opcode_ - ierc1155OpsStart,\n                    operand_\n                );\n            }\n        }\n    }\n}\n"
    },
    "contracts/cooldown/Cooldown.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title Cooldown\n/// @notice `Cooldown` is a base contract that rate limits functions on\n/// the implementing contract per `msg.sender`.\n///\n/// Each time a function with the `onlyAfterCooldown` modifier is called the\n/// `msg.sender` must wait N blocks before calling any modified function.\n///\n/// This does nothing to prevent sybils who can generate an arbitrary number of\n/// `msg.sender` values in parallel to spam a contract.\n///\n/// `Cooldown` is intended to prevent rapid state cycling to grief a contract,\n/// such as rapidly locking and unlocking a large amount of capital in the\n/// `SeedERC20` contract.\n///\n/// Requiring a lock/deposit of significant economic stake that sybils will not\n/// have access to AND applying a cooldown IS a sybil mitigation. The economic\n/// stake alone is NOT sufficient if gas is cheap as sybils can cycle the same\n/// stake between each other. The cooldown alone is NOT sufficient as many\n/// sybils can be created, each as a new `msg.sender`.\n///\n/// @dev Base for anything that enforces a cooldown delay on functions.\n/// `Cooldown` requires a minimum time in blocks to elapse between actions that\n/// cooldown. The modifier `onlyAfterCooldown` both enforces and triggers the\n/// cooldown. There is a single cooldown across all functions per-contract\n/// so any function call that requires a cooldown will also trigger it for\n/// all other functions.\n///\n/// Cooldown is NOT an effective sybil resistance alone, as the cooldown is\n/// per-address only. It is always possible for many accounts to be created\n/// to spam a contract with dust in parallel.\n/// Cooldown is useful to stop a single account rapidly cycling contract\n/// state in a way that can be disruptive to peers. Cooldown works best when\n/// coupled with economic stake associated with each state change so that\n/// peers must lock capital during the cooldown. `Cooldown` tracks the first\n/// `msg.sender` it sees for a call stack so cooldowns are enforced across\n/// reentrant code. Any function that enforces a cooldown also has reentrancy\n/// protection.\ncontract Cooldown {\n    event CooldownInitialize(address sender, uint256 cooldownDuration);\n    event CooldownTriggered(address caller, uint256 cooldown);\n    /// Time in blocks to restrict access to modified functions.\n    uint256 internal cooldownDuration = 0;\n\n    /// Every caller has its own cooldown, the minimum block that the caller\n    /// call another function sharing the same cooldown state.\n    mapping(address => uint256) private cooldowns;\n    address private caller;\n\n    /// Initialize the cooldown duration.\n    /// The cooldown duration is global to the contract.\n    /// Cooldown duration must be greater than 0.\n    /// Cooldown duration can only be set once.\n    /// @param cooldownDuration_ The global cooldown duration.\n    function initializeCooldown(uint256 cooldownDuration_) internal {\n        require(cooldownDuration_ > 0, \"COOLDOWN_0\");\n        // Reinitialization is a bug.\n        assert(cooldownDuration == 0);\n        cooldownDuration = cooldownDuration_;\n        emit CooldownInitialize(msg.sender, cooldownDuration_);\n    }\n\n    /// Modifies a function to enforce the cooldown for `msg.sender`.\n    /// Saves the original caller so that cooldowns are enforced across\n    /// reentrant code.\n    modifier onlyAfterCooldown() {\n        address caller_ = caller == address(0) ? caller = msg.sender : caller;\n        require(cooldowns[caller_] <= block.number, \"COOLDOWN\");\n        // Every action that requires a cooldown also triggers a cooldown.\n        uint256 cooldown_ = block.number + cooldownDuration;\n        cooldowns[caller_] = cooldown_;\n        emit CooldownTriggered(caller_, cooldown_);\n        _;\n        // Refund as much gas as we can.\n        delete caller;\n    }\n}\n"
    },
    "contracts/test/ops/TierOpsTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../vm/RainVM.sol\";\nimport {TierOps} from \"../../vm/ops/tier/TierOps.sol\";\nimport {VMState, StateConfig} from \"../../vm/libraries/VMState.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\ncontract TierOpsTest is RainVM, VMState {\n    uint256 private immutable tierOpsStart;\n    address private immutable vmStatePointer;\n\n    constructor(StateConfig memory config_) {\n        tierOpsStart = RAIN_VM_OPS_LENGTH;\n\n        vmStatePointer = _snapshot(_newState(config_));\n    }\n\n    /// Wraps `runState` and returns top of stack.\n    /// @return top of `runState` stack.\n    function run() external view returns (uint256) {\n        State memory state_ = runState();\n        return state_.stack[state_.stackIndex - 1];\n    }\n\n    /// Wraps `runState` and returns top `length_` values on the stack.\n    /// @return top `length_` values on `runState` stack.\n    function runLength(uint256 length_)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        State memory state_ = runState();\n\n        uint256[] memory stackArray = new uint256[](length_);\n\n        for (uint256 i = 0; i < length_; ++i) {\n            stackArray[i] = state_.stack[state_.stackIndex - length_ + i];\n        }\n\n        return stackArray;\n    }\n\n    /// Runs `eval` and returns full state.\n    /// @return `State` after running own immutable source.\n    function runState() public view returns (State memory) {\n        State memory state_ = _restore(vmStatePointer);\n        eval(\"\", state_, 0);\n        return state_;\n    }\n\n    /// @inheritdoc RainVM\n    function applyOp(\n        bytes memory,\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view override {\n        unchecked {\n            TierOps.applyOp(state_, opcode_ - tierOpsStart, operand_);\n        }\n    }\n}\n"
    },
    "contracts/sale/Sale.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Cooldown} from \"../cooldown/Cooldown.sol\";\n\nimport \"../math/FixedPointMath.sol\";\nimport \"../vm/RainVM.sol\";\n// solhint-disable-next-line max-line-length\nimport {AllStandardOps, ALL_STANDARD_OPS_START, ALL_STANDARD_OPS_LENGTH} from \"../vm/ops/AllStandardOps.sol\";\nimport {VMState, StateConfig} from \"../vm/libraries/VMState.sol\";\nimport {ERC20Config} from \"../erc20/ERC20Config.sol\";\nimport \"./ISale.sol\";\n//solhint-disable-next-line max-line-length\nimport {RedeemableERC20, RedeemableERC20Config} from \"../redeemableERC20/RedeemableERC20.sol\";\n//solhint-disable-next-line max-line-length\nimport {RedeemableERC20Factory} from \"../redeemableERC20/RedeemableERC20Factory.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/// Everything required to construct a Sale (not initialize).\n/// @param maximumSaleTimeout The sale timeout set in initialize cannot exceed\n/// this. Avoids downstream escrows and similar trapping funds due to sales\n/// that never end, or perhaps never even start.\n/// @param maximumCooldownDuration The cooldown duration set in initialize\n/// cannot exceed this. Avoids the \"no refunds\" situation where someone sets an\n/// infinite cooldown, then accidentally or maliciously the sale ends up in a\n/// state where it cannot end (bad \"can end\" script), leading to trapped funds.\n/// @param redeemableERC20Factory The factory contract that creates redeemable\n/// erc20 tokens that the `Sale` can mint, sell and burn.\nstruct SaleConstructorConfig {\n    uint256 maximumSaleTimeout;\n    uint256 maximumCooldownDuration;\n    RedeemableERC20Factory redeemableERC20Factory;\n}\n\n/// Everything required to configure (initialize) a Sale.\n/// @param canStartStateConfig State config for the script that allows a Sale\n/// to start.\n/// @param canEndStateConfig State config for the script that allows a Sale to\n/// end. IMPORTANT: A Sale can always end if/when its rTKN sells out,\n/// regardless of the result of this script.\n/// @param calculatePriceStateConfig State config for the script that defines\n/// the current price quoted by a Sale.\n/// @param recipient The recipient of the proceeds of a Sale, if/when the Sale\n/// is successful.\n/// @param reserve The reserve token the Sale is deonominated in.\n/// @param saleTimeout The number of blocks before this sale can timeout.\n/// SHOULD be well after the expected end time as a timeout will fail an active\n/// or pending sale regardless of any funds raised.\n/// @param cooldownDuration forwarded to `Cooldown` contract initialization.\n/// @param minimumRaise defines the amount of reserve required to raise that\n/// defines success/fail of the sale. Reaching the minimum raise DOES NOT cause\n/// the raise to end early (unless the \"can end\" script allows it of course).\n/// @param dustSize The minimum amount of rTKN that must remain in the Sale\n/// contract unless it is all purchased, clearing the raise to 0 stock and thus\n/// ending the raise.\nstruct SaleConfig {\n    StateConfig canStartStateConfig;\n    StateConfig canEndStateConfig;\n    StateConfig calculatePriceStateConfig;\n    address recipient;\n    IERC20 reserve;\n    uint256 saleTimeout;\n    uint256 cooldownDuration;\n    uint256 minimumRaise;\n    uint256 dustSize;\n}\n\n/// Forwarded config to RedeemableERC20 initialization.\nstruct SaleRedeemableERC20Config {\n    ERC20Config erc20Config;\n    address tier;\n    uint256 minimumTier;\n    address distributionEndForwardingAddress;\n}\n\n/// Defines a request to buy rTKN from an active sale.\n/// @param feeRecipient Optional recipient to send fees to. Intended to be a\n/// \"tip\" for the front-end client that the buyer is using to fund development,\n/// infrastructure, etc.\n/// @param fee Size of the optional fee to send to the recipient. Denominated\n/// in the reserve token of the `Sale` contract.\n/// @param minimumUnits The minimum size of the buy. If the sale is close to\n/// selling out then the buyer may not fulfill their entire order, so this sets\n/// the minimum units the buyer is willing to accept for their order. MAY be 0\n/// if the buyer is willing to accept any amount of tokens.\n/// @param desiredUnits The maximum and desired size of the buy. The sale will\n/// always attempt to fulfill the buy order to the maximum rTKN amount possible\n/// according to the unsold stock on hand. Typically all the desired units will\n/// clear but as the sale runs low on stock it may not be able to.\n/// @param maximumPrice As the price quoted by the sale is a programmable curve\n/// it may change rapidly between when the buyer submitted a transaction to the\n/// mempool and when it is mined. Setting a maximum price is akin to setting\n/// slippage on a traditional AMM. The transaction will revert if the sale\n/// price exceeds the buyer's maximum.\nstruct BuyConfig {\n    address feeRecipient;\n    uint256 fee;\n    uint256 minimumUnits;\n    uint256 desiredUnits;\n    uint256 maximumPrice;\n}\n\n/// Defines the receipt for a successful buy.\n/// The receipt includes the final units and price paid for rTKN, which are\n/// known as possible ranges in `BuyConfig`.\n/// Importantly a receipt allows a buy to be reversed for as long as the sale\n/// is active, subject to buyer cooldowns as per `Cooldown`. In the case of a\n/// finalized but failed sale, all buyers can immediately process refunds for\n/// their receipts without cooldown. As the receipt is crucial to the refund\n/// process every receipt is logged so it can be indexed and never lost, and\n/// unique IDs bound to the buyer in onchain storage prevent receipts from\n/// being used in a fraudulent context. The entire receipt including the id is\n/// hashed in the storage mapping that binds it to a buyer so that a buyer\n/// cannot change the receipt offchain to claim fraudulent refunds.\n/// Front-end fees are also tracked and refunded for each receipt, to prevent\n/// front end clients from gaming/abusing sale contracts.\n/// @param id Every receipt is assigned a sequential ID to ensure uniqueness\n/// across all receipts.\n/// @param feeRecipient as per `BuyConfig`.\n/// @param fee as per `BuyConfig`.\n/// @param units number of rTKN bought and refundable.\n/// @param price price paid per unit denominated and refundable in reserve.\nstruct Receipt {\n    uint256 id;\n    address feeRecipient;\n    uint256 fee;\n    uint256 units;\n    uint256 price;\n}\n\n// solhint-disable-next-line max-states-count\ncontract Sale is\n    Initializable,\n    Cooldown,\n    RainVM,\n    VMState,\n    ISale,\n    ReentrancyGuard\n{\n    using Math for uint256;\n    using FixedPointMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// Contract is constructing.\n    /// @param sender `msg.sender` of the contract deployer.\n    event Construct(address sender, SaleConstructorConfig config);\n    /// Contract is initializing (being cloned by factory).\n    /// @param sender `msg.sender` of the contract initializer (cloner).\n    /// @param config All initialization config passed by the sender.\n    /// @param token The freshly deployed and minted rTKN for the sale.\n    event Initialize(address sender, SaleConfig config, address token);\n    /// Sale is started (moved to active sale state).\n    /// @param sender `msg.sender` that started the sale.\n    event Start(address sender);\n    /// Sale has ended (moved to success/fail sale state).\n    /// @param sender `msg.sender` that ended the sale.\n    /// @param saleStatus The final success/fail state of the sale.\n    event End(address sender, SaleStatus saleStatus);\n    /// Sale has failed due to a timeout (failed to even start/end).\n    /// @param sender `msg.sender` that timed out the sale.\n    event Timeout(address sender);\n    /// rTKN being bought.\n    /// Importantly includes the receipt that sender can use to apply for a\n    /// refund later if they wish.\n    /// @param sender `msg.sender` buying rTKN.\n    /// @param config All buy config passed by the sender.\n    /// @param receipt The purchase receipt, can be used to claim refunds.\n    event Buy(address sender, BuyConfig config, Receipt receipt);\n    /// rTKN being refunded.\n    /// Includes the receipt used to justify the refund.\n    event Refund(address sender, Receipt receipt);\n\n    /// @dev local opcode to stack remaining rTKN units.\n    uint256 private constant OPCODE_REMAINING_UNITS = 0;\n    /// @dev local opcode to stack total reserve taken in so far.\n    uint256 private constant OPCODE_TOTAL_RESERVE_IN = 1;\n    /// @dev local opcode to stack the rTKN units/amount of the current buy.\n    uint256 private constant OPCODE_CURRENT_BUY_UNITS = 2;\n    /// @dev local opcode to stack the address of the rTKN.\n    uint256 private constant OPCODE_TOKEN_ADDRESS = 3;\n    /// @dev local opcode to stack the address of the reserve token.\n    uint256 private constant OPCODE_RESERVE_ADDRESS = 4;\n    /// @dev local opcodes length.\n    uint256 internal constant LOCAL_OPS_LENGTH = 5;\n\n    /// @dev local offset for local ops.\n    uint256 private immutable localOpsStart;\n    /// @dev the saleTimeout cannot exceed this. Prevents downstream contracts\n    /// that require a finalization such as escrows from getting permanently\n    /// stuck in a pending or active status due to buggy scripts.\n    uint256 private immutable maximumSaleTimeout;\n    /// @dev the cooldown duration cannot exceed this. Prevents \"no refunds\" in\n    /// a raise that never ends. Configured at the factory level upon deploy.\n    uint256 private immutable maximumCooldownDuration;\n\n    /// Factory responsible for minting rTKN.\n    RedeemableERC20Factory private immutable redeemableERC20Factory;\n    /// Minted rTKN for each sale.\n    /// Exposed via. `ISale.token()`.\n    RedeemableERC20 private _token;\n\n    /// @dev as per `SaleConfig`.\n    address private recipient;\n    /// @dev as per `SaleConfig`.\n    address private canStartStatePointer;\n    /// @dev as per `SaleConfig`.\n    address private canEndStatePointer;\n    /// @dev as per `SaleConfig`.\n    address private calculatePriceStatePointer;\n    /// @dev as per `SaleConfig`.\n    uint256 private minimumRaise;\n    /// @dev as per `SaleConfig`.\n    uint256 private dustSize;\n    /// @dev as per `SaleConfig`.\n    /// Exposed via. `ISale.reserve()`.\n    IERC20 private _reserve;\n\n    /// @dev the current sale status exposed as `ISale.saleStatus`.\n    SaleStatus private _saleStatus;\n    /// @dev the current sale can always end in failure at this block even if\n    /// it did not start. Provided it did not already end of course.\n    uint256 private saleTimeout;\n\n    /// @dev remaining rTKN units to sell. MAY NOT be the rTKN balance of the\n    /// Sale contract if rTKN has been sent directly to the sale contract\n    /// outside the standard buy/refund loop.\n    uint256 private remainingUnits;\n    /// @dev total reserve taken in to the sale contract via. buys. Does NOT\n    /// include any reserve sent directly to the sale contract outside the\n    /// standard buy/refund loop.\n    uint256 private totalReserveIn;\n\n    /// @dev Binding buyers to receipt hashes to maybe a non-zero value.\n    /// A receipt will only be honoured if the mapping resolves to non-zero.\n    /// The receipt hashing ensures that receipts cannot be manipulated before\n    /// redemption. Each mapping is deleted if/when receipt is used for refund.\n    /// Buyer => keccak receipt => exists (1+ or 0).\n    mapping(address => mapping(bytes32 => uint256)) private receipts;\n    /// @dev simple incremental counter to keep all receipts unique so that\n    /// receipt hashes bound to buyers never collide.\n    uint256 private nextReceiptId;\n\n    /// @dev Tracks combined fees per recipient to be claimed if/when a sale\n    /// is successful.\n    /// Fee recipient => unclaimed fees.\n    mapping(address => uint256) private fees;\n\n    constructor(SaleConstructorConfig memory config_) {\n        localOpsStart = ALL_STANDARD_OPS_START + ALL_STANDARD_OPS_LENGTH;\n\n        maximumSaleTimeout = config_.maximumSaleTimeout;\n        maximumCooldownDuration = config_.maximumCooldownDuration;\n\n        redeemableERC20Factory = config_.redeemableERC20Factory;\n\n        emit Construct(msg.sender, config_);\n    }\n\n    function initialize(\n        SaleConfig memory config_,\n        SaleRedeemableERC20Config memory saleRedeemableERC20Config_\n    ) external initializer {\n        require(\n            config_.cooldownDuration <= maximumCooldownDuration,\n            \"MAX_COOLDOWN\"\n        );\n        initializeCooldown(config_.cooldownDuration);\n\n        require(config_.saleTimeout <= maximumSaleTimeout, \"MAX_TIMEOUT\");\n        saleTimeout = block.number + config_.saleTimeout;\n\n        // 0 minimum raise is ambiguous as to how it should be handled. It\n        // literally means \"the raise succeeds without any trades\", which\n        // doesn't have a clear way to move funds around as there are no\n        // recipients of potentially escrowed or redeemable funds. There needs\n        // to be at least 1 reserve token paid from 1 buyer in order to\n        // meaningfully process success logic.\n        require(config_.minimumRaise > 0, \"MIN_RAISE_0\");\n        minimumRaise = config_.minimumRaise;\n\n        canStartStatePointer = _snapshot(\n            _newState(config_.canStartStateConfig)\n        );\n        canEndStatePointer = _snapshot(_newState(config_.canEndStateConfig));\n        calculatePriceStatePointer = _snapshot(\n            _newState(config_.calculatePriceStateConfig)\n        );\n        recipient = config_.recipient;\n\n        dustSize = config_.dustSize;\n\n        // just making this explicit during initialization in case it ever\n        // takes a nonzero value somehow due to refactor.\n        _saleStatus = SaleStatus.Pending;\n\n        _reserve = config_.reserve;\n\n        // The distributor of the rTKN is always set to the sale contract.\n        // It is an error for the deployer to attempt to set the distributor.\n        require(\n            saleRedeemableERC20Config_.erc20Config.distributor == address(0),\n            \"DISTRIBUTOR_SET\"\n        );\n        saleRedeemableERC20Config_.erc20Config.distributor = address(this);\n\n        remainingUnits = saleRedeemableERC20Config_.erc20Config.initialSupply;\n\n        RedeemableERC20 token_ = RedeemableERC20(\n            redeemableERC20Factory.createChild(\n                abi.encode(\n                    RedeemableERC20Config(\n                        address(config_.reserve),\n                        saleRedeemableERC20Config_.erc20Config,\n                        saleRedeemableERC20Config_.tier,\n                        saleRedeemableERC20Config_.minimumTier,\n                        saleRedeemableERC20Config_\n                            .distributionEndForwardingAddress\n                    )\n                )\n            )\n        );\n        _token = token_;\n\n        emit Initialize(msg.sender, config_, address(token_));\n    }\n\n    /// @inheritdoc ISale\n    function token() external view returns (address) {\n        return address(_token);\n    }\n\n    /// @inheritdoc ISale\n    function reserve() external view returns (address) {\n        return address(_reserve);\n    }\n\n    /// @inheritdoc ISale\n    function saleStatus() external view returns (SaleStatus) {\n        return _saleStatus;\n    }\n\n    /// Can the sale start?\n    /// Evals `canStartStatePointer` to a boolean that determines whether the\n    /// sale can start (move from pending to active). Buying from and ending\n    /// the sale will both always fail if the sale never started.\n    /// The sale can ONLY start if it is currently in pending status.\n    function canStart() public view returns (bool) {\n        // Only a pending sale can start. Starting a sale more than once would\n        // always be a bug.\n        if (_saleStatus == SaleStatus.Pending) {\n            State memory state_ = _restore(canStartStatePointer);\n            eval(\"\", state_, 0);\n            return state_.stack[state_.stackIndex - 1] > 0;\n        } else {\n            return false;\n        }\n    }\n\n    /// Can the sale end?\n    /// Evals `canEndStatePointer` to a boolean that determines whether the\n    /// sale can end (move from active to success/fail). Buying will fail if\n    /// the sale has ended.\n    /// If the sale is out of rTKN stock it can ALWAYS end and in this case\n    /// will NOT eval the \"can end\" script.\n    /// The sale can ONLY end if it is currently in active status.\n    function canEnd() public view returns (bool) {\n        // Only an active sale can end. Ending an ended or pending sale would\n        // always be a bug.\n        if (_saleStatus == SaleStatus.Active) {\n            // It is always possible to end an out of stock sale because at\n            // this point the only further buys that can happen are after a\n            // refund, and it makes no sense that someone would refund at a low\n            // price to buy at a high price. Therefore we should end the sale\n            // and tally the final result as soon as we sell out.\n            if (remainingUnits < 1) {\n                return true;\n            }\n            // The raise is active and still has stock remaining so we delegate\n            // to the appropriate script for an answer.\n            else {\n                State memory state_ = _restore(canEndStatePointer);\n                eval(\"\", state_, 0);\n                return state_.stack[state_.stackIndex - 1] > 0;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /// Calculates the current reserve price quoted for 1 unit of rTKN.\n    /// Used internally to process `buy`.\n    /// @param units_ Amount of rTKN to quote a price for, will be available to\n    /// the price script from OPCODE_CURRENT_BUY_UNITS.\n    function calculatePrice(uint256 units_) public view returns (uint256) {\n        State memory state_ = _restore(calculatePriceStatePointer);\n        eval(abi.encode(units_), state_, 0);\n\n        return state_.stack[state_.stackIndex - 1];\n    }\n\n    /// Start the sale (move from pending to active).\n    /// `canStart` MUST return true.\n    function start() external {\n        require(canStart(), \"CANT_START\");\n        _saleStatus = SaleStatus.Active;\n        emit Start(msg.sender);\n    }\n\n    /// End the sale (move from active to success or fail).\n    /// `canEnd` MUST return true.\n    function end() public {\n        require(canEnd(), \"CANT_END\");\n\n        bool success_ = totalReserveIn >= minimumRaise;\n        SaleStatus endStatus_ = success_ ? SaleStatus.Success : SaleStatus.Fail;\n\n        remainingUnits = 0;\n        _saleStatus = endStatus_;\n        emit End(msg.sender, endStatus_);\n        _token.endDistribution(address(this));\n\n        // Only send reserve to recipient if the raise is a success.\n        // If the raise is NOT a success then everyone can refund their reserve\n        // deposited individually.\n        if (success_) {\n            _reserve.safeTransfer(recipient, totalReserveIn);\n        }\n    }\n\n    /// Timeout the sale (move from pending or active to fail).\n    /// The ONLY condition for a timeout is that the `saleTimeout` block set\n    /// during initialize is in the past. This means that regardless of what\n    /// happens re: starting, ending, buying, etc. if the sale does NOT manage\n    /// to unambiguously end by the timeout block then it can timeout to a fail\n    /// state. This means that any downstream escrows or similar can always\n    /// expect that eventually they will see a pass/fail state and so are safe\n    /// to lock funds while a Sale is active.\n    function timeout() external {\n        require(saleTimeout < block.number, \"EARLY_TIMEOUT\");\n        require(\n            _saleStatus == SaleStatus.Pending ||\n                _saleStatus == SaleStatus.Active,\n            \"ALREADY_ENDED\"\n        );\n\n        // Mimic `end` with a failed state but `Timeout` event.\n        remainingUnits = 0;\n        _saleStatus = SaleStatus.Fail;\n        emit Timeout(msg.sender);\n        _token.endDistribution(address(this));\n    }\n\n    /// Main entrypoint to the sale. Sells rTKN in exchange for reserve token.\n    /// The price curve is eval'd to produce a reserve price quote. Each 1 unit\n    /// of rTKN costs `price` reserve token where BOTH the rTKN units and price\n    /// are treated as 18 decimal fixed point values. If the reserve token has\n    /// more or less precision by its own conventions (e.g. \"decimals\" method\n    /// on ERC20 tokens) then the price will need to scale accordingly.\n    /// The receipt is _logged_ rather than returned as it cannot be used in\n    /// same block for a refund anyway due to cooldowns.\n    /// @param config_ All parameters to configure the purchase.\n    function buy(BuyConfig memory config_)\n        external\n        onlyAfterCooldown\n        nonReentrant\n    {\n        require(0 < config_.minimumUnits, \"0_MINIMUM\");\n        require(\n            config_.minimumUnits <= config_.desiredUnits,\n            \"MINIMUM_OVER_DESIRED\"\n        );\n\n        require(_saleStatus == SaleStatus.Active, \"NOT_ACTIVE\");\n\n        uint256 units_ = config_.desiredUnits.min(remainingUnits);\n        require(units_ >= config_.minimumUnits, \"INSUFFICIENT_STOCK\");\n\n        uint256 price_ = calculatePrice(units_);\n\n        require(price_ <= config_.maximumPrice, \"MAXIMUM_PRICE\");\n        uint256 cost_ = price_.fixedPointMul(units_);\n\n        Receipt memory receipt_ = Receipt(\n            nextReceiptId,\n            config_.feeRecipient,\n            config_.fee,\n            units_,\n            price_\n        );\n        nextReceiptId++;\n        // There should never be more than one of the same key due to the ID\n        // counter but we can use checked math to easily cover the case of\n        // potential duplicate receipts due to some bug.\n        receipts[msg.sender][keccak256(abi.encode(receipt_))]++;\n\n        fees[config_.feeRecipient] += config_.fee;\n\n        // We ignore any rTKN or reserve that is sent to the contract directly\n        // outside of a `buy` call. This also means we don't support reserve\n        // tokens with balances that can change outside of transfers\n        // (e.g. rebase).\n        remainingUnits -= units_;\n        totalReserveIn += cost_;\n\n        // This happens before `end` so that the transfer from happens before\n        // the transfer to.\n        // `end` changes state so `buy` needs to be nonReentrant.\n        _reserve.safeTransferFrom(\n            msg.sender,\n            address(this),\n            cost_ + config_.fee\n        );\n        // This happens before `end` so that the transfer happens before the\n        // distributor is burned and token is frozen.\n        IERC20(address(_token)).safeTransfer(msg.sender, units_);\n\n        if (remainingUnits < 1) {\n            end();\n        } else {\n            require(remainingUnits >= dustSize, \"DUST\");\n        }\n\n        emit Buy(msg.sender, config_, receipt_);\n    }\n\n    /// @dev This is here so we can use a modifier like a function call.\n    function refundCooldown()\n        private\n        onlyAfterCooldown\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    /// Rollback a buy given its receipt.\n    /// Ignoring gas (which cannot be refunded) the refund process rolls back\n    /// all state changes caused by a buy, other than the receipt id increment.\n    /// Refunds are limited by the global cooldown to mitigate rapid buy/refund\n    /// cycling that could cause volatile price curves or other unwanted side\n    /// effects for other sale participants. Cooldowns are bypassed if the sale\n    /// ends and is a failure.\n    /// @param receipt_ The receipt of the buy to rollback.\n    function refund(Receipt calldata receipt_) external {\n        require(_saleStatus != SaleStatus.Success, \"REFUND_SUCCESS\");\n        // If the sale failed then cooldowns do NOT apply. Everyone should\n        // immediately refund all their receipts.\n        if (_saleStatus != SaleStatus.Fail) {\n            refundCooldown();\n        }\n\n        // Checked math here will prevent consuming a receipt that doesn't\n        // exist or was already refunded as it will underflow.\n        receipts[msg.sender][keccak256(abi.encode(receipt_))]--;\n\n        uint256 cost_ = receipt_.price.fixedPointMul(receipt_.units);\n\n        totalReserveIn -= cost_;\n        remainingUnits += receipt_.units;\n        fees[receipt_.feeRecipient] -= receipt_.fee;\n\n        emit Refund(msg.sender, receipt_);\n\n        IERC20(address(_token)).safeTransferFrom(\n            msg.sender,\n            address(this),\n            receipt_.units\n        );\n        _reserve.safeTransfer(msg.sender, cost_ + receipt_.fee);\n    }\n\n    /// After a sale ends in success all fees collected for a recipient can be\n    /// cleared. If the raise is active or fails then fees cannot be claimed as\n    /// they are set aside in case of refund. A failed raise implies that all\n    /// buyers should immediately refund and zero fees claimed.\n    /// @param recipient_ The recipient to claim fees for. Does NOT need to be\n    /// the `msg.sender`.\n    function claimFees(address recipient_) external {\n        require(_saleStatus == SaleStatus.Success, \"NOT_SUCCESS\");\n        uint256 amount_ = fees[recipient_];\n        if (amount_ > 0) {\n            delete fees[recipient_];\n            _reserve.safeTransfer(recipient_, amount_);\n        }\n    }\n\n    /// @inheritdoc RainVM\n    function applyOp(\n        bytes memory context_,\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view override {\n        unchecked {\n            if (opcode_ < localOpsStart) {\n                AllStandardOps.applyOp(\n                    state_,\n                    opcode_ - ALL_STANDARD_OPS_START,\n                    operand_\n                );\n            } else {\n                opcode_ -= localOpsStart;\n                require(opcode_ < LOCAL_OPS_LENGTH, \"MAX_OPCODE\");\n                if (opcode_ == OPCODE_REMAINING_UNITS) {\n                    state_.stack[state_.stackIndex] = remainingUnits;\n                } else if (opcode_ == OPCODE_TOTAL_RESERVE_IN) {\n                    state_.stack[state_.stackIndex] = totalReserveIn;\n                } else if (opcode_ == OPCODE_CURRENT_BUY_UNITS) {\n                    uint256 units_ = abi.decode(context_, (uint256));\n                    state_.stack[state_.stackIndex] = units_;\n                } else if (opcode_ == OPCODE_TOKEN_ADDRESS) {\n                    state_.stack[state_.stackIndex] = uint256(\n                        uint160(address(_token))\n                    );\n                } else if (opcode_ == OPCODE_RESERVE_ADDRESS) {\n                    state_.stack[state_.stackIndex] = uint256(\n                        uint160(address(_reserve))\n                    );\n                }\n                state_.stackIndex++;\n            }\n        }\n    }\n}\n"
    },
    "contracts/sale/ISale.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// An `ISale` can be in one of 4 possible states and a linear progression is\n/// expected from an \"in flight\" status to an immutable definitive outcome.\n/// - Pending: The sale is deployed onchain but cannot be interacted with yet.\n/// - Active: The sale can now be bought into and otherwise interacted with.\n/// - Success: The sale has ended AND reached its minimum raise target.\n/// - Fail: The sale has ended BUT NOT reached its minimum raise target.\n/// Once an `ISale` reaches `Active` it MUST NOT return `Pending` ever again.\n/// Once an `ISale` reaches `Success` or `Fail` it MUST NOT return any other\n/// status ever again.\nenum SaleStatus {\n    Pending,\n    Active,\n    Success,\n    Fail\n}\n\ninterface ISale {\n    /// Returns the address of the token being sold in the sale.\n    /// MUST NOT change during the lifecycle of the sale contract.\n    function token() external view returns (address);\n\n    /// Returns the address of the token that sale prices are denominated in.\n    /// MUST NOT change during the lifecycle of the sale contract.\n    function reserve() external view returns (address);\n\n    /// Returns the current `SaleStatus` of the sale.\n    /// Represents a linear progression of the sale through its major lifecycle\n    /// events.\n    function saleStatus() external view returns (SaleStatus);\n}\n"
    },
    "contracts/redeemableERC20/RedeemableERC20.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {ERC20Config} from \"../erc20/ERC20Config.sol\";\nimport \"../erc20/ERC20Redeem.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {ITier} from \"../tier/ITier.sol\";\nimport {TierReport} from \"../tier/libraries/TierReport.sol\";\n\nimport {Phased} from \"../phased/Phased.sol\";\n\n/// Everything required by the `RedeemableERC20` constructor.\n/// @param reserve Reserve token that the associated `Trust` or equivalent\n/// raise contract will be forwarding to the `RedeemableERC20` contract.\n/// @param erc20Config ERC20 config forwarded to the ERC20 constructor.\n/// @param tier Tier contract to compare statuses against on transfer.\n/// @param minimumTier Minimum tier required for transfers in `Phase.ZERO`.\n/// Can be `0`.\n/// @param distributionEndForwardingAddress Optional address to send rTKN to at\n/// the end of the distribution phase. If `0` address then all undistributed\n/// rTKN will burn itself at the end of the distribution.\nstruct RedeemableERC20Config {\n    address reserve;\n    ERC20Config erc20Config;\n    address tier;\n    uint256 minimumTier;\n    address distributionEndForwardingAddress;\n}\n\n/// @title RedeemableERC20\n/// @notice This is the ERC20 token that is minted and distributed.\n///\n/// During `Phase.ZERO` the token can be traded and so compatible with the\n/// Balancer pool mechanics.\n///\n/// During `Phase.ONE` the token is frozen and no longer able to be traded on\n/// any AMM or transferred directly.\n///\n/// The token can be redeemed during `Phase.ONE` which burns the token in\n/// exchange for pro-rata erc20 tokens held by the `RedeemableERC20` contract\n/// itself.\n///\n/// The token balances can be used indirectly for other claims, promotions and\n/// events as a proof of participation in the original distribution by token\n/// holders.\n///\n/// The token can optionally be restricted by the `ITier` contract to only\n/// allow receipients with a specified membership status.\n///\n/// @dev `RedeemableERC20` is an ERC20 with 2 phases.\n///\n/// `Phase.ZERO` is the distribution phase where the token can be freely\n/// transfered but not redeemed.\n/// `Phase.ONE` is the redemption phase where the token can be redeemed but no\n/// longer transferred.\n///\n/// Redeeming some amount of `RedeemableERC20` burns the token in exchange for\n/// some other tokens held by the contract. For example, if the\n/// `RedeemableERC20` token contract holds 100 000 USDC then a holder of the\n/// redeemable token can burn some of their tokens to receive a % of that USDC.\n/// If they redeemed (burned) an amount equal to 10% of the redeemable token\n/// supply then they would receive 10 000 USDC.\n///\n/// To make the treasury assets discoverable anyone can call `newTreasuryAsset`\n/// to emit an event containing the treasury asset address. As malicious and/or\n/// spam users can emit many treasury events there is a need for sensible\n/// indexing and filtering of asset events to only trusted users. This contract\n/// is agnostic to how that trust relationship is defined for each user.\n///\n/// Users must specify all the treasury assets they wish to redeem to the\n/// `redeem` function. After `redeem` is called the redeemed tokens are burned\n/// so all treasury assets must be specified and claimed in a batch atomically.\n/// Note: The same amount of `RedeemableERC20` is burned, regardless of which\n/// treasury assets were specified. Specifying fewer assets will NOT increase\n/// the proportion of each that is returned.\n///\n/// `RedeemableERC20` has several owner administrative functions:\n/// - Owner can add senders and receivers that can send/receive tokens even\n///   during `Phase.ONE`\n/// - Owner can end `Phase.ONE` during `Phase.ZERO` by specifying the address\n///   of a distributor, which will have any undistributed tokens burned.\n/// The owner should be a `Trust` not an EOA.\n///\n/// The redeem functions MUST be used to redeem and burn RedeemableERC20s\n/// (NOT regular transfers).\n///\n/// `redeem` will simply revert if called outside `Phase.ONE`.\n/// A `Redeem` event is emitted on every redemption (per treasury asset) as\n/// `(redeemer, asset, redeemAmount)`.\ncontract RedeemableERC20 is Initializable, Phased, ERC20Redeem {\n    using SafeERC20 for IERC20;\n\n    /// @dev Phase constants.\n    /// Contract is not yet initialized.\n    uint256 private constant PHASE_UNINITIALIZED = 0;\n    /// @dev Token is in the distribution phase and can be transferred freely\n    /// subject to tier requirements.\n    uint256 private constant PHASE_DISTRIBUTING = 1;\n    /// @dev Token is frozen and cannot be transferred unless the\n    /// sender/receiver is authorized as a sender/receiver.\n    uint256 private constant PHASE_FROZEN = 2;\n\n    /// @dev Bits for a receiver.\n    uint256 private constant RECEIVER = 0x1;\n    /// @dev Bits for a sender.\n    uint256 private constant SENDER = 0x2;\n\n    /// @dev To be clear, this admin is NOT intended to be an EOA.\n    /// This contract is designed assuming the admin is a `Sale` or equivalent\n    /// contract that itself does NOT have an admin key.\n    address private admin;\n    /// @dev Tracks addresses that can always send/receive regardless of phase.\n    /// sender/receiver => access bits\n    mapping(address => uint256) private access;\n\n    /// Results of initializing.\n    /// @param sender `msg.sender` of initialize.\n    /// @param config Initialization config.\n    event Initialize(address sender, RedeemableERC20Config config);\n\n    /// A new token sender has been added.\n    /// @param sender `msg.sender` that approved the token sender.\n    /// @param grantedSender address that is now a token sender.\n    event Sender(address sender, address grantedSender);\n\n    /// A new token receiver has been added.\n    /// @param sender `msg.sender` that approved the token receiver.\n    /// @param grantedReceiver address that is now a token receiver.\n    event Receiver(address sender, address grantedReceiver);\n\n    /// RedeemableERC20 uses the standard/default 18 ERC20 decimals.\n    /// The minimum supply enforced by the constructor is \"one\" token which is\n    /// `10 ** 18`.\n    /// The minimum supply does not prevent subsequent redemption/burning.\n    uint256 private constant MINIMUM_INITIAL_SUPPLY = 10**18;\n\n    /// Tier contract that produces the report that `minimumTier` is checked\n    /// against.\n    /// Public so external contracts can interface with the required tier.\n    ITier public tier;\n\n    /// The minimum status that a user must hold to receive transfers during\n    /// `Phase.ZERO`.\n    /// The tier contract passed to `TierByConstruction` determines if\n    /// the status is held during `_beforeTokenTransfer`.\n    /// Public so external contracts can interface with the required tier.\n    uint256 public minimumTier;\n\n    /// Optional address to send rTKN to at the end of the distribution phase.\n    /// If `0` address then all undistributed rTKN will burn itself at the end\n    /// of the distribution.\n    address private distributionEndForwardingAddress;\n\n    /// Mint the full ERC20 token supply and configure basic transfer\n    /// restrictions. Initializes all base contracts.\n    /// @param config_ Initialized configuration.\n    function initialize(RedeemableERC20Config calldata config_)\n        external\n        initializer\n    {\n        initializePhased();\n\n        tier = ITier(config_.tier);\n        __ERC20_init(config_.erc20Config.name, config_.erc20Config.symbol);\n\n        require(\n            config_.erc20Config.initialSupply >= MINIMUM_INITIAL_SUPPLY,\n            \"MINIMUM_INITIAL_SUPPLY\"\n        );\n        minimumTier = config_.minimumTier;\n        distributionEndForwardingAddress = config_\n            .distributionEndForwardingAddress;\n\n        // Minting and burning must never fail.\n        access[address(0)] = RECEIVER | SENDER;\n\n        // Admin receives full supply.\n        access[config_.erc20Config.distributor] = RECEIVER;\n\n        // Forwarding address must be able to receive tokens.\n        if (distributionEndForwardingAddress != address(0)) {\n            access[distributionEndForwardingAddress] = RECEIVER;\n        }\n\n        admin = config_.erc20Config.distributor;\n\n        // Need to mint after assigning access.\n        _mint(\n            config_.erc20Config.distributor,\n            config_.erc20Config.initialSupply\n        );\n\n        // The reserve must always be one of the treasury assets.\n        newTreasuryAsset(config_.reserve);\n\n        emit Initialize(msg.sender, config_);\n\n        // Smoke test on whatever is on the other side of `config_.tier`.\n        // It is a common mistake to pass in a contract without the `ITier`\n        // interface and brick transfers. We want to discover that ASAP.\n        // E.g. `Verify` instead of `VerifyTier`.\n        // Slither does not like this unused return, but we're not looking for\n        // any specific return value, just trying to avoid something that\n        // blatantly errors out.\n        // slither-disable-next-line unused-return\n        ITier(config_.tier).report(msg.sender);\n\n        schedulePhase(PHASE_DISTRIBUTING, block.number);\n    }\n\n    /// Require a function is only admin callable.\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"ONLY_ADMIN\");\n        _;\n    }\n\n    /// Check that an address is a receiver.\n    /// A sender is also a receiver.\n    /// @param maybeReceiver_ account to check.\n    /// @return True if account is a receiver.\n    function isReceiver(address maybeReceiver_) public view returns (bool) {\n        return access[maybeReceiver_] & RECEIVER > 0;\n    }\n\n    /// Admin can grant an address receiver rights.\n    /// @param newReceiver_ The account to grand receiver.\n    function grantReceiver(address newReceiver_) external onlyAdmin {\n        // Using `|` preserves sender if previously granted.\n        access[newReceiver_] |= RECEIVER;\n        emit Receiver(msg.sender, newReceiver_);\n    }\n\n    /// Check that an address is a sender.\n    /// @param maybeSender_ account to check.\n    /// @return True if account is a sender.\n    function isSender(address maybeSender_) public view returns (bool) {\n        return access[maybeSender_] & SENDER > 0;\n    }\n\n    /// Admin can grant an addres sender rights.\n    /// @param newSender_ The account to grant sender.\n    function grantSender(address newSender_) external onlyAdmin {\n        // Uinsg `|` preserves receiver if previously granted.\n        access[newSender_] |= SENDER;\n        emit Sender(msg.sender, newSender_);\n    }\n\n    /// The admin can forward or burn all tokens of a single address to end\n    /// `PHASE_DISTRIBUTING`.\n    /// The intent is that during `PHASE_DISTRIBUTING` there is some contract\n    /// responsible for distributing the tokens.\n    /// The admin specifies the distributor to end `PHASE_DISTRIBUTING` and the\n    /// forwarding address set during initialization is used. If the forwarding\n    /// address is `0` the rTKN will be burned, otherwise the entire balance of\n    /// the distributor is forwarded to the nominated address. In practical\n    /// terms the forwarding allows for escrow depositors to receive a prorata\n    /// claim on unsold rTKN if they forward it to themselves, otherwise raise\n    /// participants will receive a greater share of the final escrowed tokens\n    /// due to the burn reducing the total supply.\n    /// The distributor is NOT set during the constructor because it may not\n    /// exist at that point. For example, Balancer needs the paired erc20\n    /// tokens to exist before the trading pool can be built.\n    /// @param distributor_ The distributor according to the admin.\n    /// BURN the tokens if `address(0)`.\n    function endDistribution(address distributor_)\n        external\n        onlyPhase(PHASE_DISTRIBUTING)\n        onlyAdmin\n    {\n        schedulePhase(PHASE_FROZEN, block.number);\n        address forwardTo_ = distributionEndForwardingAddress;\n        uint256 distributorBalance_ = balanceOf(distributor_);\n        if (distributorBalance_ > 0) {\n            if (forwardTo_ == address(0)) {\n                _burn(distributor_, distributorBalance_);\n            } else {\n                _transfer(distributor_, forwardTo_, distributorBalance_);\n            }\n        }\n    }\n\n    /// Wraps `_redeem` from `ERC20Redeem`.\n    /// Very thin wrapper so be careful when calling!\n    /// @param treasuryAssets_ The treasury assets to redeem for. If this is\n    /// empty or incomplete then tokens will be permanently burned for no\n    /// reason by the caller and the remaining funds will be effectively\n    /// redistributed to everyone else.\n    function redeem(IERC20[] calldata treasuryAssets_, uint256 redeemAmount_)\n        external\n        onlyPhase(PHASE_FROZEN)\n    {\n        _redeem(treasuryAssets_, redeemAmount_);\n    }\n\n    /// Apply phase sensitive transfer restrictions.\n    /// During `Phase.ZERO` only tier requirements apply.\n    /// During `Phase.ONE` all transfers except burns are prevented.\n    /// If a transfer involves either a sender or receiver with the SENDER\n    /// or RECEIVER role, respectively, it will bypass these restrictions.\n    /// @inheritdoc ERC20Upgradeable\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n\n        // Sending tokens to this contract (e.g. instead of redeeming) is\n        // always an error.\n        require(receiver_ != address(this), \"TOKEN_SEND_SELF\");\n\n        // Some contracts may attempt a preflight (e.g. Balancer) of a 0 amount\n        // transfer.\n        // We don't want to accidentally cause external errors due to zero\n        // value transfers.\n        if (\n            amount_ > 0 &&\n            // The sender and receiver lists bypass all access restrictions.\n            !(isSender(sender_) || isReceiver(receiver_))\n        ) {\n            // During `PHASE_DISTRIBUTING` transfers are only restricted by the\n            // tier of the recipient. Every other phase only allows senders and\n            // receivers as above.\n            require(currentPhase() == PHASE_DISTRIBUTING, \"FROZEN\");\n\n            // Receivers act as \"hubs\" that can send to \"spokes\".\n            // i.e. any address of the minimum tier.\n            // Spokes cannot send tokens another \"hop\" e.g. to each other.\n            // Spokes can only send back to a receiver (doesn't need to be\n            // the same receiver they received from).\n            require(isReceiver(sender_), \"2SPOKE\");\n            require(\n                TierReport.tierAtBlockFromReport(\n                    tier.report(receiver_),\n                    block.number\n                ) >= minimumTier,\n                \"MIN_TIER\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/redeemableERC20/RedeemableERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport {RedeemableERC20, RedeemableERC20Config} from \"./RedeemableERC20.sol\";\nimport {ITier} from \"../tier/ITier.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title RedeemableERC20Factory\n/// @notice Factory for deploying and registering `RedeemableERC20` contracts.\ncontract RedeemableERC20Factory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new RedeemableERC20());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        RedeemableERC20Config memory config_ = abi.decode(\n            data_,\n            (RedeemableERC20Config)\n        );\n        address clone_ = Clones.clone(implementation);\n        RedeemableERC20(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `RedeemableERC20Config` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `RedeemableERC20` constructor configuration.\n    /// @return New `RedeemableERC20` child contract.\n    function createChildTyped(RedeemableERC20Config calldata config_)\n        external\n        returns (RedeemableERC20)\n    {\n        return RedeemableERC20(this.createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/erc20/ERC20Redeem.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\n\ncontract ERC20Redeem is ERC20BurnableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    /// Anon has burned their tokens in exchange for some treasury assets.\n    /// Emitted once per redeemed asset.\n    /// @param sender `msg.sender` is burning.\n    /// @param treasuryAsset Treasury asset being sent to redeemer.\n    /// @param redeemAmount Amount of token being burned.\n    /// @param assetAmount Amount of treasury asset being sent.\n    event Redeem(\n        address sender,\n        address treasuryAsset,\n        uint256 redeemAmount,\n        uint256 assetAmount\n    );\n\n    /// Anon can notify the world that they are adding treasury assets to the\n    /// contract. Indexers are strongly encouraged to ignore untrusted anons.\n    /// @param sender `msg.sender` adding a treasury asset.\n    /// @param asset The treasury asset being added.\n    event TreasuryAsset(address sender, address asset);\n\n    /// Anon can emit a `TreasuryAsset` event to notify token holders that\n    /// an asset could be redeemed by burning `RedeemableERC20` tokens.\n    /// As this is callable by anon the events should be filtered by the\n    /// indexer to those from trusted entities only.\n    /// @param newTreasuryAsset_ The asset to log.\n    function newTreasuryAsset(address newTreasuryAsset_) public {\n        emit TreasuryAsset(msg.sender, newTreasuryAsset_);\n    }\n\n    /// Burn tokens for a prorata share of the current treasury.\n    ///\n    /// The assets to be redeemed for must be specified as an array. This keeps\n    /// the redeem functionality:\n    /// - Gas efficient as we avoid tracking assets in storage\n    /// - Decentralised as any user can deposit any asset to be redeemed\n    /// - Error resistant as any individual asset reverting can be avoided by\n    ///   redeeming againt sans the problematic asset.\n    /// It is also a super sharp edge if someone burns their tokens prematurely\n    /// or with an incorrect asset list. Implementing contracts are strongly\n    /// encouraged to implement additional safety rails to prevent high value\n    /// mistakes.\n    /// Only \"vanilla\" erc20 token balances are supported as treasury assets.\n    /// I.e. if the balance is changing such as due to a rebasing token or\n    /// other mechanism then the WRONG token amounts will be redeemed. The\n    /// redemption calculation is very simple and naive in that it takes the\n    /// current balance of this contract of the assets being claimed via\n    /// redemption to calculate the \"prorata\" entitlement. If the contract's\n    /// balance of the claimed token is changing between redemptions (other\n    /// than due to the redemption itself) then each redemption will send\n    /// incorrect amounts.\n    /// @param treasuryAssets_ The list of assets to redeem.\n    /// @param redeemAmount_ The amount of redeemable token to burn.\n    function _redeem(IERC20[] memory treasuryAssets_, uint256 redeemAmount_)\n        internal\n    {\n        uint256 assetsLength_ = treasuryAssets_.length;\n\n        // Calculate everything before any balances change.\n        uint256[] memory amounts_ = new uint256[](assetsLength_);\n\n        // The fraction of the assets we release is the fraction of the\n        // outstanding total supply of the redeemable being burned.\n        // Every treasury asset is released in the same proportion.\n        // Guard against no asset redemptions and log all events before we\n        // change any contract state or call external contracts.\n        require(assetsLength_ > 0, \"EMPTY_ASSETS\");\n        uint256 supply_ = IERC20(address(this)).totalSupply();\n        uint256 amount_ = 0;\n        for (uint256 i_ = 0; i_ < assetsLength_; i_++) {\n            amount_ =\n                (treasuryAssets_[i_].balanceOf(address(this)) * redeemAmount_) /\n                supply_;\n            require(amount_ > 0, \"ZERO_AMOUNT\");\n            emit Redeem(\n                msg.sender,\n                address(treasuryAssets_[i_]),\n                redeemAmount_,\n                amount_\n            );\n            amounts_[i_] = amount_;\n        }\n\n        // Burn FIRST (reentrancy safety).\n        _burn(msg.sender, redeemAmount_);\n\n        // THEN send all assets.\n        for (uint256 i_ = 0; i_ < assetsLength_; i_++) {\n            treasuryAssets_[i_].safeTransfer(msg.sender, amounts_[i_]);\n        }\n    }\n}\n"
    },
    "contracts/phased/Phased.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title Phased\n/// @notice `Phased` is an abstract contract that defines up to `9` phases that\n/// an implementing contract moves through.\n///\n/// Phase `0` is always the first phase and does not, and cannot, be set\n/// expicitly. Effectively it is implied that phase `0` has been active\n/// since block zero.\n///\n/// Each subsequent phase `1` through `8` must be scheduled sequentially and\n/// explicitly at a block number.\n///\n/// Only the immediate next phase can be scheduled with `scheduleNextPhase`,\n/// it is not possible to schedule multiple phases ahead.\n///\n/// Multiple phases can be scheduled in a single block if each scheduled phase\n/// is scheduled for the current block.\n///\n/// Several utility functions and modifiers are provided.\n///\n/// One event `PhaseShiftScheduled` is emitted each time a phase shift is\n/// scheduled (not when the scheduled phase is reached).\n///\n/// @dev `Phased` contracts have a defined timeline with available\n/// functionality grouped into phases.\n/// Every `Phased` contract starts at `0` and moves sequentially\n/// through phases `1` to `8`.\n/// Every `Phase` other than `0` is optional, there is no requirement\n/// that all 9 phases are implemented.\n/// Phases can never be revisited, the inheriting contract always moves through\n/// each achieved phase linearly.\n/// This is enforced by only allowing `scheduleNextPhase` to be called once per\n/// phase.\n/// It is possible to call `scheduleNextPhase` several times in a single block\n/// but the `block.number` for each phase must be reached each time to schedule\n/// the next phase.\n/// Importantly there are events and several modifiers and checks available to\n/// ensure that functionality is limited to the current phase.\n/// The full history of each phase shift block is recorded as a fixed size\n/// array of `uint32`.\ncontract Phased {\n    /// @dev Every phase block starts uninitialized.\n    /// Only uninitialized blocks can be set by the phase scheduler.\n    uint32 private constant UNINITIALIZED = type(uint32).max;\n    /// @dev This is how many phases can fit in a `uint256`.\n    uint256 private constant MAX_PHASE = 8;\n\n    /// `PhaseScheduled` is emitted when the next phase is scheduled.\n    /// @param sender `msg.sender` that scheduled the next phase.\n    /// @param newPhase The next phase being scheduled.\n    /// @param scheduledBlock The block the phase will be achieved.\n    event PhaseScheduled(\n        address sender,\n        uint256 newPhase,\n        uint256 scheduledBlock\n    );\n\n    /// 8 phases each as 32 bits to fit a single 32 byte word.\n    uint32[MAX_PHASE] public phaseBlocks;\n\n    /// Initialize the blocks at \"never\".\n    /// All phase blocks are initialized to `UNINITIALIZED`.\n    /// i.e. not fallback solidity value of `0`.\n    function initializePhased() internal {\n        // Reinitialization is a bug.\n        // Only need to check the first block as all blocks are about to be set\n        // to `UNINITIALIZED`.\n        assert(phaseBlocks[0] < 1);\n        uint32[MAX_PHASE] memory phaseBlocks_ = [\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED\n        ];\n        phaseBlocks = phaseBlocks_;\n        // 0 is always the block for implied phase 0.\n        emit PhaseScheduled(msg.sender, 0, 0);\n    }\n\n    /// Pure function to reduce an array of phase blocks and block number to a\n    /// specific `Phase`.\n    /// The phase will be the highest attained even if several phases have the\n    /// same block number.\n    /// If every phase block is after the block number then `0` is\n    /// returned.\n    /// If every phase block is before the block number then `MAX_PHASE` is\n    /// returned.\n    /// @param phaseBlocks_ Fixed array of phase blocks to compare against.\n    /// @param blockNumber_ Determine the relevant phase relative to this block\n    /// number.\n    /// @return The \"current\" phase relative to the block number and phase\n    /// blocks list.\n    function phaseAtBlockNumber(\n        uint32[MAX_PHASE] memory phaseBlocks_,\n        uint256 blockNumber_\n    ) public pure returns (uint256) {\n        for (uint256 i_ = 0; i_ < MAX_PHASE; i_++) {\n            if (blockNumber_ < phaseBlocks_[i_]) {\n                return i_;\n            }\n        }\n        return MAX_PHASE;\n    }\n\n    /// Pure function to reduce an array of phase blocks and phase to a\n    /// specific block number.\n    /// `Phase.ZERO` will always return block `0`.\n    /// Every other phase will map to a block number in `phaseBlocks_`.\n    /// @param phaseBlocks_ Fixed array of phase blocks to compare against.\n    /// @param phase_ Determine the relevant block number for this phase.\n    /// @return The block number for the phase according to `phaseBlocks_`.\n    function blockNumberForPhase(\n        uint32[MAX_PHASE] memory phaseBlocks_,\n        uint256 phase_\n    ) public pure returns (uint256) {\n        return phase_ > 0 ? phaseBlocks_[phase_ - 1] : 0;\n    }\n\n    /// Impure read-only function to return the \"current\" phase from internal\n    /// contract state.\n    /// Simply wraps `phaseAtBlockNumber` for current values of `phaseBlocks`\n    /// and `block.number`.\n    function currentPhase() public view returns (uint256) {\n        return phaseAtBlockNumber(phaseBlocks, block.number);\n    }\n\n    /// Modifies functions to only be callable in a specific phase.\n    /// @param phase_ Modified functions can only be called during this phase.\n    modifier onlyPhase(uint256 phase_) {\n        require(currentPhase() == phase_, \"BAD_PHASE\");\n        _;\n    }\n\n    /// Modifies functions to only be callable in a specific phase OR if the\n    /// specified phase has passed.\n    /// @param phase_ Modified function only callable during or after this\n    /// phase.\n    modifier onlyAtLeastPhase(uint256 phase_) {\n        require(currentPhase() >= phase_, \"MIN_PHASE\");\n        _;\n    }\n\n    /// Writes the block for the next phase.\n    /// Only uninitialized blocks can be written to.\n    /// Only the immediate next phase relative to `currentPhase` can be written\n    /// to. It is still required to specify the `phase_` so that it is explicit\n    /// and clear in the calling code which phase is being moved to.\n    /// Emits `PhaseShiftScheduled` with the phase block.\n    /// @param phase_ The phase being scheduled.\n    /// @param block_ The block for the phase.\n    function schedulePhase(uint256 phase_, uint256 block_) internal {\n        require(block.number <= block_, \"NEXT_BLOCK_PAST\");\n        require(block_ < UNINITIALIZED, \"NEXT_BLOCK_UNINITIALIZED\");\n        // Don't need to check for underflow as the index will be used as a\n        // fixed array index below. Implies that scheduling phase `0` is NOT\n        // supported.\n        uint256 index_;\n        unchecked {\n            index_ = phase_ - 1;\n        }\n        // Bit of a hack to check the current phase against the index to\n        // save calculating the subtraction twice.\n        require(currentPhase() == index_, \"NEXT_PHASE\");\n\n        require(UNINITIALIZED == phaseBlocks[index_], \"NEXT_BLOCK_SET\");\n\n        // Cannot exceed UNINITIALIZED (see above) so don't need to check\n        // overflow on downcast.\n        unchecked {\n            phaseBlocks[index_] = uint32(block_);\n        }\n\n        emit PhaseScheduled(msg.sender, phase_, block_);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/test/SaleReentrant.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ReserveToken} from \"./ReserveToken.sol\";\nimport {Sale, BuyConfig} from \"../sale/Sale.sol\";\n\n/// @title SaleReentrant\n/// Test contract that attempts to call reentrant code on `Sale`.\n/// The calls MUST fail when driven by the test harness.\ncontract SaleReentrant is ReserveToken {\n    Sale private sale;\n    BuyConfig private buyConfig;\n\n    /// Configures the contract to attempt to reenter.\n    constructor() ReserveToken() {} // solhint-disable-line no-empty-blocks\n\n    /// Set the contract to attempt to reenter.\n    /// @param sale_ Sale contract to reeenter.\n    /// @param config_ BuyConfig for reentrant buy call.\n    function addReentrantTarget(\n        Sale sale_,\n        BuyConfig calldata config_\n    ) external {\n        sale = sale_;\n        buyConfig = config_;\n    }\n\n    /// @inheritdoc ReserveToken\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n        if (receiver_ != address(0) && receiver_ == address(sale)) {\n            // This call MUST fail.\n            sale.buy(buyConfig);\n        }\n    }\n}\n"
    },
    "contracts/test/ReserveToken.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n/// @title ReserveToken\n/// A test token that can be used as a reserve asset.\n/// On mainnet this would likely be some brand of stablecoin but can be\n/// anything.\n/// Notably mimics 6 decimals commonly used by stables in production.\ncontract ReserveToken is ERC20, ERC20Burnable {\n    /// Accounts to freeze during testing.\n    mapping(address => bool) public freezables;\n\n    // Stables such as USDT and USDC commonly have 6 decimals.\n    uint256 public constant DECIMALS = 6;\n    // One _billion_ dollars .\n    uint256 public constant TOTAL_SUPPLY = 10**(DECIMALS + 9);\n\n    /// Define and mint the erc20 token.\n    constructor() ERC20(\"USD Classic\", \"USDCC\") {\n        _mint(msg.sender, TOTAL_SUPPLY);\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return uint8(DECIMALS);\n    }\n\n    /// Add an account to the freezables list.\n    /// @param account_ The account to freeze.\n    function addFreezable(address account_) external {\n        freezables[account_] = true;\n    }\n\n    /// Block any transfers to a frozen account.\n    /// @inheritdoc ERC20\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n        require(!freezables[receiver_], \"FROZEN\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n"
    },
    "contracts/test/ReserveTokenERC1155.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n// solhint-disable-next-line max-line-length\nimport {ERC1155Burnable} from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\";\n\n/// @title ReserveTokenERC1155\n// Extremely basic ERC1155 implementation for testing purposes.\ncontract ReserveTokenERC1155 is ERC1155, ERC1155Burnable {\n    // Stables such as USDT and USDC commonly have 6 decimals.\n    uint256 public constant DECIMALS = 6;\n    // One _billion_ dollars .\n    uint256 public constant TOTAL_SUPPLY = 10**(DECIMALS + 9);\n\n    // Incremented token count for use as id for newly minted tokens.\n    uint256 public tokenCount;\n\n    /// Define and mint a erc1155 token.\n    constructor() ERC1155(\"\") {\n        tokenCount = 0;\n        _mint(msg.sender, tokenCount, TOTAL_SUPPLY, \"\");\n    }\n\n    function mintNewToken() external {\n        tokenCount++;\n        _mint(msg.sender, tokenCount, TOTAL_SUPPLY, \"\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "contracts/test/ReserveTokenERC721.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n// solhint-disable-next-line max-line-length\nimport {ERC721Burnable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\n\n/// @title ReserveTokenERC721\n// Extremely basic ERC721 implementation for testing purposes.\ncontract ReserveTokenERC721 is ERC721, ERC721Burnable {\n    // Incremented token count for use as id for newly minted tokens.\n    uint256 public tokenCount;\n\n    /// Define and mint a erc721 token.\n    constructor() ERC721(\"Test NFT\", \"TNFT\") {\n        tokenCount = 0;\n        _mint(msg.sender, tokenCount);\n    }\n\n    function mintNewToken() external {\n        tokenCount++;\n        _mint(msg.sender, tokenCount);\n    }\n}\n"
    },
    "contracts/test/ReserveNFT.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract ReserveNFT is ERC721 {\n    mapping(address => bool) public freezables;\n\n    uint256 public totalSupply;\n    uint256 public maxSupply;\n\n    /// Define and mint the erc20 token.\n    constructor() ERC721(\"NON FUNGIBLE TOKEN\", \"NFT\") {\n        maxSupply = 10000;\n    }\n\n    /// Add an account to the freezables list.\n    /// @param account_ The account to freeze.\n    function addFreezable(address account_) external {\n        freezables[account_] = true;\n    }\n\n    /// Function ti Mint NFTs\n    function mint(address _address, uint256 _amount) external {\n        require(totalSupply + _amount <= maxSupply,\"Max limit reached.\");\n        for(uint256 i = 0; i < _amount; i=i+1){\n            totalSupply++;\n            _mint(_address, totalSupply);\n        }\n    }\n\n    /// Block any transfers to a frozen account.\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n        require(!freezables[receiver_], \"FROZEN\");\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override \n    returns(string memory){\n        return \"URI\";\n    }\n}"
    },
    "contracts/test/ERC20PulleeTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {RedeemableERC20} from \"../redeemableERC20/RedeemableERC20.sol\";\n\ncontract ERC20PulleeTest {\n    using SafeERC20 for IERC20;\n\n    function approve(\n        address token_,\n        address recipient_,\n        uint256 amount_\n    ) external {\n        IERC20(token_).safeIncreaseAllowance(recipient_, amount_);\n    }\n\n    function transfer(\n        address token_,\n        address recipient_,\n        uint256 amount_\n    ) external {\n        IERC20(token_).transfer(recipient_, amount_);\n    }\n\n    function endDistribution(address token_, address distributor_)\n        external\n    {\n        RedeemableERC20(token_).endDistribution(distributor_);\n    }\n\n    function grantSender(address token_, address sender_) external {\n        RedeemableERC20(token_).grantSender(sender_);\n    }\n\n    function grantReceiver(address token_, address receiver_) external {\n        RedeemableERC20(token_).grantReceiver(receiver_);\n    }\n\n    function redeem(\n        address token_,\n        IERC20[] calldata assets_,\n        uint256 amount_\n    ) external {\n        RedeemableERC20(token_).redeem(assets_, amount_);\n    }\n}"
    },
    "contracts/test/RedeemableERC20Reentrant.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ReserveToken} from \"./ReserveToken.sol\";\nimport {RedeemableERC20} from \"../redeemableERC20/RedeemableERC20.sol\";\n\n/// @title RedeemableERC20Reentrant\n/// Test contract that attempts to call reentrant code on `RedeemableERC20`.\n/// The calls MUST fail when driven by the test harness.\ncontract RedeemableERC20Reentrant is ReserveToken {\n    RedeemableERC20 private redeemableERC20;\n\n    /// Configures the contract to attempt to reenter.\n    constructor() ReserveToken() {} // solhint-disable-line no-empty-blocks\n\n    /// Set the contract to attempt to reenter.\n    /// @param redeemableERC20_ RedeemableERC20 contract to reeenter.\n    function addReentrantTarget(RedeemableERC20 redeemableERC20_) external {\n        redeemableERC20 = redeemableERC20_;\n    }\n\n    /// @inheritdoc ReserveToken\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n        if (sender_ != address(0) && sender_ == address(redeemableERC20)) {\n            IERC20[] memory treasuryAssets_ = new IERC20[](1);\n            treasuryAssets_[0] = IERC20(address(this));\n            // This call MUST fail.\n            redeemableERC20.redeem(treasuryAssets_, amount_);\n        }\n    }\n}\n"
    },
    "contracts/test/ReserveTokenTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @title ReserveTokenTest\n/// An example token that can be used as a reserve asset.\n/// On mainnet this would likely be some stablecoin but can be anything.\ncontract ReserveTokenTest is ERC20 {\n    /// How many tokens to mint initially.\n    // One _billion_ dollars \n    uint256 public constant INITIAL_MINT = 10**9;\n\n    /// Test against frozen assets, for example USDC can do this.\n    mapping(address => bool) public freezables;\n\n    constructor() ERC20(\"USD Classic\", \"USDCC\") {\n        _mint(msg.sender, INITIAL_MINT * 10**18);\n    }\n\n    /// Anyone in the world can freeze any address on our test asset.\n    /// @param address_ The address to freeze.\n    function addFreezable(address address_) external {\n        freezables[address_] = true;\n    }\n\n    /// Anyone in the world can unfreeze any address on our test asset.\n    /// @param address_ The address to unfreeze.\n    function removeFreezable(address address_) external {\n        freezables[address_] = false;\n    }\n\n    /// Burns all tokens held by the sender.\n    function purge() external {\n        _burn(msg.sender, balanceOf(msg.sender));\n    }\n\n    /// Enforces the freeze list.\n    function _beforeTokenTransfer(\n        address,\n        address receiver_,\n        uint256\n    ) internal view override {\n        require(receiver_ == address(0) || !(freezables[receiver_]), \"FROZEN\");\n    }\n}\n"
    },
    "contracts/escrow/RedeemableERC20ClaimEscrow.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {RedeemableERC20} from \"../redeemableERC20/RedeemableERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./SaleEscrow.sol\";\n\n/// Escrow contract for ERC20 tokens to be deposited and withdrawn against\n/// redeemableERC20 tokens from a specific `Sale`.\n///\n/// When some token is deposited the running total of that token against the\n/// trust is incremented by the deposited amount. When some `redeemableERC20`\n/// token holder calls `withdraw` they are sent the full balance they have not\n/// previously claimed, multiplied by their fraction of the redeemable token\n/// supply that they currently hold. As redeemable tokens are frozen after\n/// distribution there are no issues with holders manipulating withdrawals by\n/// transferring tokens to claim multiple times.\n///\n/// As redeemable tokens can be burned it is possible for the total supply to\n/// decrease over time, which naively would result in claims being larger\n/// retroactively (prorata increases beyond what can be paid).\n///\n/// For example:\n/// - Alice and Bob hold 50 rTKN each, 100 total supply\n/// - 100 TKN is deposited\n/// - Alice withdraws 50% of 100 TKN => alice holds 50 TKN escrow holds 50 TKN\n/// - Alice burns her 50 rTKN\n/// - Bob attempts to withdraw his 50 rTKN which is now 100% of supply\n/// - Escrow tries to pay 100% of 100 TKN deposited and fails as the escrow\n///   only holds 50 TKN (alice + bob = 150%).\n///\n/// To avoid the escrow allowing more withdrawals than deposits we include the\n/// total rTKN supply in the key of each deposit mapping, and include it in the\n/// emmitted event. Alice and Bob must read the events offchain and make a\n/// withdrawal relative to the rTKN supply as it was at deposit time. Many\n/// deposits can be made under a single rTKN supply and will all combine to a\n/// single withdrawal but deposits made across different supplies will require\n/// multiple withdrawals.\n///\n/// Alice or Bob could burn their tokens before withdrawing and would simply\n/// withdraw zero or only some of the deposited TKN. This hurts them\n/// individually, so they SHOULD check their indexer for claimable assets in\n/// the escrow before considering a burn. But neither of them can cause the\n/// other to be able to withdraw more or less relative to the supply as it was\n/// at the time of TKN being deposited, or to trick the escrow into overpaying\n/// more TKN than was deposited under a given `Sale`.\n///\n/// A griefer could attempt to flood the escrow with many dust deposits under\n/// many different supplies in an attempt to confuse alice/bob. They are free\n/// to filter out events in their indexer that come from an unknown depositor\n/// or fall below some dust value threshold.\n///\n/// Tokens may also exit the escrow as an `undeposit` call where the depositor\n/// receives back the tokens they deposited. As above the depositor must\n/// provide the rTKN supply from `deposit` time in order to `undeposit`.\n///\n/// As `withdraw` and `undeposit` both represent claims on the same tokens they\n/// are mutually exclusive outcomes, hence the need for an escrow. The escrow\n/// will process `withdraw` only if the `Sale` is reporting a complete and\n/// successful raise. Similarly `undeposit` will only return tokens after the\n/// `Sale` completes and reports failure. While the `Sale` is in active\n/// distribution neither `withdraw` or `undeposit` will move tokens. This is\n/// necessary in part because it is only safe to calculate entitlements once\n/// the redeemable tokens are fully distributed and frozen.\n///\n/// Because much of the redeemable token supply will never be sold, and then\n/// burned, `depositPending` MUST be called rather than `deposit` while the\n/// raise is active. When the raise completes anon can call `sweepPending`\n/// which will calculate and emit a `Deposit` event for a useful `supply`.\n///\n/// Any supported ERC20 token can be deposited at any time BUT ONLY under a\n/// `Sale` contract that is the child of the `TrustFactory` that the escrow\n/// is deployed for. `TrustEscrow` is used to prevent a `Sale` from changing\n/// the pass/fail outcome once it is known due to a bug/attempt to double\n/// spend escrow funds.\n///\n/// This mechanism is very similar to the native burn mechanism on\n/// `redeemableERC20` itself under `redeem` but without requiring any tokens to\n/// be burned in the process. Users can claim the same token many times safely,\n/// simply receiving 0 tokens if there is nothing left to claim.\n///\n/// This does NOT support rebase/elastic token _balance_ mechanisms on the\n/// escrowed token as the escrow has no way to track deposits/withdrawals other\n/// than 1:1 conservation of input/output. For example, if 100 tokens are\n/// deposited under two different trusts and then that token rebases all\n/// balances to half, there will be 50 tokens in the escrow but the escrow will\n/// attempt transfers up to 100 tokens between the two trusts. Essentially the\n/// first 50 tokens will send and the next 50 tokens will fail because the\n/// trust literally doesn't have 100 tokens at that point.\n///\n/// Elastic _supply_ tokens are supported as every token to be withdrawn must\n/// be first deposited, with the caveat that if some mechanism can\n/// mint/burn/transfer tokens out from under the escrow contract directly, this\n/// will break internal accounting much like the rebase situation.\n///\n/// Using a real-world example, stETH from LIDO would be NOT be supported as\n/// the balance changes every day to reflect incoming ETH from validators, but\n/// wstETH IS supported as balances remain static while the underlying assets\n/// per unit of wstETH increase each day. This is of course exactly why wstETH\n/// was created in the first place.\n///\n/// Every escrowed token has a separate space in the deposited/withdrawn\n/// mappings so that some broken/malicious/hacked token that leads to incorrect\n/// token movement in/out of the escrow cannot impact other tokens, even for\n/// the same trust and redeemable.\ncontract RedeemableERC20ClaimEscrow is SaleEscrow {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    /// Emitted for every successful pending deposit.\n    /// @param sender Anon `msg.sender` depositing the token.\n    /// @param sale `ISale` contract deposit is under.\n    /// @param redeemable Redeemable token that can claim this deposit.\n    /// Implicitly snapshots the redeemable so malicious `Trust` cannot\n    /// redirect funds later.\n    /// @param token `IERC20` token being deposited.\n    /// @param amount Amount of token deposited.\n    event PendingDeposit(\n        address sender,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 amount\n    );\n\n    /// Emitted every time a pending deposit is swept to a full deposit.\n    /// @param sender Anon `msg.sender` sweeping the deposit.\n    /// @param depositor Anon `msg.sender` who originally deposited the token.\n    /// @param sale `ISale` contract deposit is under.\n    /// @param redeemable Redeemable token first reported by the trust.\n    /// @param token `IERC20` token being swept into a deposit.\n    /// @param amount Amount of token being swept into a deposit.\n    event Sweep(\n        address sender,\n        address depositor,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 amount\n    );\n\n    /// Emitted for every successful deposit.\n    /// @param sender Anon `msg.sender` triggering the deposit.\n    /// MAY NOT be the `depositor` in the case of a pending sweep.\n    /// @param depositor Anon `msg.sender` who originally deposited the token.\n    /// MAY NOT be the current `msg.sender` in the case of a pending sweep.\n    /// @param sale `ISale` contract deposit is under.\n    /// @param redeemable Redeemable token that can claim this deposit.\n    /// @param token `IERC20` token being deposited.\n    /// @param supply rTKN supply at moment of deposit.\n    /// @param amount Amount of token deposited.\n    event Deposit(\n        address sender,\n        address depositor,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 supply,\n        uint256 amount\n    );\n\n    /// Emitted for every successful undeposit.\n    /// @param sender Anon `msg.sender` undepositing the token.\n    /// @param sale `ISale` contract undeposit is from.\n    /// @param redeemable Redeemable token that is being undeposited against.\n    /// @param token `IERC20` token being undeposited.\n    /// @param supply rTKN supply at moment of deposit.\n    /// @param amount Amount of token undeposited.\n    event Undeposit(\n        address sender,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 supply,\n        uint256 amount\n    );\n\n    /// Emitted for every successful withdrawal.\n    /// @param withdrawer Anon `msg.sender` withdrawing the token.\n    /// @param sale `ISale` contract withdrawal is from.\n    /// @param redeemable Redeemable token used to withdraw.\n    /// @param token `IERC20` token being withdrawn.\n    /// @param supply rTKN supply at moment of deposit.\n    /// @param amount Amount of token withdrawn.\n    event Withdraw(\n        address withdrawer,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 supply,\n        uint256 amount\n    );\n\n    /// Every time an address calls `withdraw` their withdrawals increases to\n    /// match the current `totalDeposits` for that trust/token combination.\n    /// The token amount they actually receive is only their prorata share of\n    /// that deposited balance. The prorata scaling calculation happens inline\n    /// within the `withdraw` function.\n    /// trust => withdrawn token =>  rTKN supply => withdrawer => amount\n    // solhint-disable-next-line max-line-length\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => uint256))))\n        internal withdrawals;\n\n    /// Deposits during an active raise are desirable to trustlessly prove to\n    /// raise participants that they will in fact be able to access the TKN\n    /// after the raise succeeds. Deposits during the pending stage are set\n    /// aside with no rTKN supply mapping, to be swept into a real deposit by\n    /// anon once the raise completes.\n    mapping(address => mapping(address => mapping(address => uint256)))\n        internal pendingDeposits;\n\n    /// Every time an address calls `deposit` their deposited trust/token\n    /// combination is increased. If they call `undeposit` when the raise has\n    /// failed they will receive the full amount they deposited back. Every\n    /// depositor must call `undeposit` for themselves.\n    /// trust => deposited token => depositor => rTKN supply => amount\n    // solhint-disable-next-line max-line-length\n    mapping(address => mapping(address => mapping(address => mapping(uint256 => uint256))))\n        internal deposits;\n\n    /// Every time an address calls `deposit` the amount is added to that\n    /// trust/token/supply combination. This increase becomes the\n    /// \"high water mark\" that withdrawals move up to with each `withdraw`\n    /// call.\n    /// trust => deposited token => rTKN supply => amount\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        internal totalDeposits;\n\n    /// Redundant tracking of deposits withdrawn.\n    /// Counts aggregate deposits down as users withdraw, while their own\n    /// individual withdrawal counters count up.\n    /// Guards against buggy/malicious redeemable tokens that don't correctly\n    /// freeze their balances, hence opening up double spends.\n    /// trust => deposited token => rTKN supply => amount\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        internal remainingDeposits;\n\n    /// Depositor can set aside tokens during pending raise status to be swept\n    /// into a real deposit later.\n    /// The problem with doing a normal deposit while the raise is still active\n    /// is that the `Sale` will burn all unsold tokens when the raise ends. If\n    /// we captured the token supply mid-raise then many deposited TKN would\n    /// be allocated to unsold rTKN. Instead we set aside TKN so that raise\n    /// participants can be sure that they will be claimable upon raise success\n    /// but they remain unbound to any rTKN supply until `sweepPending` is\n    /// called.\n    /// `depositPending` is a one-way function, there is no way to `undeposit`\n    /// until after the raise fails. Strongly recommended that depositors do\n    /// NOT call `depositPending` until raise starts, so they know it will also\n    /// end.\n    /// @param sale_ The `Sale` to assign this deposit to.\n    /// @param token_ The `IERC20` token to deposit to the escrow.\n    /// @param amount_ The amount of token to despoit. Requires depositor has\n    /// approved at least this amount to succeed.\n    function depositPending(\n        address sale_,\n        address token_,\n        uint256 amount_\n    ) external {\n        require(amount_ > 0, \"ZERO_DEPOSIT\");\n        require(escrowStatus(sale_) == EscrowStatus.Pending, \"NOT_PENDING\");\n        pendingDeposits[sale_][token_][msg.sender] += amount_;\n        // Important to snapshot the token from the trust here so it can't be\n        // changed later by the trust.\n        address redeemable_ = token(sale_);\n\n        emit PendingDeposit(msg.sender, sale_, redeemable_, token_, amount_);\n\n        IERC20(token_).safeTransferFrom(msg.sender, address(this), amount_);\n    }\n\n    /// Internal accounting for a deposit.\n    /// Identical for both a direct deposit and sweeping a pending deposit.\n    /// @param sale_ The sale to register a deposit under.\n    /// @param token_ The token being deposited.\n    /// @param depositor_ The depositor address to register the deposit under.\n    /// @param amount_ The size of the deposit denominated in `token_`.\n    function registerDeposit(\n        address sale_,\n        address token_,\n        address depositor_,\n        uint256 amount_\n    ) private {\n        require(escrowStatus(sale_) > EscrowStatus.Pending, \"PENDING\");\n        require(amount_ > 0, \"ZERO_DEPOSIT\");\n\n        address redeemable_ = token(sale_);\n        uint256 supply_ = IERC20(redeemable_).totalSupply();\n\n        deposits[sale_][token_][depositor_][supply_] += amount_;\n        totalDeposits[sale_][token_][supply_] += amount_;\n        remainingDeposits[sale_][token_][supply_] += amount_;\n\n        emit Deposit(\n            msg.sender,\n            depositor_,\n            sale_,\n            redeemable_,\n            token_,\n            supply_,\n            amount_\n        );\n    }\n\n    /// Anon can convert any existing pending deposit to a deposit with known\n    /// rTKN supply once the escrow has moved out of pending status.\n    /// As `sweepPending` is anon callable, raise participants know that the\n    /// depositor cannot later prevent a sweep, and depositor knows that raise\n    /// participants cannot prevent a sweep. As per normal deposits, the output\n    /// of swept tokens depends on success/fail state allowing `undeposit` or\n    /// `withdraw` to be called subsequently.\n    /// Partial sweeps are NOT supported, to avoid griefers splitting a deposit\n    /// across many different `supply_` values.\n    /// @param sale_ The sale to sweep all pending deposits for.\n    /// @param token_ The token to sweep into registered deposits.\n    /// @param depositor_ The depositor to sweep registered deposits under.\n    function sweepPending(\n        address sale_,\n        address token_,\n        address depositor_\n    ) external {\n        uint256 amount_ = pendingDeposits[sale_][token_][depositor_];\n        delete pendingDeposits[sale_][token_][depositor_];\n        emit Sweep(\n            msg.sender,\n            depositor_,\n            sale_,\n            token(sale_),\n            token_,\n            amount_\n        );\n        registerDeposit(sale_, token_, depositor_, amount_);\n    }\n\n    /// Any address can deposit any amount of its own `IERC20` under a `Sale`.\n    /// The `Sale` MUST be a child of the trusted factory.\n    /// The deposit will be accounted for under both the depositor individually\n    /// and the trust in aggregate. The aggregate value is used by `withdraw`\n    /// and the individual value by `undeposit`.\n    /// The depositor is responsible for approving the token for this contract.\n    /// `deposit` is still enabled after the distribution ends; `undeposit` is\n    /// always allowed in case of a fail and disabled on success. Multiple\n    /// `deposit` calls before and after a success result are supported. If a\n    /// depositor deposits when a raise has failed they will need to undeposit\n    /// it again manually.\n    /// Delegated `deposit` is not supported. Every depositor is directly\n    /// responsible for every `deposit`.\n    /// WARNING: As `undeposit` can only be called when the `Sale` reports\n    /// failure, `deposit` should only be called when the caller is sure the\n    /// `Sale` will reach a clear success/fail status. For example, when a\n    /// `Sale` has not yet been seeded it may never even start the raise so\n    /// depositing at this point is dangerous. If the `Sale` never starts the\n    /// raise it will never fail the raise either.\n    /// @param sale_ The `Sale` to assign this deposit to.\n    /// @param token_ The `IERC20` token to deposit to the escrow.\n    /// @param amount_ The amount of token to deposit. Requires depositor has\n    /// approved at least this amount to succeed.\n    function deposit(\n        address sale_,\n        address token_,\n        uint256 amount_\n    ) external {\n        registerDeposit(sale_, token_, msg.sender, amount_);\n        IERC20(token_).safeTransferFrom(msg.sender, address(this), amount_);\n    }\n\n    /// The inverse of `deposit`.\n    /// In the case of a failed distribution the depositors can claim back any\n    /// tokens they deposited in the escrow.\n    /// Ideally the distribution is a success and this does not need to be\n    /// called but it is important that we can walk back deposits and try again\n    /// for some future raise if needed.\n    /// Delegated `undeposit` is not supported, only the depositor can wind\n    /// back their original deposit.\n    /// `amount_` must be non-zero.\n    /// If several tokens have been deposited against a given trust for the\n    /// depositor then each token must be individually undeposited. There is\n    /// no onchain tracking or bulk processing for the depositor, they are\n    /// expected to know what they have previously deposited and if/when to\n    /// process an `undeposit`.\n    /// @param sale_ The `Sale` to undeposit from.\n    /// @param token_ The token to undeposit.\n    /// @param supply_ The total supply of the sale token associated with the\n    /// deposit being undeposited.\n    /// @param amount_ The amount to undeposit.\n    function undeposit(\n        address sale_,\n        address token_,\n        uint256 supply_,\n        uint256 amount_\n    ) external {\n        // Can only undeposit when the `Trust` reports failure.\n        require(escrowStatus(sale_) == EscrowStatus.Fail, \"NOT_FAIL\");\n        require(amount_ > 0, \"ZERO_AMOUNT\");\n\n        deposits[sale_][token_][msg.sender][supply_] -= amount_;\n        // Guard against outputs exceeding inputs.\n        // Last undeposit gets a gas refund.\n        totalDeposits[sale_][token_][supply_] -= amount_;\n        remainingDeposits[sale_][token_][supply_] -= amount_;\n\n        emit Undeposit(\n            msg.sender,\n            sale_,\n            // Include this in the event so that indexer consumers see a\n            // consistent world view even if the trust_ changes its answer\n            // about the redeemable.\n            token(sale_),\n            token_,\n            supply_,\n            amount_\n        );\n\n        IERC20(token_).safeTransfer(msg.sender, amount_);\n    }\n\n    /// The successful handover of a `deposit` to a recipient.\n    /// When a redeemable token distribution is successful the redeemable token\n    /// holders are automatically and immediately eligible to `withdraw` any\n    /// and all tokens previously deposited against the relevant `Sale`.\n    /// The `withdraw` can only happen if/when the relevant `Sale` reaches the\n    /// success distribution status.\n    /// Delegated `withdraw` is NOT supported. Every redeemable token holder is\n    /// directly responsible for being aware of and calling `withdraw`.\n    /// If a redeemable token holder calls `redeem` they also burn their claim\n    /// on any tokens held in escrow so they MUST first call `withdraw` THEN\n    /// `redeem`.\n    /// It is expected that the redeemable token holder knows about the tokens\n    /// that they will be withdrawing. This information is NOT tracked onchain\n    /// or exposed for bulk processing.\n    /// Partial `withdraw` is not supported, all tokens allocated to the caller\n    /// are withdrawn`. 0 amount withdrawal is an error, if the prorata share\n    /// of the token being claimed is small enough to round down to 0 then the\n    /// withdraw will revert.\n    /// Multiple withdrawals across multiple deposits is supported and is\n    /// equivalent to a single withdraw after all relevant deposits.\n    /// @param sale_ The trust to `withdraw` against.\n    /// @param token_ The token to `withdraw`.\n    /// @param supply_ The total supply of the sale token at time of deposit\n    /// to process this withdrawal against.\n    function withdraw(\n        address sale_,\n        address token_,\n        uint256 supply_\n    ) external {\n        // Can only withdraw when the `Trust` reports success.\n        require(escrowStatus(sale_) == EscrowStatus.Success, \"NOT_SUCCESS\");\n\n        uint256 totalDeposited_ = totalDeposits[sale_][token_][supply_];\n        uint256 withdrawn_ = withdrawals[sale_][token_][supply_][msg.sender];\n\n        RedeemableERC20 redeemable_ = RedeemableERC20(token(sale_));\n\n        withdrawals[sale_][token_][supply_][msg.sender] = totalDeposited_;\n\n        //solhint-disable-next-line max-line-length\n        uint256 amount_ = (// Underflow MUST error here (should not be possible).\n        (totalDeposited_ - withdrawn_) *\n            // prorata share of `msg.sender`'s current balance vs. supply\n            // as at the time deposit was made. If nobody burns they will\n            // all get a share rounded down by integer division. 100 split\n            // 3 ways will be 33 tokens each, leaving 1 TKN as escrow dust,\n            // for example. If someone burns before withdrawing they will\n            // receive less, so 0/33/33 from 100 with 34 TKN as escrow\n            // dust, for example.\n            redeemable_.balanceOf(msg.sender)) / supply_;\n\n        // Guard against outputs exceeding inputs.\n        // For example a malicious `Trust` could report a `redeemable_` token\n        // that does NOT freeze balances. In this case token holders can double\n        // spend their withdrawals by simply shuffling the same token around\n        // between accounts.\n        remainingDeposits[sale_][token_][supply_] -= amount_;\n\n        require(amount_ > 0, \"ZERO_WITHDRAW\");\n        emit Withdraw(\n            msg.sender,\n            sale_,\n            address(redeemable_),\n            token_,\n            supply_,\n            amount_\n        );\n        IERC20(token_).safeTransfer(msg.sender, amount_);\n    }\n}\n"
    },
    "contracts/escrow/SaleEscrow.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../sale/ISale.sol\";\n\n/// Represents the 3 possible statuses an escrow could care about.\n/// Either the escrow takes no action or consistently allows a success/fail\n/// action.\nenum EscrowStatus {\n    /// The underlying `Sale` has not reached a definitive pass/fail state.\n    /// Important this is the first item in the enum as inequality is used to\n    /// check pending vs. pass/fail in security sensitive code.\n    Pending,\n    /// The underlying `Sale` distribution failed.\n    Fail,\n    /// The underlying `Sale` distribution succeeded.\n    Success\n}\n\n/// @title SaleEscrow\n/// An escrow that is designed to work with untrusted `Sale` bytecode.\n/// `escrowStatus` wraps `Sale` functions to guarantee that results do not\n/// change. Reserve and token addresses never change for a given `Sale` and\n/// a pass/fail result is one-way. Even if some bug in the `Sale` causes the\n/// pass/fail status to flip, this will not result in the escrow double\n/// spending or otherwise changing the direction that it sends funds.\ncontract SaleEscrow {\n    /// ISale address => reserve address.\n    mapping(address => address) internal reserves;\n    /// ISale address => token address.\n    mapping(address => address) internal tokens;\n    /// ISale address => status.\n    mapping(address => EscrowStatus) internal escrowStatuses;\n\n    /// Immutable wrapper around `ISale.reserve`.\n    /// Once a `Sale` reports a reserve address the `SaleEscrow` never asks\n    /// again. Prevents a malicious `Sale` from changing the reserve at some\n    /// point to break internal escrow accounting.\n    /// @param sale_ The ISale to fetch reserve for.\n    function reserve(address sale_) internal returns (address) {\n        address reserve_ = reserves[sale_];\n        if (reserve_ == address(0)) {\n            address saleReserve_ = address(ISale(sale_).reserve());\n            require(saleReserve_ != address(0), \"0_RESERVE\");\n            reserves[sale_] = saleReserve_;\n            reserve_ = saleReserve_;\n        }\n        return reserve_;\n    }\n\n    /// Immutable wrapper around `ISale.token`.\n    /// Once a `Sale` reports a token address the `SaleEscrow` never asks\n    /// again. Prevents a malicious `Sale` from changing the token at some\n    /// point to divert escrow payments after assets have already been set\n    /// aside.\n    /// @param sale_ The ISale to fetch token for.\n    function token(address sale_) internal returns (address) {\n        address token_ = tokens[sale_];\n        if (token_ == address(0)) {\n            address saleToken_ = address(ISale(sale_).token());\n            require(saleToken_ != address(0), \"0_TOKEN\");\n            tokens[sale_] = saleToken_;\n            token_ = saleToken_;\n        }\n        return token_;\n    }\n\n    /// Read the one-way, one-time transition from pending to success/fail.\n    /// We never change our opinion of a success/fail outcome.\n    /// If a buggy/malicious `ISale` somehow changes success/fail state then\n    /// that is obviously bad as the escrow will release funds in the wrong\n    /// direction. But if we were to change our opinion that would be worse as\n    /// claims/refunds could potentially be \"double spent\" somehow.\n    /// @param sale_ The sale to get the escrow status for.\n    function escrowStatus(address sale_) internal returns (EscrowStatus) {\n        EscrowStatus escrowStatus_ = escrowStatuses[sale_];\n        // Short circuit and ignore the `ISale` if we previously saved a value.\n        if (escrowStatus_ > EscrowStatus.Pending) {\n            return escrowStatus_;\n        }\n        // We have never seen a success/fail outcome so need to ask the `ISale`\n        // for the distribution status.\n        else {\n            SaleStatus saleStatus_ = ISale(sale_).saleStatus();\n            // Success maps to success.\n            if (saleStatus_ == SaleStatus.Success) {\n                escrowStatuses[sale_] = EscrowStatus.Success;\n                return EscrowStatus.Success;\n            }\n            // Fail maps to fail.\n            else if (saleStatus_ == SaleStatus.Fail) {\n                escrowStatuses[sale_] = EscrowStatus.Fail;\n                return EscrowStatus.Fail;\n            }\n            // Everything else is still pending.\n            else {\n                return EscrowStatus.Pending;\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/wrappers/RedeemableERC20ClaimEscrowWrapper.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n//solhint-disable-next-line max-line-length\nimport {RedeemableERC20ClaimEscrow} from \"../../escrow/RedeemableERC20ClaimEscrow.sol\";\n\n/// @title RedeemableERC20ClaimEscrowWrapper\n/// Thin wrapper around the `RedeemableERC20ClaimEscrow` contract with\n/// accessors to facilitate hardhat unit testing of `internal` variables.\ncontract RedeemableERC20ClaimEscrowWrapper is RedeemableERC20ClaimEscrow {\n    function getWithdrawals(\n        address trust_,\n        address token_,\n        uint256 supply_,\n        address withdrawer_\n    ) external view returns (uint256) {\n        return withdrawals[trust_][token_][supply_][withdrawer_];\n    }\n\n    function getPendingDeposits(\n        address trust_,\n        address token_,\n        address depositor_\n    ) external view returns (uint256) {\n        return pendingDeposits[trust_][token_][depositor_];\n    }\n\n    function getDeposits(\n        address trust_,\n        address token_,\n        address depositor_,\n        uint256 supply_\n    ) external view returns (uint256) {\n        return deposits[trust_][token_][depositor_][supply_];\n    }\n\n    function getTotalDeposits(\n        address trust_,\n        address token_,\n        uint256 supply_\n    ) external view returns (uint256) {\n        return totalDeposits[trust_][token_][supply_];\n    }\n}\n"
    },
    "contracts/test/wrappers/SaleEscrowWrapper.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\n//solhint-disable-next-line max-line-length\nimport {SaleEscrow, EscrowStatus} from \"../../escrow/SaleEscrow.sol\";\n\n/// @title SaleEscrowWrapper\n/// Thin wrapper around the `SaleEscrow` contract with\n/// accessors to facilitate hardhat unit testing of `internal` functions\n/// and variables.\ncontract SaleEscrowWrapper is SaleEscrow {\n    function getReserve(address sale_) external view returns (address) {\n        return reserves[sale_];\n    }\n\n    function getToken(address sale_) external view returns (address) {\n        return tokens[sale_];\n    }\n\n    function getEscrowStatus(\n        address sale_\n    ) external view returns (EscrowStatus) {\n        return escrowStatuses[sale_];\n    }\n\n    function fetchReserve(address sale_) external {\n        reserve(sale_);\n    }\n\n    function fetchToken(address sale_) external {\n        token(sale_);\n    }\n\n    function fetchEscrowStatus(address sale_) external {\n        escrowStatus(sale_);\n    }\n}\n"
    },
    "contracts/test/MockISale.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../sale/ISale.sol\";\n\ncontract MockISale is ISale {\n    address public _reserve;\n    SaleStatus public _saleStatus;\n    address public _token;\n\n    function setReserve(address reserve_) external {\n        _reserve = reserve_;\n    }\n\n    function setSaleStatus(SaleStatus saleStatus_) external {\n        _saleStatus = saleStatus_;\n    }\n\n    function setToken(address token_) external {\n        _token = token_;\n    }\n\n    function reserve() external view returns (address) {\n        return _reserve;\n    }\n\n    function saleStatus() external view returns (SaleStatus) {\n        return _saleStatus;\n    }\n\n    function token() external view returns (address) {\n        return _token;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/rain-statusfi/GatedNFT.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\n// solhint-disable-next-line max-line-length\nimport { ITier } from \"@beehiveinnovation/rain-protocol/contracts/tier/ITier.sol\";\nimport { Base64 } from \"base64-sol/base64.sol\";\n// solhint-disable-next-line max-line-length\nimport { TierReport } from \"@beehiveinnovation/rain-protocol/contracts/tier/libraries/TierReport.sol\";\n// solhint-disable-next-line max-line-length\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport {IERC2981Upgradeable, IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/interfaces/IERC2981Upgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport { ERC721Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport { CountersUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\n\ncontract GatedNFT is\n    IERC165Upgradeable,\n    IERC2981Upgradeable,\n    ERC721Upgradeable,\n    OwnableUpgradeable\n{\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    event CreatedGatedNFT(\n        address contractAddress,\n        address creator,\n        Config config,\n        ITier tier,\n        uint256 minimumStatus,\n        uint256 maxPerAddress,\n        Transferrable transferrable,\n        uint256 maxMintable,\n        address royaltyRecipient,\n        uint256 royaltyBPS\n    );\n\n    event UpdatedRoyaltyRecipient(\n        address royaltyRecipient\n    );\n\n    struct Config {\n        string name;\n        string symbol;\n        string description;\n        string animationUrl;\n        string imageUrl;\n        bytes32 animationHash;\n        bytes32 imageHash;\n    }\n\n    enum Transferrable {\n        NonTransferrable,\n        Transferrable,\n        TierGatedTransferrable\n    }\n\n    CountersUpgradeable.Counter private tokenIdCounter;\n\n    Config private config;\n\n    ITier public tier;\n\n    uint256 private minimumStatus;\n\n    uint256 private maxPerAddress;\n\n    Transferrable private transferrable;\n\n    uint256 private maxMintable;\n\n    address private royaltyRecipient;\n\n    uint256 private royaltyBPS;\n\n    function initialize(\n        address owner_,\n        Config memory config_,\n        ITier tier_,\n        uint256 minimumStatus_,\n        uint256 maxPerAddress_,\n        Transferrable transferrable_,\n        uint256 maxMintable_,\n        address royaltyRecipient_,\n        uint256 royaltyBPS_\n    ) external initializer {\n        require(\n            royaltyRecipient_ != address(0),\n            \"Recipient cannot be 0 address\"\n        );\n        __ERC721_init(config_.name, config_.symbol);\n        __Ownable_init();\n        transferOwnership(owner_);\n        tier = ITier(tier_);\n        config = config_;\n        minimumStatus = minimumStatus_;\n        maxPerAddress = maxPerAddress_;\n        transferrable = transferrable_;\n        maxMintable = maxMintable_;\n        royaltyRecipient = royaltyRecipient_;\n        royaltyBPS = royaltyBPS_;\n        // Set tokenId to start at 1 instead of 0\n        tokenIdCounter.increment();\n\n        emit CreatedGatedNFT(\n            address(this),\n            owner_,\n            config_,\n            tier_,\n            minimumStatus_,\n            maxPerAddress_,\n            transferrable_,\n            maxMintable_,\n            royaltyRecipient_,\n            royaltyBPS_\n        );\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(_exists(tokenId), \"Nonexistent token\");\n        return base64JSONMetadata();\n    }\n\n    function mint(address to) external returns (uint256) {\n        require(\n            TierReport.tierAtBlockFromReport(\n                tier.report(to),\n                block.number\n            ) >= minimumStatus,\n            \"Address missing required tier\"\n        );\n        require(\n            balanceOf(to) < maxPerAddress,\n            \"Address has exhausted allowance\"\n        );\n        uint256 tokenId = tokenIdCounter.current();\n        require(tokenId <= maxMintable, \"Total supply exhausted\");\n        _safeMint(to, tokenId);\n        tokenIdCounter.increment();\n        return tokenId;\n    }\n\n    function royaltyInfo(uint256, uint256 salePrice_)\n        external\n        view\n        override\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        if (royaltyRecipient == address(0x0)) {\n            return (royaltyRecipient, 0);\n        }\n        return (royaltyRecipient, (salePrice_ * royaltyBPS) / 10_000);\n    }\n\n    function updateRoyaltyRecipient(address royaltyRecipient_) external\n    {\n        require(\n            royaltyRecipient_ != address(0),\n            \"Recipient cannot be 0 address\"\n        );\n        // solhint-disable-next-line reason-string\n        require(\n            msg.sender == royaltyRecipient,\n            \"Only current recipient can update\"\n        );\n\n        royaltyRecipient = royaltyRecipient_;\n\n        emit UpdatedRoyaltyRecipient(royaltyRecipient_);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) override internal virtual {\n        require(\n            transferrable != Transferrable.NonTransferrable,\n            \"Transfer not supported\"\n        );\n\n        if (transferrable == Transferrable.TierGatedTransferrable) {\n            require(\n                TierReport.tierAtBlockFromReport(\n                    tier.report(to),\n                    block.number\n                ) >= minimumStatus,\n                \"Address missing required tier\"\n            );\n        }\n\n        require(\n            balanceOf(to) < maxPerAddress,\n            \"Address has exhausted allowance\"\n        );\n\n        super._transfer(from, to, tokenId);\n    }\n\n    /// @dev returns the number of minted tokens\n    function totalSupply() external view returns (uint256) {\n        return tokenIdCounter.current() - 1;\n    }\n\n    function base64JSONMetadata()\n        internal\n        view\n        returns (string memory)\n    {\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64.encode(\n                        abi.encodePacked(\n                            // solhint-disable-next-line quotes\n                            '{\"name\": \"',\n                            config.name,\n                            // solhint-disable-next-line quotes\n                            '\", \"description\": \"',\n                            config.description,\n                            // solhint-disable-next-line quotes\n                            '\"',\n                            mediaJSONParts(),\n                            // solhint-disable-next-line quotes\n                            '}'\n                        )\n                    )\n                )\n            );\n    }\n\n    function mediaJSONParts() internal view returns (string memory) {\n        bool hasImage = bytes(config.imageUrl).length > 0;\n        bool hasAnimation = bytes(config.animationUrl).length > 0;\n        if (hasImage && hasAnimation) {\n            return\n                string(\n                    abi.encodePacked(\n                    // solhint-disable-next-line quotes\n                        ', \"image\": \"',\n                        config.imageUrl,\n                        // solhint-disable-next-line quotes\n                        '\", \"animation_url\": \"',\n                        config.animationUrl,\n                        // solhint-disable-next-line quotes\n                        '\"'\n                    )\n                );\n        }\n        if (hasImage) {\n            return\n                string(\n                    abi.encodePacked(\n                        // solhint-disable-next-line quotes\n                        ', \"image\": \"',\n                        config.imageUrl,\n                        // solhint-disable-next-line quotes\n                        '\"'\n                    )\n                );\n        }\n        if (hasAnimation) {\n            return\n                string(\n                    abi.encodePacked(\n                        // solhint-disable-next-line quotes\n                        ', \"animation_url\": \"',\n                        config.animationUrl,\n                        // solhint-disable-next-line quotes\n                        '\"'\n                    )\n                );\n        }\n        return \"\";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return\n            type(IERC2981Upgradeable).interfaceId == interfaceId ||\n            ERC721Upgradeable.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/tier/ITier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title ITier\n/// @notice `ITier` is a simple interface that contracts can\n/// implement to provide membership lists for other contracts.\n///\n/// There are many use-cases for a time-preserving conditional membership list.\n///\n/// Some examples include:\n///\n/// - Self-serve whitelist to participate in fundraising\n/// - Lists of users who can claim airdrops and perks\n/// - Pooling resources with implied governance/reward tiers\n/// - POAP style attendance proofs allowing access to future exclusive events\n///\n/// @dev Standard interface to a tiered membership.\n///\n/// A \"membership\" can represent many things:\n/// - Exclusive access.\n/// - Participation in some event or process.\n/// - KYC completion.\n/// - Combination of sub-memberships.\n/// - Etc.\n///\n/// The high level requirements for a contract implementing `ITier`:\n/// - MUST represent held tiers as a `uint`.\n/// - MUST implement `report`.\n///   - The report is a `uint256` that SHOULD represent the block each tier has\n///     been continuously held since encoded as `uint32`.\n///   - The encoded tiers start at `1`; Tier `0` is implied if no tier has ever\n///     been held.\n///   - Tier `0` is NOT encoded in the report, it is simply the fallback value.\n///   - If a tier is lost the block data is erased for that tier and will be\n///     set if/when the tier is regained to the new block.\n///   - If a tier is held but the historical block information is not available\n///     the report MAY return `0x00000000` for all held tiers.\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\n/// - SHOULD implement `setTier`.\n///   - Contracts SHOULD revert with `SET_TIER` error if they cannot\n///     meaningfully set a tier directly.\n///     For example a contract that can only derive a membership tier by\n///     reading the state of an external contract cannot set tiers.\n///   - Contracts implementing `setTier` SHOULD error with `SET_ZERO_TIER`\n///     if tier 0 is being set.\n/// - MUST emit `TierChange` when `setTier` successfully writes a new tier.\n///   - Contracts that cannot meaningfully set a tier are exempt.\n///\n/// So the four possible states and report values are:\n/// - Tier is held and block is known: Block is in the report\n/// - Tier is held but block is NOT known: `0` is in the report\n/// - Tier is NOT held: `0xFF..` is in the report\n/// - Tier is unknown: `0xFF..` is in the report\ninterface ITier {\n    /// Every time a tier changes we log start and end tier against the\n    /// account.\n    /// This MAY NOT be emitted if reports are being read from the state of an\n    /// external contract.\n    /// The start tier MAY be lower than the current tier as at the block this\n    /// event is emitted in.\n    /// @param sender The `msg.sender` that authorized the tier change.\n    /// @param account The account changing tier.\n    /// @param startTier The previous tier the account held.\n    /// @param endTier The newly acquired tier the account now holds.\n    /// @param data The associated data for the tier change.\n    event TierChange(\n        address sender,\n        address account,\n        uint256 startTier,\n        uint256 endTier,\n        bytes data\n    );\n\n    /// @notice Users can set their own tier by calling `setTier`.\n    ///\n    /// The contract that implements `ITier` is responsible for checking\n    /// eligibility and/or taking actions required to set the tier.\n    ///\n    /// For example, the contract must take/refund any tokens relevant to\n    /// changing the tier.\n    ///\n    /// Obviously the user is responsible for any approvals for this action\n    /// prior to calling `setTier`.\n    ///\n    /// When the tier is changed a `TierChange` event will be emmited as:\n    /// ```\n    /// event TierChange(address account, uint startTier, uint endTier);\n    /// ```\n    ///\n    /// The `setTier` function includes arbitrary data as the third\n    /// parameter. This can be used to disambiguate in the case that\n    /// there may be many possible options for a user to achieve some tier.\n    ///\n    /// For example, consider the case where tier 3 can be achieved\n    /// by EITHER locking 1x rare NFT or 3x uncommon NFTs. A user with both\n    /// could use `data` to explicitly state their intent.\n    ///\n    /// NOTE however that _any_ address can call `setTier` for any other\n    /// address.\n    ///\n    /// If you implement `data` or anything that changes state then be very\n    /// careful to avoid griefing attacks.\n    ///\n    /// The `data` parameter can also be ignored by the contract implementing\n    /// `ITier`. For example, ERC20 tokens are fungible so only the balance\n    /// approved by the user is relevant to a tier change.\n    ///\n    /// The `setTier` function SHOULD prevent users from reassigning\n    /// tier 0 to themselves.\n    ///\n    /// The tier 0 status represents never having any status.\n    /// @dev Updates the tier of an account.\n    ///\n    /// The implementing contract is responsible for all checks and state\n    /// changes required to set the tier. For example, taking/refunding\n    /// funds/NFTs etc.\n    ///\n    /// Contracts may disallow directly setting tiers, preferring to derive\n    /// reports from other onchain data.\n    /// In this case they should `revert(\"SET_TIER\");`.\n    ///\n    /// @param account Account to change the tier for.\n    /// @param endTier Tier after the change.\n    /// @param data Arbitrary input to disambiguate ownership\n    /// (e.g. NFTs to lock).\n    function setTier(\n        address account,\n        uint256 endTier,\n        bytes calldata data\n    ) external;\n\n    /// @notice A tier report is a `uint256` that contains each of the block\n    /// numbers each tier has been held continously since as a `uint32`.\n    /// There are 9 possible tier, starting with tier 0 for `0` offset or\n    /// \"never held any tier\" then working up through 8x 4 byte offsets to the\n    /// full 256 bits.\n    ///\n    /// Low bits = Lower tier.\n    ///\n    /// In hexadecimal every 8 characters = one tier, starting at tier 8\n    /// from high bits and working down to tier 1.\n    ///\n    /// `uint32` should be plenty for any blockchain that measures block times\n    /// in seconds, but reconsider if deploying to an environment with\n    /// significantly sub-second block times.\n    ///\n    /// ~135 years of 1 second blocks fit into `uint32`.\n    ///\n    /// `2^8 / (365 * 24 * 60 * 60)`\n    ///\n    /// When a user INCREASES their tier they keep all the block numbers they\n    /// already had, and get new block times for each increased tiers they have\n    /// earned.\n    ///\n    /// When a user DECREASES their tier they return to `0xFFFFFFFF` (never)\n    /// for every tier level they remove, but keep their block numbers for the\n    /// remaining tiers.\n    ///\n    /// GUIs are encouraged to make this dynamic very clear for users as\n    /// round-tripping to a lower status and back is a DESTRUCTIVE operation\n    /// for block times.\n    ///\n    /// The intent is that downstream code can provide additional benefits for\n    /// members who have maintained a certain tier for/since a long time.\n    /// These benefits can be provided by inspecting the report, and by\n    /// on-chain contracts directly,\n    /// rather than needing to work with snapshots etc.\n    /// @dev Returns the earliest block the account has held each tier for\n    /// continuously.\n    /// This is encoded as a uint256 with blocks represented as 8x\n    /// concatenated uint32.\n    /// I.e. Each 4 bytes of the uint256 represents a u32 tier start time.\n    /// The low bits represent low tiers and high bits the high tiers.\n    /// Implementing contracts should return 0xFFFFFFFF for lost and\n    /// never-held tiers.\n    ///\n    /// @param account Account to get the report for.\n    /// @return The report blocks encoded as a uint256.\n    function report(address account) external view returns (uint256);\n}\n"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/tier/libraries/TierReport.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {ITier} from \"../ITier.sol\";\nimport \"./TierConstants.sol\";\n\n/// @title TierReport\n/// @notice `TierReport` implements several pure functions that can be\n/// used to interface with reports.\n/// - `tierAtBlockFromReport`: Returns the highest status achieved relative to\n/// a block number and report. Statuses gained after that block are ignored.\n/// - `tierBlock`: Returns the block that a given tier has been held\n/// since according to a report.\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\n/// - `updateBlocksForTierRange`: Updates a report with a block\n/// number for every tier in a range.\n/// - `updateReportWithTierAtBlock`: Updates a report to a new tier.\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\n/// The low-level bit shifting can be difficult to get right so this\n/// factors that out.\nlibrary TierReport {\n    /// Enforce upper limit on tiers so we can do unchecked math.\n    /// @param tier_ The tier to enforce bounds on.\n    modifier maxTier(uint256 tier_) {\n        require(tier_ <= TierConstants.MAX_TIER, \"MAX_TIER\");\n        _;\n    }\n\n    /// Returns the highest tier achieved relative to a block number\n    /// and report.\n    ///\n    /// Note that typically the report will be from the _current_ contract\n    /// state, i.e. `block.number` but not always. Tiers gained after the\n    /// reference block are ignored.\n    ///\n    /// When the `report` comes from a later block than the `blockNumber` this\n    /// means the user must have held the tier continuously from `blockNumber`\n    /// _through_ to the report block.\n    /// I.e. NOT a snapshot.\n    ///\n    /// @param report_ A report as per `ITier`.\n    /// @param blockNumber_ The block number to check the tiers against.\n    /// @return The highest tier held since `blockNumber` as per `report`.\n    function tierAtBlockFromReport(uint256 report_, uint256 blockNumber_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            for (uint256 i_ = 0; i_ < 8; i_++) {\n                if (uint32(uint256(report_ >> (i_ * 32))) > blockNumber_) {\n                    return i_;\n                }\n            }\n            return TierConstants.MAX_TIER;\n        }\n    }\n\n    /// Returns the block that a given tier has been held since from a report.\n    ///\n    /// The report MUST encode \"never\" as 0xFFFFFFFF. This ensures\n    /// compatibility with `tierAtBlockFromReport`.\n    ///\n    /// @param report_ The report to read a block number from.\n    /// @param tier_ The Tier to read the block number for.\n    /// @return The block number this has been held since.\n    function tierBlock(uint256 report_, uint256 tier_)\n        internal\n        pure\n        maxTier(tier_)\n        returns (uint256)\n    {\n        unchecked {\n            // ZERO is a special case. Everyone has always been at least ZERO,\n            // since block 0.\n            if (tier_ == 0) {\n                return 0;\n            }\n\n            uint256 offset_ = (tier_ - 1) * 32;\n            return uint256(uint32(uint256(report_ >> offset_)));\n        }\n    }\n\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\n    ///\n    /// @param report_ Report to truncate with high bit 1s.\n    /// @param tier_ Tier to truncate above (exclusive).\n    /// @return Truncated report.\n    function truncateTiersAbove(uint256 report_, uint256 tier_)\n        internal\n        pure\n        maxTier(tier_)\n        returns (uint256)\n    {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            uint256 mask_ = (TierConstants.NEVER_REPORT >> offset_) << offset_;\n            return report_ | mask_;\n        }\n    }\n\n    /// Updates a report with a block number for a given tier.\n    /// More gas efficient than `updateBlocksForTierRange` if only a single\n    /// tier is being modified.\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\n    /// the block for tier `1`.\n    /// @param report_ Report to use as the baseline for the updated report.\n    /// @param tier_ The tier level to update.\n    /// @param blockNumber_ The new block number for `tier_`.\n    function updateBlockAtTier(\n        uint256 report_,\n        uint256 tier_,\n        uint256 blockNumber_\n    ) internal pure maxTier(tier_) returns (uint256) {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            return\n                (report_ &\n                    ~uint256(uint256(TierConstants.NEVER_TIER) << offset_)) |\n                uint256(blockNumber_ << offset_);\n        }\n    }\n\n    /// Updates a report with a block number for every tier in a range.\n    ///\n    /// Does nothing if the end status is equal or less than the start tier.\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier at the start of the range (exclusive).\n    /// @param endTier_ The tier at the end of the range (inclusive).\n    /// @param blockNumber_ The block number to set for every tier in the\n    /// range.\n    /// @return The updated report.\n    function updateBlocksForTierRange(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 blockNumber_\n    ) internal pure maxTier(endTier_) returns (uint256) {\n        unchecked {\n            uint256 offset_;\n            for (uint256 i_ = startTier_; i_ < endTier_; i_++) {\n                offset_ = i_ * 32;\n                report_ =\n                    (report_ &\n                        ~uint256(\n                            uint256(TierConstants.NEVER_TIER) << offset_\n                        )) |\n                    uint256(blockNumber_ << offset_);\n            }\n            return report_;\n        }\n    }\n\n    /// Updates a report to a new status.\n    ///\n    /// Internally dispatches to `truncateTiersAbove` and\n    /// `updateBlocksForTierRange`.\n    /// The dispatch is based on whether the new tier is above or below the\n    /// current tier.\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\n    /// It is expected the caller will know the current tier when\n    /// calling this function and need to do other things in the calling scope\n    /// with it.\n    ///\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier to start updating relative to. Data above\n    /// this tier WILL BE LOST so probably should be the current tier.\n    /// @param endTier_ The new highest tier held, at the given block number.\n    /// @param blockNumber_ The block number to update the highest tier to, and\n    /// intermediate tiers from `startTier_`.\n    /// @return The updated report.\n    function updateReportWithTierAtBlock(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 blockNumber_\n    ) internal pure returns (uint256) {\n        return\n            endTier_ < startTier_\n                ? truncateTiersAbove(report_, endTier_)\n                : updateBlocksForTierRange(\n                    report_,\n                    startTier_,\n                    endTier_,\n                    blockNumber_\n                );\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC2981Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be payed in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/tier/libraries/TierConstants.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title TierConstants\n/// @notice Constants for use with tier logic.\nlibrary TierConstants {\n    /// NEVER is 0xFF.. as it is infinitely in the future.\n    /// NEVER for an entire report.\n    uint256 internal constant NEVER_REPORT = type(uint256).max;\n    /// NEVER for a single tier.\n    uint32 internal constant NEVER_TIER = type(uint32).max;\n\n    /// Always is 0 as it is the genesis block.\n    /// Tiers can't predate the chain but they can predate an `ITier` contract.\n    uint256 internal constant ALWAYS = 0;\n\n    /// Account has never held a tier.\n    uint256 internal constant TIER_ZERO = 0;\n\n    /// Magic number for tier one.\n    uint256 internal constant TIER_ONE = 1;\n    /// Magic number for tier two.\n    uint256 internal constant TIER_TWO = 2;\n    /// Magic number for tier three.\n    uint256 internal constant TIER_THREE = 3;\n    /// Magic number for tier four.\n    uint256 internal constant TIER_FOUR = 4;\n    /// Magic number for tier five.\n    uint256 internal constant TIER_FIVE = 5;\n    /// Magic number for tier six.\n    uint256 internal constant TIER_SIX = 6;\n    /// Magic number for tier seven.\n    uint256 internal constant TIER_SEVEN = 7;\n    /// Magic number for tier eight.\n    uint256 internal constant TIER_EIGHT = 8;\n    /// Maximum tier is `TIER_EIGHT`.\n    uint256 internal constant MAX_TIER = TIER_EIGHT;\n}\n"
    },
    "contracts/rain-statusfi/GatedNFTFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport { GatedNFT } from \"./GatedNFT.sol\";\n// solhint-disable-next-line max-line-length\nimport { Factory } from \"@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol\";\n// solhint-disable-next-line max-line-length\nimport { ITier } from \"@beehiveinnovation/rain-protocol/contracts/tier/ITier.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ncontract GatedNFTFactory is Factory {\n    address private immutable implementation;\n\n    constructor() {\n        address implementation_ = address(new GatedNFT());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    function createChildTyped(\n        GatedNFT.Config memory config_,\n        ITier tier_,\n        uint256 minimumStatus_,\n        uint256 maxPerAddress_,\n        GatedNFT.Transferrable transferrable_,\n        uint256 maxMintable_,\n        address royaltyRecipient_,\n        uint256 royaltyBPS\n    ) external returns (GatedNFT) {\n        return GatedNFT(\n            this.createChild(\n                abi.encode(\n                    msg.sender,\n                    config_,\n                    tier_,\n                    minimumStatus_,\n                    maxPerAddress_,\n                    transferrable_,\n                    maxMintable_,\n                    royaltyRecipient_,\n                    royaltyBPS\n                )\n            )\n        );\n    }\n\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        (\n            address owner_,\n            GatedNFT.Config memory config_,\n            ITier tier_,\n            uint256 minimumStatus_,\n            uint256 maxPerAddress_,\n            GatedNFT.Transferrable transferrable_,\n            uint256 maxMintable_,\n            address royaltyRecipient_,\n            uint256 royaltyBPS_\n        ) = abi.decode(\n            data_,\n            (\n                address,\n                GatedNFT.Config,\n                ITier,\n                uint256,\n                uint256,\n                GatedNFT.Transferrable,\n                uint256,\n                address,\n                uint256\n            )\n        );\n\n        address clone_ = Clones.clone(implementation);\n\n        GatedNFT(clone_).initialize(\n            owner_,\n            config_,\n            tier_,\n            minimumStatus_,\n            maxPerAddress_,\n            transferrable_,\n            maxMintable_,\n            royaltyRecipient_,\n            royaltyBPS_\n        );\n\n        return clone_;\n    }\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IFactory} from \"./IFactory.sol\";\n// solhint-disable-next-line max-line-length\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Factory\n/// @notice Base contract for deploying and registering child contracts.\nabstract contract Factory is IFactory, ReentrancyGuard {\n    /// @dev state to track each deployed contract address. A `Factory` will\n    /// never lie about deploying a child, unless `isChild` is overridden to do\n    /// so.\n    mapping(address => bool) private contracts;\n\n    /// Implements `IFactory`.\n    ///\n    /// `_createChild` hook must be overridden to actually create child\n    /// contract.\n    ///\n    /// Implementers may want to overload this function with a typed equivalent\n    /// to expose domain specific structs etc. to the compiled ABI consumed by\n    /// tooling and other scripts. To minimise gas costs for deployment it is\n    /// expected that the tooling will consume the typed ABI, then encode the\n    /// arguments and pass them to this function directly.\n    ///\n    /// @param data_ ABI encoded data to pass to child contract constructor.\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        returns (address);\n\n    /// Implements `IFactory`.\n    ///\n    /// Calls the `_createChild` hook that inheriting contracts must override.\n    /// Registers child contract address such that `isChild` is `true`.\n    /// Emits `NewChild` event.\n    ///\n    /// @param data_ Encoded data to pass down to child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_)\n        external\n        virtual\n        override\n        nonReentrant\n        returns (address)\n    {\n        // Create child contract using hook.\n        address child_ = _createChild(data_);\n        // Ensure the child at this address has not previously been deployed.\n        require(!contracts[child_], \"DUPLICATE_CHILD\");\n        // Register child contract address to `contracts` mapping.\n        contracts[child_] = true;\n        // Emit `NewChild` event with child contract address.\n        emit IFactory.NewChild(msg.sender, child_);\n        return child_;\n    }\n\n    /// Implements `IFactory`.\n    ///\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// @param maybeChild_ Address of child contract to look up.\n    /// @return Returns `true` if address is a contract created by this\n    /// contract factory, otherwise `false`.\n    function isChild(address maybeChild_)\n        external\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return contracts[maybeChild_];\n    }\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/factory/IFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\ninterface IFactory {\n    /// Whenever a new child contract is deployed, a `NewChild` event\n    /// containing the new child contract address MUST be emitted.\n    /// @param sender `msg.sender` that deployed the contract (factory).\n    /// @param child address of the newly deployed child.\n    event NewChild(address sender, address child);\n\n    /// Factories that clone a template contract MUST emit an event any time\n    /// they set the implementation being cloned. Factories that deploy new\n    /// contracts without cloning do NOT need to emit this.\n    /// @param sender `msg.sender` that deployed the implementation (factory).\n    /// @param implementation address of the implementation contract that will\n    /// be used for future clones if relevant.\n    event Implementation(address sender, address implementation);\n\n    /// Creates a new child contract.\n    ///\n    /// @param data_ Domain specific data for the child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_) external returns (address);\n\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// Addresses that were not deployed by `createChild` MUST NOT return\n    /// `true` from `isChild`. This is CRITICAL to the security guarantees for\n    /// any contract implementing `IFactory`.\n    ///\n    /// @param maybeChild_ Address to check registration for.\n    /// @return `true` if address was deployed by this contract factory,\n    /// otherwise `false`.\n    function isChild(address maybeChild_) external view returns (bool);\n}\n"
    },
    "contracts/test/phased/PhasedTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Phased} from \"../../phased/Phased.sol\";\n\n/// @title PhasedTest\n/// Empty contract for tests enumerating behaviour of the `Phased` modifiers.\ncontract PhasedTest is Phased {\n    bool public condition = true;\n\n    constructor() {\n        initializePhased();\n    }\n\n    /// Exposes `schedulePhase` for testing.\n    /// @param phaseBlock_ As per `schedulePhase`.\n    function testScheduleNextPhase(uint256 phaseBlock_) external {\n        require(condition, \"CONDITION\");\n        schedulePhase(currentPhase() + 1, phaseBlock_);\n    }\n\n    /// This function wraps `onlyPhase` modifier, passing phase directly into\n    /// modifier argument.\n    /// @param phase_ Modifier MUST error if current phase is not `phase_`.\n    /// @return Always true if not error.\n    function runsOnlyPhase(uint256 phase_)\n        external\n        view\n        onlyPhase(phase_)\n        returns (bool)\n    {\n        return true;\n    }\n\n    /// This function wraps `onlyAtLeastPhase` modifier, passing phase directly\n    /// into modifier argument.\n    /// @param phase_ Modifier MUST error if current phase is not AT LEAST\n    /// `phase_`.\n    /// @return Always true if not error.\n    function runsOnlyAtLeastPhase(uint256 phase_)\n        external\n        view\n        onlyAtLeastPhase(phase_)\n        returns (bool)\n    {\n        return true;\n    }\n\n    /// Toggles `condition` for testing phase scheduling hook.\n    function toggleCondition() external {\n        condition = !condition;\n    }\n}\n"
    },
    "contracts/test/phased/PhasedScheduleTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Phased} from \"../../phased/Phased.sol\";\n\n/// @title PhasedScheduleTest\n/// Contract for testing phase hook functionality.\ncontract PhasedScheduleTest is Phased {\n    constructor() {\n        initializePhased();\n    }\n\n    /// Exposes `schedulePhase` for testing.\n    function testScheduleNextPhase() external {\n        uint256 initialPhase_ = currentPhase();\n\n        succeedsOnlyPhase(initialPhase_);\n        schedulePhase(initialPhase_ + 1, block.number);\n        succeedsOnlyPhase(initialPhase_ + 1);\n    }\n\n    /// Exposes `onlyPhase` for testing.\n    /// @param phase_ As per `onlyPhase`.\n    // solhint-disable-next-line no-empty-blocks\n    function succeedsOnlyPhase(uint256 phase_) internal onlyPhase(phase_) {}\n}\n"
    },
    "contracts/sale/SaleFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport \"./Sale.sol\";\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title SaleFactory\n/// @notice Factory for creating and deploying `Sale` contracts.\ncontract SaleFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address private immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor(SaleConstructorConfig memory config_) {\n        address implementation_ = address(new Sale(config_));\n        // silence slither.\n        require(implementation_ != address(0), \"0_IMPLEMENTATION\");\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        (\n            SaleConfig memory config_,\n            SaleRedeemableERC20Config memory saleRedeemableERC20Config_\n        ) = abi.decode(data_, (SaleConfig, SaleRedeemableERC20Config));\n        address clone_ = Clones.clone(implementation);\n        Sale(clone_).initialize(config_, saleRedeemableERC20Config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `SeedERC20Config` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `SaleConfig` constructor configuration.\n    /// @return New `Sale` child contract.\n    function createChildTyped(\n        SaleConfig calldata config_,\n        SaleRedeemableERC20Config calldata saleRedeemableERC20Config_\n    ) external returns (Sale) {\n        return\n            Sale(\n                this.createChild(\n                    abi.encode(config_, saleRedeemableERC20Config_)\n                )\n            );\n    }\n}\n"
    },
    "contracts/test/FixedPointMathOpsTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {RainVM, State, RAIN_VM_OPS_LENGTH} from \"../vm/RainVM.sol\";\nimport {VMState, StateConfig} from \"../vm/libraries/VMState.sol\";\nimport {FixedPointMathOps} from \"../vm/ops/math/FixedPointMathOps.sol\";\n\n/// @title FixedPointMathOpsTest\n/// Simple contract that exposes fixed point math ops for testing.\ncontract FixedPointMathOpsTest is RainVM, VMState {\n    uint256 private immutable fixedPointMathOpsStart;\n    address private immutable vmStatePointer;\n\n    constructor(StateConfig memory config_) {\n        /// These local opcode offsets are calculated as immutable but are\n        /// really just compile time constants. They only depend on the\n        /// imported libraries and contracts. These are calculated at\n        /// construction to future-proof against underlying ops being\n        /// added/removed and potentially breaking the offsets here.\n        fixedPointMathOpsStart = RAIN_VM_OPS_LENGTH;\n        vmStatePointer = _snapshot(_newState(config_));\n    }\n\n    /// @inheritdoc RainVM\n    function applyOp(\n        bytes memory,\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view override {\n        unchecked {\n            FixedPointMathOps.applyOp(\n                state_,\n                opcode_ - fixedPointMathOpsStart,\n                operand_\n            );\n        }\n    }\n\n    /// Wraps `runState` and returns top of stack.\n    /// @return top of `runState` stack.\n    function run() external view returns (uint256) {\n        State memory state_ = runState();\n        return state_.stack[state_.stackIndex - 1];\n    }\n\n    /// Runs `eval` and returns full state.\n    /// @return `State` after running own immutable source.\n    function runState() public view returns (State memory) {\n        State memory state_ = _restore(vmStatePointer);\n        eval(\"\", state_, 0);\n        return state_;\n    }\n}\n"
    },
    "contracts/test/ops/LogicOpsTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {RainVM, State, RAIN_VM_OPS_LENGTH} from \"../../vm/RainVM.sol\";\nimport {VMState, StateConfig} from \"../../vm/libraries/VMState.sol\";\nimport {LogicOps} from \"../../vm/ops/math/LogicOps.sol\";\n\n/// @title LogicOpsTest\n/// Simple contract that exposes logic ops for testing.\ncontract LogicOpsTest is RainVM, VMState {\n    uint256 private immutable logicOpsStart;\n    address private immutable vmStatePointer;\n\n    constructor(StateConfig memory config_) {\n        /// These local opcode offsets are calculated as immutable but are\n        /// really just compile time constants. They only depend on the\n        /// imported libraries and contracts. These are calculated at\n        /// construction to future-proof against underlying ops being\n        /// added/removed and potentially breaking the offsets here.\n        logicOpsStart = RAIN_VM_OPS_LENGTH;\n        vmStatePointer = _snapshot(_newState(config_));\n    }\n\n    /// @inheritdoc RainVM\n    function applyOp(\n        bytes memory,\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view override {\n        unchecked {\n            LogicOps.applyOp(state_, opcode_ - logicOpsStart, operand_);\n        }\n    }\n\n    /// Wraps `runState` and returns top of stack.\n    /// @return top of `runState` stack.\n    function run() external view returns (uint256) {\n        State memory state_ = runState();\n        return state_.stack[state_.stackIndex - 1];\n    }\n\n    /// Runs `eval` and returns full state.\n    /// @return `State` after running own immutable source.\n    function runState() public view returns (State memory) {\n        State memory state_ = _restore(vmStatePointer);\n        eval(\"\", state_, 0);\n        return state_;\n    }\n}\n"
    },
    "contracts/test/wrappers/ValueTierTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {ValueTier} from \"../../tier/ValueTier.sol\";\nimport {ITier} from \"../../tier/ITier.sol\";\n\n/// @title ValueTierTest\n///\n/// Thin wrapper around the `ValueTier` contract to facilitate hardhat unit\n/// testing of `internal` functions.\ncontract ValueTierTest is ValueTier {\n    /// Set the `tierValues` on construction to be referenced immutably.\n    constructor(uint256[8] memory tierValues_) {\n        initializeValueTier(tierValues_);\n    }\n\n    /// Wraps `tierToValue`.\n    function wrappedTierToValue(uint256 tier_) external view returns (uint256) {\n        return ValueTier.tierToValue(tierValues(), tier_);\n    }\n\n    /// Wraps `valueToTier`.\n    function wrappedValueToTier(uint256 value_)\n        external\n        view\n        returns (uint256)\n    {\n        return ValueTier.valueToTier(tierValues(), value_);\n    }\n}\n"
    },
    "contracts/test/wrappers/TierReportTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {ITier} from \"../../tier/ITier.sol\";\nimport {TierReport} from \"../../tier/libraries/TierReport.sol\";\n\n/// @title TierReportTest\n/// Thin wrapper around the `TierReport` library for hardhat unit testing.\ncontract TierReportTest {\n    /// Wraps `TierReport.tierAtBlockFromReport`.\n    /// @param report_ Forwarded to TierReport.\n    /// @param blockNumber_ Forwarded to TierReport.\n    function tierAtBlockFromReport(uint256 report_, uint256 blockNumber_)\n        external\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return TierReport.tierAtBlockFromReport(report_, blockNumber_);\n        }\n    }\n\n    /// Wraps `TierReport.tierBlock`.\n    /// @param report_ Forwarded to TierReport.\n    /// @param tier_ Forwarded to TierReport.\n    function tierBlock(uint256 report_, uint256 tier_)\n        external\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return TierReport.tierBlock(report_, tier_);\n        }\n    }\n\n    /// Wraps `TierReport.truncateTiersAbove`.\n    /// @param report_ Forwarded to TierReport.\n    /// @param tier_ Forwarded to TierReport.\n    function truncateTiersAbove(uint256 report_, uint256 tier_)\n        external\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return TierReport.truncateTiersAbove(report_, tier_);\n        }\n    }\n\n    /// Wraps `TierReport.updateBlocksForTierRange`.\n    /// @param report_ Forwarded to TestUtil.\n    /// @param startTier_ Forwarded to TestUtil.\n    /// @param endTier_ Forwarded to TestUtil.\n    /// @param blockNumber_ Forwarded to TestUtil.\n    function updateBlocksForTierRange(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 blockNumber_\n    ) external pure returns (uint256) {\n        unchecked {\n            return\n                TierReport.updateBlocksForTierRange(\n                    report_,\n                    startTier_,\n                    endTier_,\n                    blockNumber_\n                );\n        }\n    }\n\n    /// Wraps `TierReport.updateReportWithTierAtBlock`.\n    /// @param report_ Forwarded to TestUtil.\n    /// @param startTier_ Forwarded to TestUtil.\n    /// @param endTier_ Forwarded to TestUtil.\n    /// @param blockNumber_ Forwarded to TestUtil.\n    function updateReportWithTierAtBlock(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 blockNumber_\n    ) external pure returns (uint256) {\n        unchecked {\n            return\n                TierReport.updateReportWithTierAtBlock(\n                    report_,\n                    startTier_,\n                    endTier_,\n                    blockNumber_\n                );\n        }\n    }\n\n    /// Updates a report with a block number for a given tier.\n    /// More gas efficient than `updateBlocksForTierRange` if only a single\n    /// tier is being modified.\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\n    /// the block for tier `1`.\n    function updateBlockAtTier(\n        uint256 report_,\n        uint256 tier_,\n        uint256 blockNumber_\n    ) external pure returns (uint256) {\n        unchecked {\n            return\n                TierReport.updateBlockAtTier(\n                    report_,\n                    tier_,\n                    blockNumber_\n                );\n        }\n    }\n}\n"
    },
    "contracts/test/VerifyCallbackTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {IVerifyCallback, Evidence} from \"../verify/IVerifyCallback.sol\";\n\n// Test contract for testing Verify hooks after adding, approving, banning or\n// removing an account.\n// All logic here is for testing purposes and should not necessarily be used in\n// an actual Verify callback contract.\ncontract VerifyCallbackTest is IVerifyCallback {\n    /// Account => Boolean\n    mapping(address => bool) public additions;\n    mapping(address => bool) public approvals;\n    mapping(address => bool) public bans;\n    mapping(address => bool) public removals;\n\n    function afterAdd(\n        address adder_,\n        Evidence calldata evidence_\n    ) external virtual override {\n        require(adder_ != address(0), \"0_ADDRESS\");\n        require(!additions[evidence_.account], \"PRIOR_ADD\");\n        require(\n            keccak256(evidence_.data) == keccak256(bytes(\"Good\")),\n            \"BAD_EVIDENCE\"\n        );\n        additions[evidence_.account] = true;\n    }\n\n    function afterApprove(\n        address approver_,\n        Evidence[] calldata evidences_\n    ) external virtual override {\n        require(approver_ != address(0), \"0_ADDRESS\");\n        for (uint256 index = 0; index < evidences_.length; index++) {\n            require(!approvals[evidences_[index].account], \"PRIOR_APPROVE\");\n            require(\n                keccak256(evidences_[index].data) == keccak256(bytes(\"Good\")),\n                \"BAD_EVIDENCE\"\n            );\n            approvals[evidences_[index].account] = true;\n        }\n    }\n\n    function afterBan(\n        address banner_,\n        Evidence[] calldata evidences_\n    ) external virtual override {\n        require(banner_ != address(0), \"0_ADDRESS\");\n        for (uint256 index = 0; index < evidences_.length; index++) {\n            require(!bans[evidences_[index].account], \"PRIOR_BAN\");\n            require(\n                keccak256(evidences_[index].data) == keccak256(bytes(\"Good\")),\n                \"BAD_EVIDENCE\"\n            );\n            bans[evidences_[index].account] = true;\n        }\n    }\n\n    function afterRemove(\n        address remover_,\n        Evidence[] calldata evidences_\n    ) external virtual override {\n        require(remover_ != address(0), \"0_ADDRESS\");\n        for (uint256 index = 0; index < evidences_.length; index++) {\n            require(!removals[evidences_[index].account], \"PRIOR_REMOVE\");\n            require(\n                keccak256(evidences_[index].data) == keccak256(bytes(\"Good\")),\n                \"BAD_EVIDENCE\"\n            );\n            removals[evidences_[index].account] = true;\n        }\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "metadata": {
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}